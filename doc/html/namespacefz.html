<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Formalizer: fz Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="formalizer-logo-20200907-41x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Formalizer
   &#160;<span id="projectnumber">2.0.0-0.1</span>
   </div>
   <div id="projectbrief">The Formalizer System Support Environment</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">fz Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>On Ubuntu, to install the libpq libraries, including the libpq-fe.h header file, do: sudo apt-get install libpq-dev You may also have to add /usr/include or /usr/include/postgresql to the CPATH or to the includes in the Makefile, e.g.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1active__pq.html">active_pq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Communication info for active database connection and specified schema.  <a href="structfz_1_1active__pq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Breakpoint__pq.html">Breakpoint_pq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data types conversion helper class that can deliver the Postgres Breakpoints table equivalent INSERT value expression for all data content in a Breakpoints.  <a href="classfz_1_1Breakpoint__pq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1configbase.html">configbase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base component for Formalizer configuration file configuration parameter loading and parsing.  <a href="classfz_1_1configbase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1configurable.html">configurable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formalizer standard programs that can use configuration files should include a class that inherits <code>configurable</code> and that provides method implementation for <code><a class="el" href="classfz_1_1configbase.html#ab54418af1a3fd4f99c9433fa76760912" title="This method must be defined in configurable Formalizer components and programs that define a class in...">set_parameter()</a></code>.  <a href="classfz_1_1configurable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Edge.html">Edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Edge__ID.html">Edge_ID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfz_1_1Edge.html">Edge</a> ID that caches its ID stamp for frequent use.  <a href="classfz_1_1Edge__ID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Edge__ID__key.html">Edge_ID_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standardized Formalizer <a class="el" href="classfz_1_1Edge.html">Edge</a> ID key.  <a href="structfz_1_1Edge__ID__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Edge__pq.html">Edge_pq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data types conversion helper class that can deliver the Postgres <a class="el" href="classfz_1_1Edge.html">Edge</a> table equivalent INSERT value expression for all data content in an <a class="el" href="classfz_1_1Edge.html">Edge</a>.  <a href="classfz_1_1Edge__pq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1err__configbase.html">err_configbase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Error__Instance.html">Error_Instance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Errors.html">Errors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintain a queue of recent errors encountered in ErrQ and provide them on demand.  <a href="classfz_1_1Errors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1formalizer__base__streams.html">formalizer_base_streams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The standardized structure for standard stream redirection.  <a href="structfz_1_1formalizer__base__streams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1formalizer__standard__program.html">formalizer_standard_program</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a framework for standardized Formalizer programs.  <a href="classfz_1_1formalizer__standard__program.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1fzpq__configurable.html">fzpq_configurable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Graph.html">Graph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Graph__access.html">Graph_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A standardized way to access the <a class="el" href="classfz_1_1Graph.html">Graph</a> database.  <a href="structfz_1_1Graph__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Guide__snippet.html">Guide_snippet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic data structure for Guide snippets.  <a href="structfz_1_1Guide__snippet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1ID__exception.html">ID_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declared here for reference before further detailing.  <a href="classfz_1_1ID__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1ID__TimeStamp.html">ID_TimeStamp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timestamp IDs in the format required for <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> IDs.  <a href="structfz_1_1ID__TimeStamp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html">Log</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><h3><a class="el" href="classfz_1_1Log.html" title="Log">Log</a></h3>
 <a href="classfz_1_1Log.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__Breakpoints.html">Log_Breakpoints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><h3><a class="el" href="classfz_1_1Log.html" title="Log">Log</a> Breakpoints (section starts)</h3>
 <a href="classfz_1_1Log__Breakpoints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__by__Node__chainable.html">Log_by_Node_chainable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> components that are chainable as belonging to a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a>.  <a href="classfz_1_1Log__by__Node__chainable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This data structure is used to follow a chain by-Node through the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> that can lead to <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks or <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries.  <a href="structfz_1_1Log__chain__target.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the start time, <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a>, close time, and set of entries of a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk.  <a href="classfz_1_1Log__chunk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__chunk__ID.html">Log_chunk_ID</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standardized Formalizer <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk ID key.  <a href="structfz_1_1Log__chunk__ID__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Log__chunks__Deque.html">Log_chunks_Deque</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><h3><a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks (deque list)</h3>
 <a href="structfz_1_1Log__chunks__Deque.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__data.html">Log_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfz_1_1Log.html" title="Log">Log</a> data base class providing shared parameters and functions.  <a href="classfz_1_1Log__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__entry.html">Log_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__entry__ID.html">Log_entry_ID</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standardized Formalizer <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry ID key.  <a href="structfz_1_1Log__entry__ID__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__interval.html">Log_interval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variant of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> is used by smart on-demand <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> caching modes.  <a href="classfz_1_1Log__interval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Log__target.html">Log_target</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfz_1_1Log.html" title="Log">Log</a> objects are principally identified by their ID key, but when used as a linked target, e.g.  <a href="structfz_1_1Log__target.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timestamp IDs in the format required for <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> IDs.  <a href="structfz_1_1Log__TimeStamp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Logchunk__pq.html">Logchunk_pq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data types conversion helper class that can deliver the Postgres <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk table equivalent INSERT value expression for all data content in a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk.  <a href="classfz_1_1Logchunk__pq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Logentry__pq.html">Logentry_pq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data types conversion helper class that can deliver the Postgres <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries table equivalent INSERT value expression for all data content in a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry.  <a href="classfz_1_1Logentry__pq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1main__init__register.html">main_init_register</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes that need an initialization function to be called first-thing upon entering <code>main()</code> (but not before that in the hazardous global variables constructor calls phase) should inherit this class.  <a href="classfz_1_1main__init__register.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> class is the principal object type within a Formalizer <a class="el" href="classfz_1_1Graph.html">Graph</a>.  <a href="classfz_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Node__ID.html">Node_ID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> ID that caches its ID stamp for frequent use.  <a href="classfz_1_1Node__ID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standardized Formalizer <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> ID key.  <a href="structfz_1_1Node__ID__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Node__pq.html">Node_pq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data types conversion helper class that can deliver the Postgres <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> table equivalent INSERT value expression for all data content in a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a>.  <a href="classfz_1_1Node__pq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Node__Targets__cursor.html">Node_Targets_cursor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used by <code>Log::setup_Chunk_nodeprevnext()</code> to build a proper chain.  <a href="structfz_1_1Node__Targets__cursor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A standardized way to access the Formalizer database.  <a href="structfz_1_1Postgres__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1ReferenceTime.html">ReferenceTime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1render__environment.html">render_environment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration for a template rendering environment.  <a href="structfz_1_1render__environment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1render__varpos.html">render_varpos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Simulate__PQ__Changes.html">Simulate_PQ_Changes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simulation class that enables Postgres call testing.  <a href="classfz_1_1Simulate__PQ__Changes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Stack__Tracer.html">Stack_Tracer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used to collaboratively maintain a stack trace for use in both logged errors and exception handling.  <a href="structfz_1_1Stack__Tracer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1template__variable__values.html">template_variable_values</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1template__varvalues.html">template_varvalues</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1the__standard__object.html">the_standard_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure registers a <code>standard</code> object with a set of expected parameters and functions for any standardized Formalizer program.  <a href="structfz_1_1the__standard__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Topic.html">Topic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for real-valued <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> relevance (of <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a>), presently assumed to be in the interval [0.0,1.0].  <a href="classfz_1_1Topic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Topic__Keyword.html">Topic_Keyword</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for real-valued Keyword relevance (to <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a>), presently assumed to be in the interval [0.0,1.0].  <a href="structfz_1_1Topic__Keyword.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Topic__pq.html">Topic_pq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data types conversion helper class that can deliver the Postgres Topics table equivalent INSERT value expression for all data content in a <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a>.  <a href="classfz_1_1Topic__pq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Topic__Tags.html">Topic_Tags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> tag data, arranged by integer Index-ID.  <a href="classfz_1_1Topic__Tags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Trace__This.html">Trace_This</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a34ec4a9353f556467845f99dfd43a9aa"><td class="memItemLeft" align="right" valign="top"><a id="a34ec4a9353f556467845f99dfd43a9aa"></a>
typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a34ec4a9353f556467845f99dfd43a9aa">StackTrace</a></td></tr>
<tr class="memdesc:a34ec4a9353f556467845f99dfd43a9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defining this type for easy swap-in/out of vector, deque, or other container types. <br /></td></tr>
<tr class="separator:a34ec4a9353f556467845f99dfd43a9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90159dddcbd84757ff883b64042ea46a"><td class="memItemLeft" align="right" valign="top"><a id="a90159dddcbd84757ff883b64042ea46a"></a>
typedef float&#160;</td><td class="memItemRight" valign="bottom"><b>Keyword_Relevance</b></td></tr>
<tr class="separator:a90159dddcbd84757ff883b64042ea46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afddacf07ad964643983aa625bd00aba8"><td class="memItemLeft" align="right" valign="top"><a id="afddacf07ad964643983aa625bd00aba8"></a>
typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>Topic_ID</b></td></tr>
<tr class="separator:afddacf07ad964643983aa625bd00aba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef696382cc8a859adcdb76740012048"><td class="memItemLeft" align="right" valign="top"><a id="a4ef696382cc8a859adcdb76740012048"></a>
typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a4ef696382cc8a859adcdb76740012048">Topic_Relevance</a></td></tr>
<tr class="memdesc:a4ef696382cc8a859adcdb76740012048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for unique <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> IDs. <br /></td></tr>
<tr class="separator:a4ef696382cc8a859adcdb76740012048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ec4277595878f1f77ac6a29bdf24a8"><td class="memItemLeft" align="right" valign="top"><a id="a71ec4277595878f1f77ac6a29bdf24a8"></a>
typedef std::vector&lt; <a class="el" href="classfz_1_1Topic.html">Topic</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Topic_Tags_Vector</b></td></tr>
<tr class="separator:a71ec4277595878f1f77ac6a29bdf24a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9db5b90dfbfb5dc9a5e41a142f667f"><td class="memItemLeft" align="right" valign="top"><a id="afd9db5b90dfbfb5dc9a5e41a142f667f"></a>
typedef std::map&lt; Topic_ID, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Topics_Set</b></td></tr>
<tr class="separator:afd9db5b90dfbfb5dc9a5e41a142f667f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cb31bb2e4314340751a857568610fe"><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; <a class="el" href="classfz_1_1Edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a22cb31bb2e4314340751a857568610fe">Edges_Set</a></td></tr>
<tr class="memdesc:a22cb31bb2e4314340751a857568610fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">targetdate: For details, see the description at <a href="https://docs.google.com/document/d/1rYPFgzFgjkF1xGx3uABiXiaDR5sfmOzqYQRqSntcyyY/edit#heading=h.nu3mb52d1k6n">https://docs.google.com/document/d/1rYPFgzFgjkF1xGx3uABiXiaDR5sfmOzqYQRqSntcyyY/edit#heading=h.nu3mb52d1k6n</a>.  <a href="#a22cb31bb2e4314340751a857568610fe">More...</a><br /></td></tr>
<tr class="separator:a22cb31bb2e4314340751a857568610fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f704d7393e5b2d14f9095f8210ce4a"><td class="memItemLeft" align="right" valign="top"><a id="a41f704d7393e5b2d14f9095f8210ce4a"></a>
typedef std::map&lt; <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a>, <a class="el" href="classfz_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Node_Map</b></td></tr>
<tr class="separator:a41f704d7393e5b2d14f9095f8210ce4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722a9e6a79f45a3980877988f9984b63"><td class="memItemLeft" align="right" valign="top"><a id="a722a9e6a79f45a3980877988f9984b63"></a>
typedef std::map&lt; <a class="el" href="structfz_1_1Edge__ID__key.html">Edge_ID_key</a>, <a class="el" href="classfz_1_1Edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Edge_Map</b></td></tr>
<tr class="separator:a722a9e6a79f45a3980877988f9984b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c125ce4a1d727d1fa039f07d6e6b15"><td class="memItemLeft" align="right" valign="top"><a id="af5c125ce4a1d727d1fa039f07d6e6b15"></a>
typedef std::vector&lt; <a class="el" href="classfz_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Node_Index</b></td></tr>
<tr class="separator:af5c125ce4a1d727d1fa039f07d6e6b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005101cd3360f7440301c8c033b397f8"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; const <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a>, std::unique_ptr&lt; <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a005101cd3360f7440301c8c033b397f8">Log_entries_Map</a></td></tr>
<tr class="memdesc:a005101cd3360f7440301c8c033b397f8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><h3><a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries (map)</h3>
 <a href="#a005101cd3360f7440301c8c033b397f8">More...</a><br /></td></tr>
<tr class="separator:a005101cd3360f7440301c8c033b397f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33950887af9a1dfe223b82b40edc2b1f"><td class="memItemLeft" align="right" valign="top"><a id="a33950887af9a1dfe223b82b40edc2b1f"></a>
typedef std::pair&lt; Log_entries_Map::iterator, Log_entries_Map::iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a33950887af9a1dfe223b82b40edc2b1f">Log_entry_iterator_interval</a></td></tr>
<tr class="memdesc:a33950887af9a1dfe223b82b40edc2b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interval type for the Log_entries_Map;. <br /></td></tr>
<tr class="separator:a33950887af9a1dfe223b82b40edc2b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac6ef6feef733ab3e80d6b13d788618"><td class="memItemLeft" align="right" valign="top"><a id="a5ac6ef6feef733ab3e80d6b13d788618"></a>
typedef std::deque&lt; std::unique_ptr&lt; <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a5ac6ef6feef733ab3e80d6b13d788618">Log_chunk_ptr_deque</a></td></tr>
<tr class="memdesc:a5ac6ef6feef733ab3e80d6b13d788618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for this container type. <br /></td></tr>
<tr class="separator:a5ac6ef6feef733ab3e80d6b13d788618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54d7dcc5daf1d7c28a31a9ea2f2064a"><td class="memItemLeft" align="right" valign="top"><a id="ac54d7dcc5daf1d7c28a31a9ea2f2064a"></a>
typedef std::pair&lt; Log_chunk_ptr_deque::size_type, Log_chunk_ptr_deque::size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ac54d7dcc5daf1d7c28a31a9ea2f2064a">Log_chunk_index_interval</a></td></tr>
<tr class="memdesc:ac54d7dcc5daf1d7c28a31a9ea2f2064a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interval types for the <a class="el" href="structfz_1_1Log__chunks__Deque.html" title="Log chunks (deque list)">Log_chunks_Deque</a>. <br /></td></tr>
<tr class="separator:ac54d7dcc5daf1d7c28a31a9ea2f2064a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c3dec7a01d6cd67e148cbe8068787a"><td class="memItemLeft" align="right" valign="top"><a id="a75c3dec7a01d6cd67e148cbe8068787a"></a>
typedef std::pair&lt; <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a>, <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_chunk_ID_interval</b></td></tr>
<tr class="separator:a75c3dec7a01d6cd67e148cbe8068787a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19097fed21f7b5e73117677bb009ba08"><td class="memItemLeft" align="right" valign="top"><a id="a19097fed21f7b5e73117677bb009ba08"></a>
typedef std::deque&lt; <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a19097fed21f7b5e73117677bb009ba08">Log_chunk_ID_key_deque</a></td></tr>
<tr class="memdesc:a19097fed21f7b5e73117677bb009ba08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for this container type. <br /></td></tr>
<tr class="separator:a19097fed21f7b5e73117677bb009ba08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fa686034d8685dd4cd88b74e9e5132"><td class="memItemLeft" align="right" valign="top"><a id="a03fa686034d8685dd4cd88b74e9e5132"></a>
typedef <a class="el" href="structfz_1_1Log__target.html">Log_target</a>&lt; <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a>, <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_chunk_target</b></td></tr>
<tr class="separator:a03fa686034d8685dd4cd88b74e9e5132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b4d76cf439608a0de4a4d1282c742f"><td class="memItemLeft" align="right" valign="top"><a id="ae0b4d76cf439608a0de4a4d1282c742f"></a>
typedef <a class="el" href="structfz_1_1Log__target.html">Log_target</a>&lt; <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a>, <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_entry_target</b></td></tr>
<tr class="separator:ae0b4d76cf439608a0de4a4d1282c742f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7628e7ec4a0b6dd62dd1b38614ae2944"><td class="memItemLeft" align="right" valign="top"><a id="a7628e7ec4a0b6dd62dd1b38614ae2944"></a>
typedef std::pair&lt; bool, <a class="el" href="classfz_1_1Log__data.html">Log_data</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_ptr_pair</b></td></tr>
<tr class="separator:a7628e7ec4a0b6dd62dd1b38614ae2944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fad9a0772bcfce865af13b7a659a4c6"><td class="memItemLeft" align="right" valign="top"><a id="a4fad9a0772bcfce865af13b7a659a4c6"></a>
typedef std::tuple&lt; bool, <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a>, <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_key_tuple</b></td></tr>
<tr class="separator:a4fad9a0772bcfce865af13b7a659a4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa45880b9bbad1bcf026d98b71df765"><td class="memItemLeft" align="right" valign="top"><a id="affa45880b9bbad1bcf026d98b71df765"></a>
typedef std::tuple&lt; bool, <a class="el" href="structfz_1_1Log__target.html">Log_chunk_target</a>, <a class="el" href="structfz_1_1Log__target.html">Log_entry_target</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_target_tuple</b></td></tr>
<tr class="separator:affa45880b9bbad1bcf026d98b71df765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac707a16b6f3ce32e16ceeb269cb05967"><td class="memItemLeft" align="right" valign="top"><a id="ac707a16b6f3ce32e16ceeb269cb05967"></a>
typedef std::vector&lt; <a class="el" href="structfz_1_1render__varpos.html">render_varpos</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>template_varpos</b></td></tr>
<tr class="separator:ac707a16b6f3ce32e16ceeb269cb05967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6816aa2a6ca096b5918902e6e261cc68"><td class="memItemLeft" align="right" valign="top"><a id="a6816aa2a6ca096b5918902e6e261cc68"></a>
typedef std::tuple&lt; unsigned int, unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ymd_tuple</b></td></tr>
<tr class="separator:a6816aa2a6ca096b5918902e6e261cc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab6fa1d38b1f961757e7f352be3764d8f"><td class="memItemLeft" align="right" valign="top"><a id="ab6fa1d38b1f961757e7f352be3764d8f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>pq_Tfields</b> { <br />
&#160;&#160;<b>pqt_id</b>, 
<b>pqt_supid</b>, 
<b>pqt_tag</b>, 
<b>pqt_title</b>, 
<br />
&#160;&#160;<b>pqt_keyword</b>, 
<b>pqt_relevance</b>, 
<b>_pqt_NUM</b>
<br />
 }</td></tr>
<tr class="separator:ab6fa1d38b1f961757e7f352be3764d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7349c0b699f57fccff3f53513df94839"><td class="memItemLeft" align="right" valign="top"><a id="a7349c0b699f57fccff3f53513df94839"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>pq_Nfields</b> { <br />
&#160;&#160;<b>pqn_id</b>, 
<b>pqn_topics</b>, 
<b>pqn_topicrelevance</b>, 
<b>pqn_valuation</b>, 
<br />
&#160;&#160;<b>pqn_completion</b>, 
<b>pqn_required</b>, 
<b>pqn_text</b>, 
<b>pqn_targetdate</b>, 
<br />
&#160;&#160;<b>pqn_tdproperty</b>, 
<b>pqn_isperiodic</b>, 
<b>pqn_tdperiodic</b>, 
<b>pqn_tdevery</b>, 
<br />
&#160;&#160;<b>pqn_tdspan</b>, 
<b>_pqn_NUM</b>
<br />
 }</td></tr>
<tr class="separator:a7349c0b699f57fccff3f53513df94839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbebf38d141f22704b7eedd52437b28"><td class="memItemLeft" align="right" valign="top"><a id="a2fbebf38d141f22704b7eedd52437b28"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>pq_Efields</b> { <br />
&#160;&#160;<b>pqe_id</b>, 
<b>pqe_dependency</b>, 
<b>pqe_significance</b>, 
<b>pqe_importance</b>, 
<br />
&#160;&#160;<b>pqe_urgency</b>, 
<b>pqe_priority</b>, 
<b>_pqe_NUM</b>
<br />
 }</td></tr>
<tr class="separator:a2fbebf38d141f22704b7eedd52437b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c45e5e183774ed3322e5c3d445b3f70"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">td_property</a> { <br />
&#160;&#160;<b>unspecified</b>, 
<b>inherit</b>, 
<b>variable</b>, 
<b>fixed</b>, 
<br />
&#160;&#160;<b>exact</b>, 
<b>_tdprop_num</b>
<br />
 }<tr class="memdesc:a6c45e5e183774ed3322e5c3d445b3f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">For more information about td_property values, as well as future expansions, please see the Formalizer documentation section <a href="https://docs.google.com/document/d/1rYPFgzFgjkF1xGx3uABiXiaDR5sfmOzqYQRqSntcyyY/edit#heading=h.nu3mb52d1k6n">Target date parameters in Graph v2.0+</a>.  <a href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6c45e5e183774ed3322e5c3d445b3f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457fe66ad9a864a8062ed33117e53841"><td class="memItemLeft" align="right" valign="top"><a id="a457fe66ad9a864a8062ed33117e53841"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>td_pattern</b> { <br />
&#160;&#160;<b>patt_daily</b>, 
<b>patt_workdays</b>, 
<b>patt_weekly</b>, 
<b>patt_biweekly</b>, 
<br />
&#160;&#160;<b>patt_monthly</b>, 
<b>patt_endofmonthoffset</b>, 
<b>patt_yearly</b>, 
<b>OLD_patt_span</b>, 
<br />
&#160;&#160;<b>patt_nonperiodic</b>, 
<b>_patt_num</b>
<br />
 }</td></tr>
<tr class="separator:a457fe66ad9a864a8062ed33117e53841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd9cd34cd3b99c03b59b7054f5709df"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a6fd9cd34cd3b99c03b59b7054f5709df">pq_LBfields</a> { <b>pqlb_id</b>, 
<b>_pqlb_NUM</b>
 }<tr class="memdesc:a6fd9cd34cd3b99c03b59b7054f5709df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log Breakpoint fields:  <a href="namespacefz.html#a6fd9cd34cd3b99c03b59b7054f5709df">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6fd9cd34cd3b99c03b59b7054f5709df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229dcedb04cce4ee361097ae545fec1a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a229dcedb04cce4ee361097ae545fec1a">pq_LCfields</a> { <b>pqlc_id</b>, 
<b>pqlc_nid</b>, 
<b>pqlc_tclose</b>, 
<b>_pqlc_NUM</b>
 }<tr class="memdesc:a229dcedb04cce4ee361097ae545fec1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log chunk fields:  <a href="namespacefz.html#a229dcedb04cce4ee361097ae545fec1a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a229dcedb04cce4ee361097ae545fec1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adf8c508a2a57973cb07be9a12d345f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a1adf8c508a2a57973cb07be9a12d345f">pq_LEfields</a> { <b>pqle_id</b>, 
<b>pqle_nid</b>, 
<b>pqle_text</b>, 
<b>_pqle_NUM</b>
 }<tr class="memdesc:a1adf8c508a2a57973cb07be9a12d345f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log entry fields:  <a href="namespacefz.html#a1adf8c508a2a57973cb07be9a12d345f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a1adf8c508a2a57973cb07be9a12d345f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef05dd6bfa4d4a09d3eace4949b6fab0"><td class="memItemLeft" align="right" valign="top"><a id="aef05dd6bfa4d4a09d3eace4949b6fab0"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ReferenceTime_t</b> : std::time_t { <b>RTt_invalid_time_stamp</b> = -34403, 
<b>RTt_unspecified</b> = -1, 
<b>RTt_unix_epoch_start</b> = 0
 }</td></tr>
<tr class="separator:aef05dd6bfa4d4a09d3eace4949b6fab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a7b508456ccb1691f487ed136d52d4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a95a7b508456ccb1691f487ed136d52d4">exit_status_code</a> { <br />
&#160;&#160;<b>exit_ok</b>, 
<b>exit_general_error</b>, 
<b>exit_database_error</b>, 
<b>exit_unknown_option</b>, 
<br />
&#160;&#160;<b>exit_cancel</b>, 
<b>exit_conversion_error</b>, 
<b>exit_DIL_error</b>, 
<b>exit_unable_to_stack_clean_exit</b>, 
<br />
&#160;&#160;<b>exit_command_line_error</b>, 
<b>exit_file_error</b>, 
<a class="el" href="namespacefz.html#a95a7b508456ccb1691f487ed136d52d4a705b1561a859fa4dfba9b3e3045d9f24">exit_NUMENUMS</a>
<br />
 }<tr class="memdesc:a95a7b508456ccb1691f487ed136d52d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standardized exit codes for the Formalizer environment.  <a href="namespacefz.html#a95a7b508456ccb1691f487ed136d52d4">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a95a7b508456ccb1691f487ed136d52d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbc7396c54a5297ce62bfad68c98cb2"><td class="memItemLeft" align="right" valign="top"><a id="a2cbc7396c54a5297ce62bfad68c98cb2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>render_error_t</b> { <br />
&#160;&#160;<b>rerr_ok</b> = 0, 
<b>rerr_missing_value</b> = 1, 
<b>rerr_empty_template</b> = 2, 
<b>rerr_no_variable_values</b> = 3, 
<br />
&#160;&#160;<b>rerr_empty_variable_label</b> = 4, 
<b>rerr_unused_variable_value</b> = 5
<br />
 }</td></tr>
<tr class="separator:a2cbc7396c54a5297ce62bfad68c98cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a20fc3f13405d901ac7ecbf65ae2ae712"><td class="memItemLeft" align="right" valign="top"><a id="a20fc3f13405d901ac7ecbf65ae2ae712"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>coreversion</b> ()</td></tr>
<tr class="separator:a20fc3f13405d901ac7ecbf65ae2ae712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7838e7b982bd5a885f69f42a8fa929c"><td class="memItemLeft" align="right" valign="top">Detailed_Items_List *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aa7838e7b982bd5a885f69f42a8fa929c">get_DIL_Graph</a> ()</td></tr>
<tr class="memdesc:aa7838e7b982bd5a885f69f42a8fa929c"><td class="mdescLeft">&#160;</td><td class="mdescRight">To USE and COMPILE :  <a href="#aa7838e7b982bd5a885f69f42a8fa929c">More...</a><br /></td></tr>
<tr class="separator:aa7838e7b982bd5a885f69f42a8fa929c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004bd737f1c412b124eaf7ca6df90603"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a004bd737f1c412b124eaf7ca6df90603">get_DIL_Topics_File_List</a> ()</td></tr>
<tr class="memdesc:a004bd737f1c412b124eaf7ca6df90603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the actual set of Topical DIL Files that exist in the dil2al base directory.  <a href="#a004bd737f1c412b124eaf7ca6df90603">More...</a><br /></td></tr>
<tr class="separator:a004bd737f1c412b124eaf7ca6df90603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e9d57226726175af8c8e276edd0c58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ac5e9d57226726175af8c8e276edd0c58">get_DIL_entry_num_superiors</a> (DIL_entry *e)</td></tr>
<tr class="memdesc:ac5e9d57226726175af8c8e276edd0c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of connections from a DIL entry to Superiors.  <a href="#ac5e9d57226726175af8c8e276edd0c58">More...</a><br /></td></tr>
<tr class="separator:ac5e9d57226726175af8c8e276edd0c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02517c2cf1052f55bb388a0808fdaa1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a02517c2cf1052f55bb388a0808fdaa1b">get_DIL_hierarchy_num_connections</a> (Detailed_Items_List *dil)</td></tr>
<tr class="memdesc:a02517c2cf1052f55bb388a0808fdaa1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of connections in a DIL hierarchy.  <a href="#a02517c2cf1052f55bb388a0808fdaa1b">More...</a><br /></td></tr>
<tr class="separator:a02517c2cf1052f55bb388a0808fdaa1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd066a32696261830f98ca59ce4a7f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a3cd066a32696261830f98ca59ce4a7f0">Clean_Exit</a> (int ecode)</td></tr>
<tr class="memdesc:a3cd066a32696261830f98ca59ce4a7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after yourself before you exit.  <a href="#a3cd066a32696261830f98ca59ce4a7f0">More...</a><br /></td></tr>
<tr class="separator:a3cd066a32696261830f98ca59ce4a7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bde9da1de78d7bc0492b22eba9630e8"><td class="memItemLeft" align="right" valign="top">PGconn *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a9bde9da1de78d7bc0492b22eba9630e8">connection_setup_pq</a> (std::string dbname)</td></tr>
<tr class="memdesc:a9bde9da1de78d7bc0492b22eba9630e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up a connection with an existing Postgres database.  <a href="#a9bde9da1de78d7bc0492b22eba9630e8">More...</a><br /></td></tr>
<tr class="separator:a9bde9da1de78d7bc0492b22eba9630e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a653de26479eb7d85b850ec2918c2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aa1a653de26479eb7d85b850ec2918c2a">simple_call_pq</a> (PGconn *conn, std::string astr)</td></tr>
<tr class="memdesc:aa1a653de26479eb7d85b850ec2918c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a simple action call to a Postgres database.  <a href="#aa1a653de26479eb7d85b850ec2918c2a">More...</a><br /></td></tr>
<tr class="separator:aa1a653de26479eb7d85b850ec2918c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d24b6e4b1323e5d5687d184aa48fb4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a7d24b6e4b1323e5d5687d184aa48fb4a">query_call_pq</a> (PGconn *conn, std::string qstr, bool request_single_row_mode)</td></tr>
<tr class="memdesc:a7d24b6e4b1323e5d5687d184aa48fb4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch a Postgres query for asynchronous processing in batch or single row mode.  <a href="#a7d24b6e4b1323e5d5687d184aa48fb4a">More...</a><br /></td></tr>
<tr class="separator:a7d24b6e4b1323e5d5687d184aa48fb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b42530ac38402a5656af5bdcac5be6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a59b42530ac38402a5656af5bdcac5be6">sample_query_data</a> (PGconn *conn, unsigned int rstart, unsigned int rend, unsigned int cstart, unsigned int cend, std::string &amp;databufstr)</td></tr>
<tr class="memdesc:a59b42530ac38402a5656af5bdcac5be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that dumps several rows of data to a string buffer for easy inspection.  <a href="#a59b42530ac38402a5656af5bdcac5be6">More...</a><br /></td></tr>
<tr class="separator:a59b42530ac38402a5656af5bdcac5be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44280392e614e1145d3c5a27aa640b59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a44280392e614e1145d3c5a27aa640b59">create_Formalizer_schema_pq</a> (PGconn *conn, std::string schemaname)</td></tr>
<tr class="memdesc:a44280392e614e1145d3c5a27aa640b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new database schema for Formalizer data.  <a href="#a44280392e614e1145d3c5a27aa640b59">More...</a><br /></td></tr>
<tr class="separator:a44280392e614e1145d3c5a27aa640b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26caa1b821a4715dbec90c174a95e97"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab26caa1b821a4715dbec90c174a95e97">array_from_pq</a> (std::string pq_array_str)</td></tr>
<tr class="memdesc:ab26caa1b821a4715dbec90c174a95e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a single string containing Postgres query output that represents an array into a vector of strings.  <a href="#ab26caa1b821a4715dbec90c174a95e97">More...</a><br /></td></tr>
<tr class="separator:ab26caa1b821a4715dbec90c174a95e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852bc7a9cba819521f01ce09cc041461"><td class="memItemLeft" align="right" valign="top"><a id="a852bc7a9cba819521f01ce09cc041461"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a852bc7a9cba819521f01ce09cc041461">TimeStamp_pq</a> (time_t t)</td></tr>
<tr class="memdesc:a852bc7a9cba819521f01ce09cc041461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the UTC / Local Time convention built into TimeStamp(). <br /></td></tr>
<tr class="separator:a852bc7a9cba819521f01ce09cc041461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a40b1a728ffe05a3aca94bc24daff0e"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a8a40b1a728ffe05a3aca94bc24daff0e">epochtime_from_timestamp_pq</a> (std::string pqtimestamp)</td></tr>
<tr class="memdesc:a8a40b1a728ffe05a3aca94bc24daff0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Postgres query result time stamp strings to Unix time, for example, for <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> target date parameter.  <a href="#a8a40b1a728ffe05a3aca94bc24daff0e">More...</a><br /></td></tr>
<tr class="separator:a8a40b1a728ffe05a3aca94bc24daff0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e121747c47e1ca49747225bf5496af"><td class="memItemLeft" align="right" valign="top"><a id="ae3e121747c47e1ca49747225bf5496af"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae3e121747c47e1ca49747225bf5496af">is_not_digit</a> (int c)</td></tr>
<tr class="memdesc:ae3e121747c47e1ca49747225bf5496af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invere of &lt;cctype&gt;:isdigit(). <br /></td></tr>
<tr class="separator:ae3e121747c47e1ca49747225bf5496af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23b82243a12ae2b0d35ccb70d785857"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aa23b82243a12ae2b0d35ccb70d785857">shellcmd2str</a> (std::string cmd)</td></tr>
<tr class="memdesc:aa23b82243a12ae2b0d35ccb70d785857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a shell command and retrieve the standard output as a string.  <a href="#aa23b82243a12ae2b0d35ccb70d785857">More...</a><br /></td></tr>
<tr class="separator:aa23b82243a12ae2b0d35ccb70d785857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303e1d94ae3679f5fcc99dced6137cb2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a303e1d94ae3679f5fcc99dced6137cb2">to_precision_string</a> (double d, unsigned int p, char fillchar, unsigned int w)</td></tr>
<tr class="memdesc:a303e1d94ae3679f5fcc99dced6137cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print double to string with specific precision.  <a href="#a303e1d94ae3679f5fcc99dced6137cb2">More...</a><br /></td></tr>
<tr class="separator:a303e1d94ae3679f5fcc99dced6137cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a30fb04b5721cd05047bd4088fb8b0"><td class="memTemplParams" colspan="2">template&lt;typename Out &gt; </td></tr>
<tr class="memitem:a45a30fb04b5721cd05047bd4088fb8b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefz.html#a45a30fb04b5721cd05047bd4088fb8b0">split</a> (const std::string &amp;s, char delim, Out result)</td></tr>
<tr class="memdesc:a45a30fb04b5721cd05047bd4088fb8b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put pieces of a string into a pre-constructed vector.  <a href="#a45a30fb04b5721cd05047bd4088fb8b0">More...</a><br /></td></tr>
<tr class="separator:a45a30fb04b5721cd05047bd4088fb8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7dc083b5c0e84d7d715161e462a321f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab7dc083b5c0e84d7d715161e462a321f">split</a> (const std::string &amp;s, char delim)</td></tr>
<tr class="memdesc:ab7dc083b5c0e84d7d715161e462a321f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing pieces of a string.  <a href="#ab7dc083b5c0e84d7d715161e462a321f">More...</a><br /></td></tr>
<tr class="separator:ab7dc083b5c0e84d7d715161e462a321f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f17dcd15946bcb9a7fd70bf65e6fcc9"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a7f17dcd15946bcb9a7fd70bf65e6fcc9">ltrim</a> (std::string &amp;s, const char *t=&quot; \\\)</td></tr>
<tr class="memdesc:a7f17dcd15946bcb9a7fd70bf65e6fcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim whitespace from the front of a string.  <a href="#a7f17dcd15946bcb9a7fd70bf65e6fcc9">More...</a><br /></td></tr>
<tr class="separator:a7f17dcd15946bcb9a7fd70bf65e6fcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1cf55c9ed8689f087102061c60154a"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a8f1cf55c9ed8689f087102061c60154a">rtrim</a> (std::string &amp;s, const char *t=&quot; \\\)</td></tr>
<tr class="memdesc:a8f1cf55c9ed8689f087102061c60154a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim whitespace from the end of a string.  <a href="#a8f1cf55c9ed8689f087102061c60154a">More...</a><br /></td></tr>
<tr class="separator:a8f1cf55c9ed8689f087102061c60154a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff76817b33dcd0a0c38c28e238ad2d3"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#acff76817b33dcd0a0c38c28e238ad2d3">trim</a> (std::string &amp;s, const char *t=&quot; \\\)</td></tr>
<tr class="memdesc:acff76817b33dcd0a0c38c28e238ad2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim whitespace on both ends of a string.  <a href="#acff76817b33dcd0a0c38c28e238ad2d3">More...</a><br /></td></tr>
<tr class="separator:acff76817b33dcd0a0c38c28e238ad2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e5fa50448d4b9ffb38afea0ae0ea1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a11e5fa50448d4b9ffb38afea0ae0ea1a">string_to_file</a> (std::string path, std::string &amp;s, std::ofstream::iostate *writestate)</td></tr>
<tr class="memdesc:a11e5fa50448d4b9ffb38afea0ae0ea1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the full contents of a string to a file.  <a href="#a11e5fa50448d4b9ffb38afea0ae0ea1a">More...</a><br /></td></tr>
<tr class="separator:a11e5fa50448d4b9ffb38afea0ae0ea1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82121e1189c46fe028b6b6e9a073c8d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a82121e1189c46fe028b6b6e9a073c8d5">string_to_file_with_backup</a> (std::string path, std::string &amp;s, std::string backupext, bool &amp;backedup, std::ofstream::iostate *writestate)</td></tr>
<tr class="memdesc:a82121e1189c46fe028b6b6e9a073c8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the full contents of a string to a file, but move an existing file at the given path to a backup name first.  <a href="#a82121e1189c46fe028b6b6e9a073c8d5">More...</a><br /></td></tr>
<tr class="separator:a82121e1189c46fe028b6b6e9a073c8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac311316b5a762d53489ec1135d88479"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aac311316b5a762d53489ec1135d88479">file_to_string</a> (std::string path, std::string &amp;s, std::ifstream::iostate *readstate)</td></tr>
<tr class="memdesc:aac311316b5a762d53489ec1135d88479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the full contents of a (text) file into a string.  <a href="#aac311316b5a762d53489ec1135d88479">More...</a><br /></td></tr>
<tr class="separator:aac311316b5a762d53489ec1135d88479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4ae42399db02b1b71a5d5771f16139"><td class="memItemLeft" align="right" valign="top"><a id="a7e4ae42399db02b1b71a5d5771f16139"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>string_from_file</b> (std::string path, std::ifstream::iostate *readstate=nullptr)</td></tr>
<tr class="separator:a7e4ae42399db02b1b71a5d5771f16139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae354d176f2f483264ec225411f7eb122"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae354d176f2f483264ec225411f7eb122">stream_to_string</a> (std::istream &amp;in, std::string &amp;s)</td></tr>
<tr class="memdesc:ae354d176f2f483264ec225411f7eb122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the full contents of a (text) stream into a string.  <a href="#ae354d176f2f483264ec225411f7eb122">More...</a><br /></td></tr>
<tr class="separator:ae354d176f2f483264ec225411f7eb122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe69e72e6cc57d40e3738f2bb2d7b1bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#abe69e72e6cc57d40e3738f2bb2d7b1bc">create_Enum_Types_pq</a> (PGconn *conn, std::string schemaname)</td></tr>
<tr class="memdesc:abe69e72e6cc57d40e3738f2bb2d7b1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create enumerated types in database for <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> and <a class="el" href="classfz_1_1Edge.html">Edge</a> data.  <a href="#abe69e72e6cc57d40e3738f2bb2d7b1bc">More...</a><br /></td></tr>
<tr class="separator:abe69e72e6cc57d40e3738f2bb2d7b1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2359bd1e82e68f38bd9d900588887fde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a2359bd1e82e68f38bd9d900588887fde">create_Topics_table_pq</a> (PGconn *conn, std::string schemaname)</td></tr>
<tr class="memdesc:a2359bd1e82e68f38bd9d900588887fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new database table for Topics.  <a href="#a2359bd1e82e68f38bd9d900588887fde">More...</a><br /></td></tr>
<tr class="separator:a2359bd1e82e68f38bd9d900588887fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75375e8fb94d22f2facb4085afe93de9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a75375e8fb94d22f2facb4085afe93de9">create_Nodes_table_pq</a> (PGconn *conn, std::string schemaname)</td></tr>
<tr class="memdesc:a75375e8fb94d22f2facb4085afe93de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new database table for Nodes.  <a href="#a75375e8fb94d22f2facb4085afe93de9">More...</a><br /></td></tr>
<tr class="separator:a75375e8fb94d22f2facb4085afe93de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2da8c677f43a85e7f86d9074e468962"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ad2da8c677f43a85e7f86d9074e468962">create_Edges_table_pq</a> (PGconn *conn, std::string schemaname)</td></tr>
<tr class="memdesc:ad2da8c677f43a85e7f86d9074e468962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new database table for Edges.  <a href="#ad2da8c677f43a85e7f86d9074e468962">More...</a><br /></td></tr>
<tr class="separator:ad2da8c677f43a85e7f86d9074e468962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d3d52c28b498e4b986abd91d3797ee"><td class="memItemLeft" align="right" valign="top"><a id="a59d3d52c28b498e4b986abd91d3797ee"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>add_Topic_pq</b> (PGconn *conn, std::string schemaname, const <a class="el" href="classfz_1_1Topic.html">Topic</a> *topic)</td></tr>
<tr class="separator:a59d3d52c28b498e4b986abd91d3797ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5d35ee88b8f0e2ab786e64ded407c5"><td class="memItemLeft" align="right" valign="top"><a id="a0d5d35ee88b8f0e2ab786e64ded407c5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>add_Node_pq</b> (PGconn *conn, std::string schemaname, const <a class="el" href="classfz_1_1Node.html">Node</a> *node)</td></tr>
<tr class="separator:a0d5d35ee88b8f0e2ab786e64ded407c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad481d21955c0be457141a73c619a3fbf"><td class="memItemLeft" align="right" valign="top"><a id="ad481d21955c0be457141a73c619a3fbf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>add_Edge_pq</b> (PGconn *conn, std::string schemaname, const <a class="el" href="classfz_1_1Edge.html">Edge</a> *edge)</td></tr>
<tr class="separator:ad481d21955c0be457141a73c619a3fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb865200e35c530ff09a2a5c142c55a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a1cb865200e35c530ff09a2a5c142c55a">store_Graph_pq</a> (const <a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, std::string dbname, std::string schemaname, void(*progress_func)(unsigned long, unsigned long))</td></tr>
<tr class="memdesc:a1cb865200e35c530ff09a2a5c142c55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store all the Nodes and Edges of the <a class="el" href="classfz_1_1Graph.html">Graph</a> in the PostgreSQL database.  <a href="#a1cb865200e35c530ff09a2a5c142c55a">More...</a><br /></td></tr>
<tr class="separator:a1cb865200e35c530ff09a2a5c142c55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615c9833189de86268653cf1fc95f092"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a615c9833189de86268653cf1fc95f092">load_Graph_pq</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, std::string dbname, std::string schemaname)</td></tr>
<tr class="memdesc:a615c9833189de86268653cf1fc95f092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all the Nodes, Edges and Topics of the <a class="el" href="classfz_1_1Graph.html">Graph</a> from the PostgreSQL database.  <a href="#a615c9833189de86268653cf1fc95f092">More...</a><br /></td></tr>
<tr class="separator:a615c9833189de86268653cf1fc95f092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24f78e052197d9844de69ba284cfade"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ad24f78e052197d9844de69ba284cfade">load_Node_parameter_interval</a> (std::string dbname, std::string schemaname, pq_Nfields param, unsigned long from_row, unsigned long num_rows)</td></tr>
<tr class="memdesc:ad24f78e052197d9844de69ba284cfade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load specific <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> parameter column interval from PostgreSQL database.  <a href="#ad24f78e052197d9844de69ba284cfade">More...</a><br /></td></tr>
<tr class="separator:ad24f78e052197d9844de69ba284cfade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef824584d56abd3b06028a3925a9541c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aef824584d56abd3b06028a3925a9541c">load_Edge_parameter_interval</a> (std::string dbname, std::string schemaname, pq_Efields param, unsigned long from_row, unsigned long num_rows)</td></tr>
<tr class="memdesc:aef824584d56abd3b06028a3925a9541c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load specific <a class="el" href="classfz_1_1Edge.html">Edge</a> parameter column interval from PostgreSQL database.  <a href="#aef824584d56abd3b06028a3925a9541c">More...</a><br /></td></tr>
<tr class="separator:aef824584d56abd3b06028a3925a9541c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0e4f3360d11eff1bf1b4553a451180"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aba0e4f3360d11eff1bf1b4553a451180">valid_Node_ID</a> (std::string id_str, std::string &amp;formerror, <a class="el" href="structfz_1_1ID__TimeStamp.html">ID_TimeStamp</a> *id_timestamp)</td></tr>
<tr class="memdesc:aba0e4f3360d11eff1bf1b4553a451180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a string can be used to form a valid <a class="el" href="classfz_1_1Node__ID.html" title="Node ID that caches its ID stamp for frequent use. ">Node_ID</a>.  <a href="#aba0e4f3360d11eff1bf1b4553a451180">More...</a><br /></td></tr>
<tr class="separator:aba0e4f3360d11eff1bf1b4553a451180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4260c6b3087bdf22ce089216638d79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a0c4260c6b3087bdf22ce089216638d79">valid_Node_ID</a> (const <a class="el" href="structfz_1_1ID__TimeStamp.html">ID_TimeStamp</a> &amp;idT, std::string &amp;formerror)</td></tr>
<tr class="memdesc:a0c4260c6b3087bdf22ce089216638d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a <a class="el" href="structfz_1_1ID__TimeStamp.html" title="Timestamp IDs in the format required for Node IDs. ">ID_TimeStamp</a> can be used as a valid <a class="el" href="classfz_1_1Node__ID.html" title="Node ID that caches its ID stamp for frequent use. ">Node_ID</a>.  <a href="#a0c4260c6b3087bdf22ce089216638d79">More...</a><br /></td></tr>
<tr class="separator:a0c4260c6b3087bdf22ce089216638d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572283837fdf4fbab8814064feb3b1b1"><td class="memItemLeft" align="right" valign="top"><a id="a572283837fdf4fbab8814064feb3b1b1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Node_ID_TimeStamp_to_string</b> (const <a class="el" href="structfz_1_1ID__TimeStamp.html">ID_TimeStamp</a> idT)</td></tr>
<tr class="separator:a572283837fdf4fbab8814064feb3b1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd926038748af1ffa7f75a0f6643c38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aebd926038748af1ffa7f75a0f6643c38">create_Guide_table</a> (const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq, const std::string guidetable, const std::string guidetablelayout)</td></tr>
<tr class="memdesc:aebd926038748af1ffa7f75a0f6643c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the table for Guide snippets if it does not already exist.  <a href="#aebd926038748af1ffa7f75a0f6643c38">More...</a><br /></td></tr>
<tr class="separator:aebd926038748af1ffa7f75a0f6643c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8eebdb96e1f6ab62ce592c84ea3e669"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#af8eebdb96e1f6ab62ce592c84ea3e669">store_Guide_snippet_pq</a> (const <a class="el" href="structfz_1_1Guide__snippet.html">Guide_snippet</a> &amp;snippet, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa)</td></tr>
<tr class="memdesc:af8eebdb96e1f6ab62ce592c84ea3e669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a new Guide snippet in the PostgreSQL database.  <a href="#af8eebdb96e1f6ab62ce592c84ea3e669">More...</a><br /></td></tr>
<tr class="separator:af8eebdb96e1f6ab62ce592c84ea3e669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f30f53fd171c9a6c7f03cf96c983ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae2f30f53fd171c9a6c7f03cf96c983ba">read_Guide_snippet_pq</a> (<a class="el" href="structfz_1_1Guide__snippet.html">Guide_snippet</a> &amp;snippet, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa)</td></tr>
<tr class="memdesc:ae2f30f53fd171c9a6c7f03cf96c983ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single snippet from a Guide table in the database.  <a href="#ae2f30f53fd171c9a6c7f03cf96c983ba">More...</a><br /></td></tr>
<tr class="separator:ae2f30f53fd171c9a6c7f03cf96c983ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125c22828646b624c8e4f4775f84dc5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a125c22828646b624c8e4f4775f84dc5d">create_Breakpoints_table_pq</a> (const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq)</td></tr>
<tr class="memdesc:a125c22828646b624c8e4f4775f84dc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new database table for Breakpoints.  <a href="#a125c22828646b624c8e4f4775f84dc5d">More...</a><br /></td></tr>
<tr class="separator:a125c22828646b624c8e4f4775f84dc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a2d42be5384357b19e513b20b1c77b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a44a2d42be5384357b19e513b20b1c77b">create_Logchunks_table_pq</a> (const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq)</td></tr>
<tr class="memdesc:a44a2d42be5384357b19e513b20b1c77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new database table for <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks.  <a href="#a44a2d42be5384357b19e513b20b1c77b">More...</a><br /></td></tr>
<tr class="separator:a44a2d42be5384357b19e513b20b1c77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ef5ef0384e0d621bbff628679d3981"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aa8ef5ef0384e0d621bbff628679d3981">create_Logentries_table_pq</a> (const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq)</td></tr>
<tr class="memdesc:aa8ef5ef0384e0d621bbff628679d3981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new database table for <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries.  <a href="#aa8ef5ef0384e0d621bbff628679d3981">More...</a><br /></td></tr>
<tr class="separator:aa8ef5ef0384e0d621bbff628679d3981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539303a2c7987ed777fbc57d9abda813"><td class="memItemLeft" align="right" valign="top"><a id="a539303a2c7987ed777fbc57d9abda813"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>add_Breakpoint_pq</b> (const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq, const <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> &amp;bptopid)</td></tr>
<tr class="separator:a539303a2c7987ed777fbc57d9abda813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e7a0e71b09cf5afc4e574c7a671e46"><td class="memItemLeft" align="right" valign="top"><a id="a10e7a0e71b09cf5afc4e574c7a671e46"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>add_Logchunk_pq</b> (const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq, const <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &amp;chunk)</td></tr>
<tr class="separator:a10e7a0e71b09cf5afc4e574c7a671e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af4eade92e254bd44d8b19adf94101c"><td class="memItemLeft" align="right" valign="top"><a id="a4af4eade92e254bd44d8b19adf94101c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>add_Logentry_pq</b> (const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq, const <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> &amp;entry)</td></tr>
<tr class="separator:a4af4eade92e254bd44d8b19adf94101c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac534af76c643c9568951e81e51066108"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ac534af76c643c9568951e81e51066108">store_Log_pq</a> (const <a class="el" href="classfz_1_1Log.html">Log</a> &amp;log, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa, void(*progressfunc)(unsigned long, unsigned long))</td></tr>
<tr class="memdesc:ac534af76c643c9568951e81e51066108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store all the Chunks and Entries of the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> in the PostgreSQL database.  <a href="#ac534af76c643c9568951e81e51066108">More...</a><br /></td></tr>
<tr class="separator:ac534af76c643c9568951e81e51066108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5688f3a5a5bb5066690ccff97430eaaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a5688f3a5a5bb5066690ccff97430eaaa">load_Log_pq</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa)</td></tr>
<tr class="memdesc:a5688f3a5a5bb5066690ccff97430eaaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the full <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> with all <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks, <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries and Breakpoints from the PostgresSQL database.  <a href="#a5688f3a5a5bb5066690ccff97430eaaa">More...</a><br /></td></tr>
<tr class="separator:a5688f3a5a5bb5066690ccff97430eaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0e676f27bed9001b55fc70a1c97cc8"><td class="memItemLeft" align="right" valign="top"><a id="a1b0e676f27bed9001b55fc70a1c97cc8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TEST_load_Log_interval_pq</b> (<a class="el" href="classfz_1_1Log__interval.html">Log_interval</a> &amp;log)</td></tr>
<tr class="separator:a1b0e676f27bed9001b55fc70a1c97cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f47cae19dab82915dc813045ee3cfe"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab2f47cae19dab82915dc813045ee3cfe">Entries_total_text</a> (<a class="el" href="namespacefz.html#a005101cd3360f7440301c8c033b397f8">Log_entries_Map</a> &amp;entries)</td></tr>
<tr class="memdesc:ab2f47cae19dab82915dc813045ee3cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the total number of characters in <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry description text in the specified map.  <a href="#ab2f47cae19dab82915dc813045ee3cfe">More...</a><br /></td></tr>
<tr class="separator:ab2f47cae19dab82915dc813045ee3cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad749cc98362cd5b1af14cb171ead68fb"><td class="memItemLeft" align="right" valign="top"><a id="ad749cc98362cd5b1af14cb171ead68fb"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Log_entry_ID_TimeStamp_to_string</b> (const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> idT)</td></tr>
<tr class="separator:ad749cc98362cd5b1af14cb171ead68fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbff141b73f7b28f4d4b128ead8ba5d"><td class="memItemLeft" align="right" valign="top"><a id="acbbff141b73f7b28f4d4b128ead8ba5d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Log_chunk_ID_TimeStamp_to_string</b> (const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> idT)</td></tr>
<tr class="separator:acbbff141b73f7b28f4d4b128ead8ba5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a11e58e46a7c11d34572de05a7ebd8"><td class="memItemLeft" align="right" valign="top"><a id="a87a11e58e46a7c11d34572de05a7ebd8"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Log_TimeStamp_to_Ymd_string</b> (const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> idT)</td></tr>
<tr class="separator:a87a11e58e46a7c11d34572de05a7ebd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ced31e8ffbaf54c00a9f586eaf1dd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a61ced31e8ffbaf54c00a9f586eaf1dd4">valid_Log_entry_ID</a> (const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> &amp;idT, std::string &amp;formerror)</td></tr>
<tr class="memdesc:a61ced31e8ffbaf54c00a9f586eaf1dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a <a class="el" href="structfz_1_1Log__TimeStamp.html" title="Timestamp IDs in the format required for Log IDs. ">Log_TimeStamp</a> can be used as a valid <a class="el" href="classfz_1_1Log__entry__ID.html">Log_entry_ID</a>.  <a href="#a61ced31e8ffbaf54c00a9f586eaf1dd4">More...</a><br /></td></tr>
<tr class="separator:a61ced31e8ffbaf54c00a9f586eaf1dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045ec1abb4dc382e0b56e345c146de95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a045ec1abb4dc382e0b56e345c146de95">valid_Log_chunk_ID</a> (const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> &amp;idT, std::string &amp;formerror)</td></tr>
<tr class="memdesc:a045ec1abb4dc382e0b56e345c146de95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a <a class="el" href="structfz_1_1Log__TimeStamp.html" title="Timestamp IDs in the format required for Log IDs. ">Log_TimeStamp</a> can be used as a valid <a class="el" href="classfz_1_1Log__chunk__ID.html">Log_chunk_ID</a>.  <a href="#a045ec1abb4dc382e0b56e345c146de95">More...</a><br /></td></tr>
<tr class="separator:a045ec1abb4dc382e0b56e345c146de95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0d31396e23ba90447163d6b714f1d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a8c0d31396e23ba90447163d6b714f1d5">valid_Log_entry_ID</a> (std::string id_str, std::string &amp;formerror, <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> *id_timestamp)</td></tr>
<tr class="memdesc:a8c0d31396e23ba90447163d6b714f1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a string can be used to form a valid <a class="el" href="classfz_1_1Log__entry__ID.html">Log_entry_ID</a>.  <a href="#a8c0d31396e23ba90447163d6b714f1d5">More...</a><br /></td></tr>
<tr class="separator:a8c0d31396e23ba90447163d6b714f1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957bdd835342852a8ef5ad94723e34cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a957bdd835342852a8ef5ad94723e34cf">valid_Log_chunk_ID</a> (std::string id_str, std::string &amp;formerror, <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> *id_timestamp)</td></tr>
<tr class="memdesc:a957bdd835342852a8ef5ad94723e34cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a string can be used to form a valid <a class="el" href="classfz_1_1Log__chunk__ID.html">Log_chunk_ID</a>.  <a href="#a957bdd835342852a8ef5ad94723e34cf">More...</a><br /></td></tr>
<tr class="separator:a957bdd835342852a8ef5ad94723e34cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae767b87541ed3adf95ef80fb4cab307e"><td class="memItemLeft" align="right" valign="top">std::time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae767b87541ed3adf95ef80fb4cab307e">ActualTime</a> ()</td></tr>
<tr class="memdesc:ae767b87541ed3adf95ef80fb4cab307e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly provide the actual system time.  <a href="#ae767b87541ed3adf95ef80fb4cab307e">More...</a><br /></td></tr>
<tr class="separator:ae767b87541ed3adf95ef80fb4cab307e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdf2285bd874038959c3aca55feac8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a5cdf2285bd874038959c3aca55feac8d">error_summary_wrapper</a> ()</td></tr>
<tr class="memdesc:a5cdf2285bd874038959c3aca55feac8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapped version of ERRWARN_SUMMARY that can be stacked.  <a href="#a5cdf2285bd874038959c3aca55feac8d">More...</a><br /></td></tr>
<tr class="separator:a5cdf2285bd874038959c3aca55feac8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dba8841daadafb13e8b74c2ea661b9"><td class="memItemLeft" align="right" valign="top"><a id="ae7dba8841daadafb13e8b74c2ea661b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae7dba8841daadafb13e8b74c2ea661b9">clean_exit_wrapper</a> ()</td></tr>
<tr class="memdesc:ae7dba8841daadafb13e8b74c2ea661b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This does everyting that <code><a class="el" href="namespacefz.html#a3cd066a32696261830f98ca59ce4a7f0" title="Clean up after yourself before you exit. ">fz::Clean_Exit()</a></code> does, and it is stacked. <br /></td></tr>
<tr class="separator:ae7dba8841daadafb13e8b74c2ea661b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a72c04fc5a7860678e9156bd32b5aa1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a4a72c04fc5a7860678e9156bd32b5aa1">safe_cmdline_options</a> (int argc, char *argv[], std::string options, int &amp;optindcopy)</td></tr>
<tr class="memdesc:a4a72c04fc5a7860678e9156bd32b5aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safer parsing of command line parameters.  <a href="#a4a72c04fc5a7860678e9156bd32b5aa1">More...</a><br /></td></tr>
<tr class="separator:a4a72c04fc5a7860678e9156bd32b5aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac327c945f41c63fef32c002d058fb7c"><td class="memItemLeft" align="right" valign="top"><a id="aac327c945f41c63fef32c002d058fb7c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aac327c945f41c63fef32c002d058fb7c">key_pause</a> ()</td></tr>
<tr class="memdesc:aac327c945f41c63fef32c002d058fb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A very simple function to wait for ENTER to be pressed. <br /></td></tr>
<tr class="separator:aac327c945f41c63fef32c002d058fb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b50bdd16d9e99e3ff4bf398f3fe68f"><td class="memItemLeft" align="right" valign="top">std::time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a50b50bdd16d9e99e3ff4bf398f3fe68f">time_stamp_time</a> (std::string timestr, bool noerror=false)</td></tr>
<tr class="memdesc:a50b50bdd16d9e99e3ff4bf398f3fe68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Formalizer time stamp string into local Unix time.  <a href="#a50b50bdd16d9e99e3ff4bf398f3fe68f">More...</a><br /></td></tr>
<tr class="separator:a50b50bdd16d9e99e3ff4bf398f3fe68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0003e81e0cb15861b2dfa5fa1469e2"><td class="memItemLeft" align="right" valign="top">std::time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#acd0003e81e0cb15861b2dfa5fa1469e2">ymd_stamp_time</a> (std::string timestr, bool noerror=false, bool ignoreHM=false)</td></tr>
<tr class="memdesc:acd0003e81e0cb15861b2dfa5fa1469e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">UNIX epoch time equivalent of a Year-Month-Day date-stamp such as 20200914 or 202009140100.  <a href="#acd0003e81e0cb15861b2dfa5fa1469e2">More...</a><br /></td></tr>
<tr class="separator:acd0003e81e0cb15861b2dfa5fa1469e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b13840120d2acc08fa2fb25a6c3d6a4"><td class="memItemLeft" align="right" valign="top"><a id="a7b13840120d2acc08fa2fb25a6c3d6a4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>TimeStamp</b> (const char *dateformat, std::time_t t)</td></tr>
<tr class="separator:a7b13840120d2acc08fa2fb25a6c3d6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58effa18dd1037431893b3ad00de2005"><td class="memItemLeft" align="right" valign="top"><a id="a58effa18dd1037431893b3ad00de2005"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a58effa18dd1037431893b3ad00de2005">TimeStampYmdHM</a> (std::time_t t)</td></tr>
<tr class="memdesc:a58effa18dd1037431893b3ad00de2005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Formalizer standardized date and time stamp (YYYYmmddHHMM). <br /></td></tr>
<tr class="separator:a58effa18dd1037431893b3ad00de2005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f965a9972440886cdbba23dee898e6e"><td class="memItemLeft" align="right" valign="top"><a id="a8f965a9972440886cdbba23dee898e6e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a8f965a9972440886cdbba23dee898e6e">DateStampYmd</a> (std::time_t t)</td></tr>
<tr class="memdesc:a8f965a9972440886cdbba23dee898e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Formalizer standardized date stamp (YYYYmmdd). <br /></td></tr>
<tr class="separator:a8f965a9972440886cdbba23dee898e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4308075d0f8dc4c0129d8ee71740e5"><td class="memItemLeft" align="right" valign="top"><a id="abe4308075d0f8dc4c0129d8ee71740e5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#abe4308075d0f8dc4c0129d8ee71740e5">BackupStampYmd</a> ()</td></tr>
<tr class="memdesc:abe4308075d0f8dc4c0129d8ee71740e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Formalizer standardized file backup extension (YYYYmmdd.bak). <br /></td></tr>
<tr class="separator:abe4308075d0f8dc4c0129d8ee71740e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4932c9514aab01039104a5b0033934d4"><td class="memItemLeft" align="right" valign="top"><a id="a4932c9514aab01039104a5b0033934d4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a4932c9514aab01039104a5b0033934d4">BackupStampYmdHM</a> ()</td></tr>
<tr class="memdesc:a4932c9514aab01039104a5b0033934d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Formalizer standardized file backup precise extension (YYYYmmddHHMM.bak). <br /></td></tr>
<tr class="separator:a4932c9514aab01039104a5b0033934d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30be49d20ac6c8ba1b313fc295a235a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a30be49d20ac6c8ba1b313fc295a235a2">is_leapyear</a> (unsigned int year)</td></tr>
<tr class="memdesc:a30be49d20ac6c8ba1b313fc295a235a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple leap year test.  <a href="#a30be49d20ac6c8ba1b313fc295a235a2">More...</a><br /></td></tr>
<tr class="separator:a30be49d20ac6c8ba1b313fc295a235a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af320a36d5d2f05de32419ea52f625e1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#af320a36d5d2f05de32419ea52f625e1e">valid_year_month_day</a> (<a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a> ymd)</td></tr>
<tr class="memdesc:af320a36d5d2f05de32419ea52f625e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a year, month and day form a valid date.  <a href="#af320a36d5d2f05de32419ea52f625e1e">More...</a><br /></td></tr>
<tr class="separator:af320a36d5d2f05de32419ea52f625e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053fc7625765a11b31ee3604a1f225b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a053fc7625765a11b31ee3604a1f225b0">years_months_days</a> (<a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a> ymd1, <a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a> ymd2)</td></tr>
<tr class="memdesc:a053fc7625765a11b31ee3604a1f225b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Express the difference between two dates in terms of the number of Years, Months and Days between them.  <a href="#a053fc7625765a11b31ee3604a1f225b0">More...</a><br /></td></tr>
<tr class="separator:a053fc7625765a11b31ee3604a1f225b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bfa54595aa468eba2c7e5fda819ecf"><td class="memItemLeft" align="right" valign="top"><a id="a84bfa54595aa468eba2c7e5fda819ecf"></a>
<a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>years_months_days</b> (std::time_t t1, std::time_t t2)</td></tr>
<tr class="separator:a84bfa54595aa468eba2c7e5fda819ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5a614340e67aa9ff729f387ca8e987"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a6b5a614340e67aa9ff729f387ca8e987">utf8_safe</a> (const std::string &amp;utf8str, bool warn=true)</td></tr>
<tr class="memdesc:a6b5a614340e67aa9ff729f387ca8e987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter a text string to ensure that it contains valid UTF8 encoded content.  <a href="#a6b5a614340e67aa9ff729f387ca8e987">More...</a><br /></td></tr>
<tr class="separator:a6b5a614340e67aa9ff729f387ca8e987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0f6707de5ea5600bdc7326ec3b0830"><td class="memItemLeft" align="right" valign="top"><a id="aac0f6707de5ea5600bdc7326ec3b0830"></a>
std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aac0f6707de5ea5600bdc7326ec3b0830">param_value</a> (const std::string &amp;par_value_pair)</td></tr>
<tr class="memdesc:aac0f6707de5ea5600bdc7326ec3b0830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract parameter label and parameter value. <br /></td></tr>
<tr class="separator:aac0f6707de5ea5600bdc7326ec3b0830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7dc82ea6c4ab29ef2cbb51d09e7b8a"><td class="memItemLeft" align="right" valign="top"><a id="a8a7dc82ea6c4ab29ef2cbb51d09e7b8a"></a>
<a class="el" href="classfz_1_1Errors.html">Errors</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ErrQ</b> (DEFAULT_ERRLOGPATH)</td></tr>
<tr class="separator:a8a7dc82ea6c4ab29ef2cbb51d09e7b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf44b9878517c39c7fc3b53d7c7f56a6"><td class="memItemLeft" align="right" valign="top"><a id="acf44b9878517c39c7fc3b53d7c7f56a6"></a>
<a class="el" href="classfz_1_1Errors.html">Errors</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WarnQ</b> (DEFAULT_WARNLOGPATH)</td></tr>
<tr class="separator:acf44b9878517c39c7fc3b53d7c7f56a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b84c36d3ebbf295bcbd154874858b3"><td class="memItemLeft" align="right" valign="top"><a id="a34b84c36d3ebbf295bcbd154874858b3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>identical_Topics</b> (const <a class="el" href="classfz_1_1Topic.html">Topic</a> &amp;topic1, const <a class="el" href="classfz_1_1Topic.html">Topic</a> &amp;topic2, std::string &amp;trace)</td></tr>
<tr class="separator:a34b84c36d3ebbf295bcbd154874858b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e57f175450656687c5ca428725d97bd"><td class="memItemLeft" align="right" valign="top"><a id="a9e57f175450656687c5ca428725d97bd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>identical_Topic_Tags</b> (<a class="el" href="classfz_1_1Topic__Tags.html">Topic_Tags</a> &amp;ttags1, <a class="el" href="classfz_1_1Topic__Tags.html">Topic_Tags</a> &amp;ttags2, std::string &amp;trace)</td></tr>
<tr class="separator:a9e57f175450656687c5ca428725d97bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa017a0d639d3d67ac4b304efa514eae9"><td class="memItemLeft" align="right" valign="top"><a id="aa017a0d639d3d67ac4b304efa514eae9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>identical_Node_ID_key</b> (const <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a> &amp;key1, const <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a> &amp;key2, std::string &amp;trace)</td></tr>
<tr class="separator:aa017a0d639d3d67ac4b304efa514eae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f4dc710aff55f6fd9c2e111d7df259"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a96f4dc710aff55f6fd9c2e111d7df259">identical_Nodes</a> (<a class="el" href="classfz_1_1Node.html">Node</a> &amp;node1, <a class="el" href="classfz_1_1Node.html">Node</a> &amp;node2, std::string &amp;trace)</td></tr>
<tr class="memdesc:a96f4dc710aff55f6fd9c2e111d7df259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> objects contain the same data.  <a href="#a96f4dc710aff55f6fd9c2e111d7df259">More...</a><br /></td></tr>
<tr class="separator:a96f4dc710aff55f6fd9c2e111d7df259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3bb9d1734c1f79ca4d1f2c0e269d93"><td class="memItemLeft" align="right" valign="top"><a id="afe3bb9d1734c1f79ca4d1f2c0e269d93"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>identical_Edge_ID_key</b> (const <a class="el" href="structfz_1_1Edge__ID__key.html">Edge_ID_key</a> &amp;key1, const <a class="el" href="structfz_1_1Edge__ID__key.html">Edge_ID_key</a> &amp;key2, std::string &amp;trace)</td></tr>
<tr class="separator:afe3bb9d1734c1f79ca4d1f2c0e269d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c6c4def4995096eab72c38358ffdeb"><td class="memItemLeft" align="right" valign="top"><a id="ae7c6c4def4995096eab72c38358ffdeb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>identical_Edges</b> (<a class="el" href="classfz_1_1Edge.html">Edge</a> &amp;edge1, <a class="el" href="classfz_1_1Edge.html">Edge</a> &amp;edge2, std::string &amp;trace)</td></tr>
<tr class="separator:ae7c6c4def4995096eab72c38358ffdeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569da80848b8001bc12867337f51d1c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a569da80848b8001bc12867337f51d1c9">identical_Graphs</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph1, <a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph2, std::string &amp;trace)</td></tr>
<tr class="memdesc:a569da80848b8001bc12867337f51d1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two Graphs to report if they are data-identical.  <a href="#a569da80848b8001bc12867337f51d1c9">More...</a><br /></td></tr>
<tr class="separator:a569da80848b8001bc12867337f51d1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7549e0f879bb89ae170db487ced95cd9"><td class="memItemLeft" align="right" valign="top"><a id="a7549e0f879bb89ae170db487ced95cd9"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_enum_td_property</b> (&quot;('unspecified','inherit','variable','fixed','exact')&quot;)</td></tr>
<tr class="separator:a7549e0f879bb89ae170db487ced95cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8eb5b2d3cc88e7c31c21f894fb41795"><td class="memItemLeft" align="right" valign="top"><a id="ab8eb5b2d3cc88e7c31c21f894fb41795"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_enum_td_pattern</b> (&quot;('patt_daily','patt_workdays','patt_weekly','patt_biweekly','patt_monthly','patt_endofmonthoffset','patt_yearly','OLD_patt_span','patt_nonperiodic')&quot;)</td></tr>
<tr class="separator:ab8eb5b2d3cc88e7c31c21f894fb41795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e2e0c10e0a99c02075317aeeb6c1c5"><td class="memItemLeft" align="right" valign="top"><a id="a27e2e0c10e0a99c02075317aeeb6c1c5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_nodelayout</b> (&quot;id char(16) PRIMARY KEY,&quot; &quot;topics smallint[],&quot; &quot;topicrelevance real[],&quot; &quot;valuation real,&quot; &quot;completion real,&quot; &quot;required integer,&quot; &quot;text text,&quot; &quot;targetdate timestamp (0),&quot; &quot;tdproperty <a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">td_property</a>,&quot; &quot;isperiodic boolean,&quot; &quot;tdperiodic td_pattern,&quot; &quot;tdevery integer,&quot; &quot;tdspan integer&quot;)</td></tr>
<tr class="separator:a27e2e0c10e0a99c02075317aeeb6c1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73614ef8b5bc9f7003d3bac5de7813bf"><td class="memItemLeft" align="right" valign="top"><a id="a73614ef8b5bc9f7003d3bac5de7813bf"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_edgelayout</b> (&quot;id char(33),&quot; &quot;dependency real,&quot; &quot;significance real,&quot; &quot;importance real,&quot; &quot;urgency real,&quot; &quot;priority real&quot;)</td></tr>
<tr class="separator:a73614ef8b5bc9f7003d3bac5de7813bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95d4dae6638078251973dce703bc6da"><td class="memItemLeft" align="right" valign="top"><a id="ac95d4dae6638078251973dce703bc6da"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_topiclayout</b> (&quot;id smallint,&quot; &quot;supid smallint,&quot; &quot;tag text,&quot; &quot;title text,&quot; &quot;keyword text[],&quot; &quot;relevance real[]&quot;)</td></tr>
<tr class="separator:ac95d4dae6638078251973dce703bc6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe38748c6da4110ea71ee010642d3606"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#afe38748c6da4110ea71ee010642d3606">get_Topic_pq_field_numbers</a> (PGresult *res)</td></tr>
<tr class="memdesc:afe38748c6da4110ea71ee010642d3606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve field column numbers for topics query to make sure the correct field numbers are used.  <a href="#afe38748c6da4110ea71ee010642d3606">More...</a><br /></td></tr>
<tr class="separator:afe38748c6da4110ea71ee010642d3606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c85e3e526a0195ae67354ec8da0961"><td class="memItemLeft" align="right" valign="top"><a id="a66c85e3e526a0195ae67354ec8da0961"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_Node_pq_field_numbers</b> (PGresult *res)</td></tr>
<tr class="separator:a66c85e3e526a0195ae67354ec8da0961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d83157fc9e0622a67f569ec7b4e821"><td class="memItemLeft" align="right" valign="top"><a id="af8d83157fc9e0622a67f569ec7b4e821"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_Edge_pq_field_numbers</b> (PGresult *res)</td></tr>
<tr class="separator:af8d83157fc9e0622a67f569ec7b4e821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2e1a49e1871f23c757c97c84484676"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structfz_1_1Topic__Keyword.html">Topic_Keyword</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#add2e1a49e1871f23c757c97c84484676">keyrel_from_pq</a> (std::string keywordstr, std::string relevancestr)</td></tr>
<tr class="memdesc:add2e1a49e1871f23c757c97c84484676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert textual arrays of keywords and keyword-relevance values to a vector of <a class="el" href="structfz_1_1Topic__Keyword.html" title="Type for real-valued Keyword relevance (to Topic), presently assumed to be in the interval [0...">Topic_Keyword</a> pairs.  <a href="#add2e1a49e1871f23c757c97c84484676">More...</a><br /></td></tr>
<tr class="separator:add2e1a49e1871f23c757c97c84484676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2218c0801453155ac1531a857fd4e6"><td class="memItemLeft" align="right" valign="top"><a id="a0f2218c0801453155ac1531a857fd4e6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>read_Topics_pq</b> (PGconn *conn, std::string schemaname, <a class="el" href="classfz_1_1Topic__Tags.html">Topic_Tags</a> &amp;topictags)</td></tr>
<tr class="separator:a0f2218c0801453155ac1531a857fd4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de97e67d19ad7d3d8bd98bd13f2cb27"><td class="memItemLeft" align="right" valign="top"><a id="a9de97e67d19ad7d3d8bd98bd13f2cb27"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>node_topics_from_pq</b> (<a class="el" href="classfz_1_1Node.html">Node</a> &amp;node, std::string topicsstr, std::string topicrelevancestr)</td></tr>
<tr class="separator:a9de97e67d19ad7d3d8bd98bd13f2cb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658f2d4bdcf3d5fced3a350eed24d1a3"><td class="memItemLeft" align="right" valign="top"><a id="a658f2d4bdcf3d5fced3a350eed24d1a3"></a>
<a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">td_property</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tdproperty_from_pq</b> (std::string pqtdproperty)</td></tr>
<tr class="separator:a658f2d4bdcf3d5fced3a350eed24d1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47cf2abbaba0b2f748c0d170a543c5c"><td class="memItemLeft" align="right" valign="top"><a id="aa47cf2abbaba0b2f748c0d170a543c5c"></a>
td_pattern&#160;</td><td class="memItemRight" valign="bottom"><b>tdpattern_from_pq</b> (std::string pqtdpattern)</td></tr>
<tr class="separator:aa47cf2abbaba0b2f748c0d170a543c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a879fdf29f58852f12083396988690"><td class="memItemLeft" align="right" valign="top"><a id="af4a879fdf29f58852f12083396988690"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>read_Nodes_pq</b> (PGconn *conn, std::string schemaname, <a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="separator:af4a879fdf29f58852f12083396988690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80adfe467cc24306945531b24fc2d766"><td class="memItemLeft" align="right" valign="top"><a id="a80adfe467cc24306945531b24fc2d766"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>read_Edges_pq</b> (PGconn *conn, std::string schemaname, <a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="separator:a80adfe467cc24306945531b24fc2d766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70525212cc7a8fff346a1540c8c8f8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfz_1_1Topic.html">Topic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#af70525212cc7a8fff346a1540c8c8f8a">main_topic</a> (<a class="el" href="classfz_1_1Topic__Tags.html">Topic_Tags</a> &amp;topictags, <a class="el" href="classfz_1_1Node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:af70525212cc7a8fff346a1540c8c8f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the main <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a>, as indicated by the maximum Topic_Relevance value.  <a href="#af70525212cc7a8fff346a1540c8c8f8a">More...</a><br /></td></tr>
<tr class="separator:af70525212cc7a8fff346a1540c8c8f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302a9b232573c36c992a057ff655cad7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfz_1_1Topic.html">Topic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a302a9b232573c36c992a057ff655cad7">main_topic</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;_graph, <a class="el" href="classfz_1_1Node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:a302a9b232573c36c992a057ff655cad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the main <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a>, as indicated by the maximum Topic_Relevance value.  <a href="#a302a9b232573c36c992a057ff655cad7">More...</a><br /></td></tr>
<tr class="separator:a302a9b232573c36c992a057ff655cad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d2b0e332e8c8cb2da50ef8a3fd395f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ac5d2b0e332e8c8cb2da50ef8a3fd395f">pq_LBlayout</a> (&quot;id timestamp (0) PRIMARY KEY&quot;)</td></tr>
<tr class="memdesc:ac5d2b0e332e8c8cb2da50ef8a3fd395f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notes about the Postgres <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> layout:  <a href="#ac5d2b0e332e8c8cb2da50ef8a3fd395f">More...</a><br /></td></tr>
<tr class="separator:ac5d2b0e332e8c8cb2da50ef8a3fd395f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5c069b6383bc4a981651bd9a25f2c5"><td class="memItemLeft" align="right" valign="top"><a id="a7a5c069b6383bc4a981651bd9a25f2c5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_LClayout</b> (&quot;id timestamp (0) PRIMARY KEY,&quot; &quot;nid char(16),&quot; &quot;tclose timestamp (0)&quot;)</td></tr>
<tr class="separator:a7a5c069b6383bc4a981651bd9a25f2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040c6fbb221224626b2495d36555ba20"><td class="memItemLeft" align="right" valign="top"><a id="a040c6fbb221224626b2495d36555ba20"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_LElayout</b> (&quot;id char(16),&quot; &quot;nid char(16),&quot; &quot;text text&quot;)</td></tr>
<tr class="separator:a040c6fbb221224626b2495d36555ba20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163df4ed695f0e00f7d1ff4c0efbf966"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a163df4ed695f0e00f7d1ff4c0efbf966">read_Breakpoints_pq</a> (<a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq, <a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:a163df4ed695f0e00f7d1ff4c0efbf966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load full Breakpoints table into Log::breakpoints.  <a href="#a163df4ed695f0e00f7d1ff4c0efbf966">More...</a><br /></td></tr>
<tr class="separator:a163df4ed695f0e00f7d1ff4c0efbf966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c13e8ff9e09d7fa7218c9b024eee6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#af0c13e8ff9e09d7fa7218c9b024eee6e">get_Chunk_pq_field_numbers</a> (PGresult *res)</td></tr>
<tr class="memdesc:af0c13e8ff9e09d7fa7218c9b024eee6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve field column numbers for chunks query to make sure the correct field numbers are used.  <a href="#af0c13e8ff9e09d7fa7218c9b024eee6e">More...</a><br /></td></tr>
<tr class="separator:af0c13e8ff9e09d7fa7218c9b024eee6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d216093fa5bf63db9826208d535ba7d"><td class="memItemLeft" align="right" valign="top"><a id="a8d216093fa5bf63db9826208d535ba7d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_Entry_pq_field_numbers</b> (PGresult *res)</td></tr>
<tr class="separator:a8d216093fa5bf63db9826208d535ba7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807cb2dee4f6e554f8f29042e8d39f72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a807cb2dee4f6e554f8f29042e8d39f72">read_Chunks_pq</a> (<a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq, <a class="el" href="classfz_1_1Log.html">Log</a> &amp;log, std::string wherestr=&quot;&quot;)</td></tr>
<tr class="memdesc:a807cb2dee4f6e554f8f29042e8d39f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load full Chunks table into Log::chunks.  <a href="#a807cb2dee4f6e554f8f29042e8d39f72">More...</a><br /></td></tr>
<tr class="separator:a807cb2dee4f6e554f8f29042e8d39f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33a508dd163fea401543abc5f20a8a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae33a508dd163fea401543abc5f20a8a2">read_Entries_pq</a> (<a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq, <a class="el" href="classfz_1_1Log.html">Log</a> &amp;log, std::string wherestr=&quot;&quot;)</td></tr>
<tr class="memdesc:ae33a508dd163fea401543abc5f20a8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load full Entries table into Log::entries.  <a href="#ae33a508dd163fea401543abc5f20a8a2">More...</a><br /></td></tr>
<tr class="separator:ae33a508dd163fea401543abc5f20a8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35c1e0f1b89afb3f7d1ecb898710296"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ad35c1e0f1b89afb3f7d1ecb898710296">TEST_load_Log_interval_pq</a> (<a class="el" href="classfz_1_1Log__interval.html">Log_interval</a> &amp;log, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa, time_t t_from, time_t t_to)</td></tr>
<tr class="memdesc:ad35c1e0f1b89afb3f7d1ecb898710296"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL! Load the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks and <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries with ID in a specified interval.  <a href="#ad35c1e0f1b89afb3f7d1ecb898710296">More...</a><br /></td></tr>
<tr class="separator:ad35c1e0f1b89afb3f7d1ecb898710296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af542142d941cd3b6ed66b5b6ed7bc181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfz_1_1Topic.html">Topic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#af542142d941cd3b6ed66b5b6ed7bc181">main_topic</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;_graph, <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &amp;chunk)</td></tr>
<tr class="memdesc:af542142d941cd3b6ed66b5b6ed7bc181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the main <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> of a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk's <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a>, as indicated by the maximum Topic_Relevance value.  <a href="#af542142d941cd3b6ed66b5b6ed7bc181">More...</a><br /></td></tr>
<tr class="separator:af542142d941cd3b6ed66b5b6ed7bc181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bdf475eb9d5fb9b7dfe97fe594498b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Log_chunks_Deque::size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a16bdf475eb9d5fb9b7dfe97fe594498b">Breakpoint_Indices</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:a16bdf475eb9d5fb9b7dfe97fe594498b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This converts the list of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> breakpoint <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk IDs into a list of indices into the list of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks (in Log::chunks).  <a href="#a16bdf475eb9d5fb9b7dfe97fe594498b">More...</a><br /></td></tr>
<tr class="separator:a16bdf475eb9d5fb9b7dfe97fe594498b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99de56e900ef8f39ac539d88521905ab"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a99de56e900ef8f39ac539d88521905ab">Log_span_in_seconds</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:a99de56e900ef8f39ac539d88521905ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the span in seconds from when the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was started (first cunk) to its most recent chunk.  <a href="#a99de56e900ef8f39ac539d88521905ab">More...</a><br /></td></tr>
<tr class="separator:a99de56e900ef8f39ac539d88521905ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99ee1f9eb33cd43975a1e2ba185affc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab99ee1f9eb33cd43975a1e2ba185affc">Log_span_in_days</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:ab99ee1f9eb33cd43975a1e2ba185affc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the span in days from when the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was started (first cunk) to its most recent chunk.  <a href="#ab99ee1f9eb33cd43975a1e2ba185affc">More...</a><br /></td></tr>
<tr class="separator:ab99ee1f9eb33cd43975a1e2ba185affc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac852c19de9635df74fca9eab2d419e5b"><td class="memItemLeft" align="right" valign="top">ymd_tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ac852c19de9635df74fca9eab2d419e5b">Log_span_years_months_days</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:ac852c19de9635df74fca9eab2d419e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the span in years, months and days from when the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was started (first cunk) to its most recent chunk.  <a href="#ac852c19de9635df74fca9eab2d419e5b">More...</a><br /></td></tr>
<tr class="separator:ac852c19de9635df74fca9eab2d419e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac009eb8797e3b0c24c3f4bf60941797"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Log_chunks_Deque::size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aac009eb8797e3b0c24c3f4bf60941797">Chunks_per_Breakpoint</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:aac009eb8797e3b0c24c3f4bf60941797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the frequency distribution for the number of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks per <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> breakpoint.  <a href="#aac009eb8797e3b0c24c3f4bf60941797">More...</a><br /></td></tr>
<tr class="separator:aac009eb8797e3b0c24c3f4bf60941797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0563de3c4cc5d0ad43ea49f58b6bd6"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aba0563de3c4cc5d0ad43ea49f58b6bd6">Chunks_total_minutes</a> (<a class="el" href="structfz_1_1Log__chunks__Deque.html">Log_chunks_Deque</a> &amp;chunks)</td></tr>
<tr class="memdesc:aba0563de3c4cc5d0ad43ea49f58b6bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the total number of minutes logged for all <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks in the specified deque.  <a href="#aba0563de3c4cc5d0ad43ea49f58b6bd6">More...</a><br /></td></tr>
<tr class="separator:aba0563de3c4cc5d0ad43ea49f58b6bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c5acaefdebe1051c4ff921bc754e68"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a31c5acaefdebe1051c4ff921bc754e68">TimeStamp</a> (const char *dateformat, time_t t)</td></tr>
<tr class="memdesc:a31c5acaefdebe1051c4ff921bc754e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate time stamp.  <a href="#a31c5acaefdebe1051c4ff921bc754e68">More...</a><br /></td></tr>
<tr class="separator:a31c5acaefdebe1051c4ff921bc754e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae57b0efbfc91e9c65004b3d40dd3ff71"><td class="memItemLeft" align="right" valign="top"><a id="ae57b0efbfc91e9c65004b3d40dd3ff71"></a>
<a class="el" href="structfz_1_1Stack__Tracer.html">Stack_Tracer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae57b0efbfc91e9c65004b3d40dd3ff71">errtracer</a></td></tr>
<tr class="memdesc:ae57b0efbfc91e9c65004b3d40dd3ff71"><td class="mdescLeft">&#160;</td><td class="mdescRight">The global stack tracer variable. <br /></td></tr>
<tr class="separator:ae57b0efbfc91e9c65004b3d40dd3ff71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6eca7b9586ecff715a8ad5bd26efb3e"><td class="memItemLeft" align="right" valign="top"><a id="ab6eca7b9586ecff715a8ad5bd26efb3e"></a>
<a class="el" href="classfz_1_1Errors.html">Errors</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ErrQ</b></td></tr>
<tr class="separator:ab6eca7b9586ecff715a8ad5bd26efb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcb97eafaecf389dd6dd7a9cbde00ed"><td class="memItemLeft" align="right" valign="top"><a id="aafcb97eafaecf389dd6dd7a9cbde00ed"></a>
<a class="el" href="classfz_1_1Errors.html">Errors</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WarnQ</b></td></tr>
<tr class="separator:aafcb97eafaecf389dd6dd7a9cbde00ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba84cce5b733cf4ca721bd800103b1c4"><td class="memItemLeft" align="right" valign="top"><a id="aba84cce5b733cf4ca721bd800103b1c4"></a>
<a class="el" href="classfz_1_1Simulate__PQ__Changes.html">Simulate_PQ_Changes</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SimPQ</b></td></tr>
<tr class="separator:aba84cce5b733cf4ca721bd800103b1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5946fa5b803240f1c0cd734f214c8c15"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>td_property_str</b> [_tdprop_num]</td></tr>
<tr class="separator:a5946fa5b803240f1c0cd734f214c8c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64dd91504fdcea08cc7617a5314ec6d2"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>td_pattern_str</b> [_patt_num]</td></tr>
<tr class="separator:a64dd91504fdcea08cc7617a5314ec6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd4b0fb0c54c1b32ee6a18e72bfccf1"><td class="memItemLeft" align="right" valign="top"><a id="a5bd4b0fb0c54c1b32ee6a18e72bfccf1"></a>
<a class="el" href="structfz_1_1formalizer__base__streams.html">formalizer_base_streams</a>&#160;</td><td class="memItemRight" valign="bottom"><b>base</b></td></tr>
<tr class="separator:a5bd4b0fb0c54c1b32ee6a18e72bfccf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812e6aee98e3ba6635c8fc4bed8ad57c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfz_1_1the__standard__object.html">the_standard_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a812e6aee98e3ba6635c8fc4bed8ad57c">standard</a></td></tr>
<tr class="memdesc:a812e6aee98e3ba6635c8fc4bed8ad57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This object projects one unique and clear interface with settings for standardized Formalizer programs, including exit hooks and other important requirements.  <a href="#a812e6aee98e3ba6635c8fc4bed8ad57c">More...</a><br /></td></tr>
<tr class="separator:a812e6aee98e3ba6635c8fc4bed8ad57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9f249ab6da4a5330fbf47805b36b49"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_topic_fieldnames</b> [_pqt_NUM]</td></tr>
<tr class="separator:a0e9f249ab6da4a5330fbf47805b36b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2e72b75f6a44514c6175b6dd58988c"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_node_fieldnames</b> [_pqn_NUM]</td></tr>
<tr class="separator:a4e2e72b75f6a44514c6175b6dd58988c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593c105236196b2da156f585c6d7ae30"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_edge_fieldnames</b> [_pqe_NUM]</td></tr>
<tr class="separator:a593c105236196b2da156f585c6d7ae30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40054abc0cdb4156693ceafa10eda38a"><td class="memItemLeft" align="right" valign="top"><a id="a40054abc0cdb4156693ceafa10eda38a"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>pq_topic_field</b> [_pqt_NUM]</td></tr>
<tr class="separator:a40054abc0cdb4156693ceafa10eda38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4a02a14d1fd045bd92c84b18c51cc1"><td class="memItemLeft" align="right" valign="top"><a id="a1a4a02a14d1fd045bd92c84b18c51cc1"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>pq_node_field</b> [_pqn_NUM]</td></tr>
<tr class="separator:a1a4a02a14d1fd045bd92c84b18c51cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae856eb9ebccda1813f38aef6ebed04b4"><td class="memItemLeft" align="right" valign="top"><a id="ae856eb9ebccda1813f38aef6ebed04b4"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>pq_edge_field</b> [_pqe_NUM]</td></tr>
<tr class="separator:ae856eb9ebccda1813f38aef6ebed04b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3867ed7aa9968c6dc3743c08621727"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">td_property</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tdprop_by_pqtdprop</b></td></tr>
<tr class="separator:acd3867ed7aa9968c6dc3743c08621727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47d47929bea0b332de69408d4880092"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, td_pattern &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tdpatt_by_pqtdpatt</b></td></tr>
<tr class="separator:ab47d47929bea0b332de69408d4880092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891acb04fd8751af330b359683bf1f32"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_chunk_fieldnames</b> [_pqlc_NUM]</td></tr>
<tr class="separator:a891acb04fd8751af330b359683bf1f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e1faf355d3b06d2b95e06e207f1cb7"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_entry_fieldnames</b> [_pqle_NUM]</td></tr>
<tr class="separator:a75e1faf355d3b06d2b95e06e207f1cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c60bcc3ec5facb69675fa478256a5a"><td class="memItemLeft" align="right" valign="top"><a id="a88c60bcc3ec5facb69675fa478256a5a"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>pq_chunk_field</b> [_pqlc_NUM]</td></tr>
<tr class="separator:a88c60bcc3ec5facb69675fa478256a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5220e38267cfa691460e3665ae9aee1d"><td class="memItemLeft" align="right" valign="top"><a id="a5220e38267cfa691460e3665ae9aee1d"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>pq_entry_field</b> [_pqle_NUM]</td></tr>
<tr class="separator:a5220e38267cfa691460e3665ae9aee1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab0d860bf18ea1cc2acb7577f4f294f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfz_1_1ReferenceTime.html">ReferenceTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aeab0d860bf18ea1cc2acb7577f4f294f">maintime</a></td></tr>
<tr class="memdesc:aeab0d860bf18ea1cc2acb7577f4f294f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Every program that uses core Formalizer functions that depend on time stamping includes <a class="el" href="ReferenceTime_8hpp_source.html">ReferenceTime.hpp</a> (it is automatically included through <a class="el" href="TimeStamp_8hpp.html" title="This header file declares Formalizer TimeStamp format and operations. ">TimeStamp.hpp</a>).  <a href="#aeab0d860bf18ea1cc2acb7577f4f294f">More...</a><br /></td></tr>
<tr class="separator:aeab0d860bf18ea1cc2acb7577f4f294f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>On Ubuntu, to install the libpq libraries, including the libpq-fe.h header file, do: sudo apt-get install libpq-dev You may also have to add /usr/include or /usr/include/postgresql to the CPATH or to the includes in the Makefile, e.g. </p>
<p>The utf8.cpp and <a class="el" href="utf8_8hpp.html" title="This header serves as a core utility wrapper for the open source cpputf library. ">utf8.hpp</a> files are core utility wrappers for the open source cpputf library.</p>
<p>A simmple set of templating functions.</p>
<p>This source file was separated out of Graphtypes.cpp in order to produce a separate compiled .obj file for <a class="el" href="classfz_1_1Graph.html">Graph</a> comparison (friend) helper utility functions.</p>
<p>General collection of functions used in various Core and Tool programs.</p>
<p>-I/usr/include/postgresql.</p>
<p>Those functions will not be needed by every program that needs the <a class="el" href="classfz_1_1Graph.html">Graph</a> data type header.</p>
<p>In many cases, this can be a small fast replacement for a feature-rich templating library such as <code>inja</code>.</p>
<p>See details in <a class="el" href="utf8_8hpp.html" title="This header serves as a core utility wrapper for the open source cpputf library. ">utf8.hpp</a>. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a22cb31bb2e4314340751a857568610fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cb31bb2e4314340751a857568610fe">&#9670;&nbsp;</a></span>Edges_Set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="classfz_1_1Edge.html">Edge</a>*&gt; <a class="el" href="namespacefz.html#a22cb31bb2e4314340751a857568610fe">fz::Edges_Set</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>targetdate: For details, see the description at <a href="https://docs.google.com/document/d/1rYPFgzFgjkF1xGx3uABiXiaDR5sfmOzqYQRqSntcyyY/edit#heading=h.nu3mb52d1k6n">https://docs.google.com/document/d/1rYPFgzFgjkF1xGx3uABiXiaDR5sfmOzqYQRqSntcyyY/edit#heading=h.nu3mb52d1k6n</a>. </p>
<p>topics: <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> tags specify logical categories to which a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> belongs. A <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> can belong to many categories, and new topic categories can be defined freely. By convention, every <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> must have at least 1 topic tag at all times. Since <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> storage can now be independent of <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> tagging there is no strict implementation reason for this. It has backward compatibility value. See the historical node for more. (historical) In the dil2al implementation of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> (DIL_entry), most of the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> data is stored in a 'DIL File', also known as a <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> or Topical File. Every <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> had to be stored in at least one such file (but could be copied in multiple such files), so that <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> data was stored. A <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> could not belong to zero DIL Files. </p>

</div>
</div>
<a id="a005101cd3360f7440301c8c033b397f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005101cd3360f7440301c8c033b397f8">&#9670;&nbsp;</a></span>Log_entries_Map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;const <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a>,std::unique_ptr&lt;<a class="el" href="classfz_1_1Log__entry.html">Log_entry</a>&gt; &gt; <a class="el" href="namespacefz.html#a005101cd3360f7440301c8c033b397f8">fz::Log_entries_Map</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><h3><a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries (map)</h3>
</p>
<p>A map of smart pointers to <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries, referenced by <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry ID key. This is how entries are connected in the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> data structure.</p>
<p>Consecutive entries (ordered by ID) are the primary records of the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a>, as stored in database format. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a95a7b508456ccb1691f487ed136d52d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a7b508456ccb1691f487ed136d52d4">&#9670;&nbsp;</a></span>exit_status_code</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefz.html#a95a7b508456ccb1691f487ed136d52d4">fz::exit_status_code</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standardized exit codes for the Formalizer environment. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a95a7b508456ccb1691f487ed136d52d4a705b1561a859fa4dfba9b3e3045d9f24"></a>exit_NUMENUMS&#160;</td><td class="fielddoc"><p>this one simplifies corresponding array definition, e.g. char[exit_NUMENUMS] </p>
</td></tr>
</table>

</div>
</div>
<a id="a6fd9cd34cd3b99c03b59b7054f5709df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd9cd34cd3b99c03b59b7054f5709df">&#9670;&nbsp;</a></span>pq_LBfields</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefz.html#a6fd9cd34cd3b99c03b59b7054f5709df">fz::pq_LBfields</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classfz_1_1Log.html" title="Log">Log</a> Breakpoint fields: </p>
<ul>
<li><code>pqlb_id</code>: a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk ID identifies each Breakpoint. </li>
</ul>

</div>
</div>
<a id="a229dcedb04cce4ee361097ae545fec1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229dcedb04cce4ee361097ae545fec1a">&#9670;&nbsp;</a></span>pq_LCfields</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefz.html#a229dcedb04cce4ee361097ae545fec1a">fz::pq_LCfields</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk fields: </p>
<ul>
<li><code>pqlc_id</code>: ID that also specifies the start time of a chunk.</li>
<li><code>pqlc_nid</code>: <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> ID of the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> to which the chunk belongs.</li>
<li><code>pqlc_tclose</code>: Chunk close time (or infinity if the cuhnk is still open). </li>
</ul>

</div>
</div>
<a id="a1adf8c508a2a57973cb07be9a12d345f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adf8c508a2a57973cb07be9a12d345f">&#9670;&nbsp;</a></span>pq_LEfields</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefz.html#a1adf8c508a2a57973cb07be9a12d345f">fz::pq_LEfields</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry fields: </p>
<ul>
<li><code>pqle_id</code>: ID that corresponds to a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk ID, with an index position.</li>
<li><code>pqle_nid</code>: possible <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> ID when the entry does not belong to the same <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> as the chunk.</li>
<li><code>pqle_text</code>: Entry text content. </li>
</ul>

</div>
</div>
<a id="a6c45e5e183774ed3322e5c3d445b3f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c45e5e183774ed3322e5c3d445b3f70">&#9670;&nbsp;</a></span>td_property</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">fz::td_property</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For more information about td_property values, as well as future expansions, please see the Formalizer documentation section <a href="https://docs.google.com/document/d/1rYPFgzFgjkF1xGx3uABiXiaDR5sfmOzqYQRqSntcyyY/edit#heading=h.nu3mb52d1k6n">Target date parameters in Graph v2.0+</a>. </p>
<p>Also consider Note 2 of the documentation of dil2graph.cc:get_Node_Target_Date() about target date hints in the <a class="el" href="classfz_1_1Graph.html">Graph</a> 2.0+ format parameters. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae767b87541ed3adf95ef80fb4cab307e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae767b87541ed3adf95ef80fb4cab307e">&#9670;&nbsp;</a></span>ActualTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::time_t fz::ActualTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly provide the actual system time. </p>
<p>This function is called where an emulated time status cannot be applied, such as when generating time stamps for backup files. </p>

</div>
</div>
<a id="ab26caa1b821a4715dbec90c174a95e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26caa1b821a4715dbec90c174a95e97">&#9670;&nbsp;</a></span>array_from_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; fz::array_from_pq </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pq_array_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a single string containing Postgres query output that represents an array into a vector of strings. </p>
<p>The Postgres array should be enclosed in curly brackets.</p>
<p>WARNING: This function assumes that every comma indicates a next element of the array. It does not consider the case where array elements may be quoted text that contains commas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pq_array_str</td><td>the Postgres query output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of strings, one for each array element. </dd></dl>

</div>
</div>
<a id="a16bdf475eb9d5fb9b7dfe97fe594498b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bdf475eb9d5fb9b7dfe97fe594498b">&#9670;&nbsp;</a></span>Breakpoint_Indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Log_chunks_Deque::size_type&gt; fz::Breakpoint_Indices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This converts the list of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> breakpoint <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk IDs into a list of indices into the list of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks (in Log::chunks). </p>
<p>Note: All <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks must be loaded into memory before calling this function.</p>
<p>If a breakpoint was not found then the corresponding element of the vector of indices has the value log::num_Chunks(), pointing beyond all valid <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks in the deque.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> object where all <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks are in the chunks deque. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of indices into log::chunks. </dd></dl>

</div>
</div>
<a id="aac009eb8797e3b0c24c3f4bf60941797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac009eb8797e3b0c24c3f4bf60941797">&#9670;&nbsp;</a></span>Chunks_per_Breakpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Log_chunks_Deque::size_type&gt; fz::Chunks_per_Breakpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the frequency distribution for the number of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks per <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> breakpoint. </p>
<p>Note: All <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks must be loaded into memory before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> object where all <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks are in the chunks deque. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of counts. </dd></dl>

</div>
</div>
<a id="aba0563de3c4cc5d0ad43ea49f58b6bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0563de3c4cc5d0ad43ea49f58b6bd6">&#9670;&nbsp;</a></span>Chunks_total_minutes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long fz::Chunks_total_minutes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1Log__chunks__Deque.html">Log_chunks_Deque</a> &amp;&#160;</td>
          <td class="paramname"><em>chunks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the total number of minutes logged for all <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks in the specified deque. </p>
<p>Sum of durations of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunks</td><td>a deque containing a sorted list <a class="el" href="classfz_1_1Log__chunk.html" title="Specifies the start time, Node, close time, and set of entries of a Log chunk. ">Log_chunk</a> pointers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum total of time logged in minutes. </dd></dl>

</div>
</div>
<a id="a3cd066a32696261830f98ca59ce4a7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd066a32696261830f98ca59ce4a7f0">&#9670;&nbsp;</a></span>Clean_Exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::Clean_Exit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ecode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up after yourself before you exit. </p>
<p>Call this to exit the program and log any remaining errors in the queue.</p>
<p>The ERRWARN_SUMMARY() macro can be used to print a summary report before calling this function. After this function the queues will be empty.</p>
<p>Note: If you are using <a class="el" href="standard_8hpp.html" title="This header file declares standard structures and functions that should be used with any standardized...">standard.hpp</a> (which every Formalizer program should) then do not use this function. The correct exit processes will be set up by member functions and initialization of the <code><a class="el" href="namespacefz.html#a812e6aee98e3ba6635c8fc4bed8ad57c" title="This object projects one unique and clear interface with settings for standardized Formalizer program...">fz::standard</a></code> object instead. In your program, you can then simply call <code>exit(error_code)</code> or <code>standard.exit(error_code)</code>. Both will do the same thing. </p>

</div>
</div>
<a id="a9bde9da1de78d7bc0492b22eba9630e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bde9da1de78d7bc0492b22eba9630e8">&#9670;&nbsp;</a></span>connection_setup_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PGconn * fz::connection_setup_pq </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up a connection with an existing Postgres database. </p>
<p>This also prepares a safe search search path. The database needs to exist. If necessary, create it with the command <code>createdb [databasename]</code> (which defaults to the user name).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a125c22828646b624c8e4f4775f84dc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125c22828646b624c8e4f4775f84dc5d">&#9670;&nbsp;</a></span>create_Breakpoints_table_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Breakpoints_table_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;&#160;</td>
          <td class="paramname"><em>apq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new database table for Breakpoints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apq</td><td>active database connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if table was successfully created. </dd></dl>

</div>
</div>
<a id="ad2da8c677f43a85e7f86d9074e468962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2da8c677f43a85e7f86d9074e468962">&#9670;&nbsp;</a></span>create_Edges_table_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Edges_table_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new database table for Edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>active database connection. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if table was successfully created. </dd></dl>

</div>
</div>
<a id="abe69e72e6cc57d40e3738f2bb2d7b1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe69e72e6cc57d40e3738f2bb2d7b1bc">&#9670;&nbsp;</a></span>create_Enum_Types_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Enum_Types_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create enumerated types in database for <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> and <a class="el" href="classfz_1_1Edge.html">Edge</a> data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>active database connection. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if types were successfully created. </dd></dl>

</div>
</div>
<a id="a44280392e614e1145d3c5a27aa640b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44280392e614e1145d3c5a27aa640b59">&#9670;&nbsp;</a></span>create_Formalizer_schema_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Formalizer_schema_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new database schema for Formalizer data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>active database connection. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if schema was successfully created. </dd></dl>

</div>
</div>
<a id="aebd926038748af1ffa7f75a0f6643c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd926038748af1ffa7f75a0f6643c38">&#9670;&nbsp;</a></span>create_Guide_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Guide_table </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;&#160;</td>
          <td class="paramname"><em>apq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>guidetable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>guidetablelayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the table for Guide snippets if it does not already exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>is an open database connection. </td></tr>
    <tr><td class="paramname">schemaname</td><td>is the Formalizer schema name (usually Graph_access::pq_schemaname). </td></tr>
    <tr><td class="paramname">guidetable</td><td>is the Guide table name (e.g. "guide_system"). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44a2d42be5384357b19e513b20b1c77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a2d42be5384357b19e513b20b1c77b">&#9670;&nbsp;</a></span>create_Logchunks_table_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Logchunks_table_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;&#160;</td>
          <td class="paramname"><em>apq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new database table for <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apq</td><td>active database connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if table was successfully created. </dd></dl>

</div>
</div>
<a id="aa8ef5ef0384e0d621bbff628679d3981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ef5ef0384e0d621bbff628679d3981">&#9670;&nbsp;</a></span>create_Logentries_table_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Logentries_table_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;&#160;</td>
          <td class="paramname"><em>apq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new database table for <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apq</td><td>active database connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if table was successfully created. </dd></dl>

</div>
</div>
<a id="a75375e8fb94d22f2facb4085afe93de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75375e8fb94d22f2facb4085afe93de9">&#9670;&nbsp;</a></span>create_Nodes_table_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Nodes_table_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new database table for Nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>active database connection. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if table was successfully created. </dd></dl>

</div>
</div>
<a id="a2359bd1e82e68f38bd9d900588887fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2359bd1e82e68f38bd9d900588887fde">&#9670;&nbsp;</a></span>create_Topics_table_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Topics_table_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new database table for Topics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>active database connection. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if table was successfully created. </dd></dl>

</div>
</div>
<a id="ab2f47cae19dab82915dc813045ee3cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f47cae19dab82915dc813045ee3cfe">&#9670;&nbsp;</a></span>Entries_total_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long fz::Entries_total_text </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacefz.html#a005101cd3360f7440301c8c033b397f8">Log_entries_Map</a> &amp;&#160;</td>
          <td class="paramname"><em>entries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the total number of characters in <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry description text in the specified map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entries</td><td>a map containing <a class="el" href="structfz_1_1Log__entry__ID__key.html" title="Standardized Formalizer Log entry ID key. ">Log_entry_ID_key</a> and <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> smart pointer pairs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum total of text characters. </dd></dl>

</div>
</div>
<a id="a8a40b1a728ffe05a3aca94bc24daff0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a40b1a728ffe05a3aca94bc24daff0e">&#9670;&nbsp;</a></span>epochtime_from_timestamp_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t fz::epochtime_from_timestamp_pq </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pqtimestamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert Postgres query result time stamp strings to Unix time, for example, for <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> target date parameter. </p>
<p>The format returned by PQgetvalue() is '2015-01-03 16:00:00'. As long as DATESTYLE has not been altered (e.g. with 'set datestyle to DMY'), the standard ISO format is YMD. It might be best to confirm that. Empty or 'infinity' (or other non-numerical time stamps) are interpreted as unspecified, for which -1 is returned.</p>
<p>This uses the UTC / Local Time convention built into <a class="el" href="namespacefz.html#a50b50bdd16d9e99e3ff4bf398f3fe68f" title="Convert a Formalizer time stamp string into local Unix time. ">time_stamp_time()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pqtimestamp</td><td>a time stamp string obtained via PQgetvalue(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unix time stamp as seconds since 00:00:00 UTC, January 1, 1970 or -1 when unspecified or invalid format. </dd></dl>

</div>
</div>
<a id="a5cdf2285bd874038959c3aca55feac8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdf2285bd874038959c3aca55feac8d">&#9670;&nbsp;</a></span>error_summary_wrapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::error_summary_wrapper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wrapped version of ERRWARN_SUMMARY that can be stacked. </p>
<p>This can be suppressed either by setting base.out to nullptr or by setting the standard.quiet flag. (Note that this flag receives a copy of any formalizer_standard_program::quiet when formalizer_standard_program::exit() is used.) </p>

</div>
</div>
<a id="aac311316b5a762d53489ec1135d88479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac311316b5a762d53489ec1135d88479">&#9670;&nbsp;</a></span>file_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::file_to_string </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ifstream::iostate *&#160;</td>
          <td class="paramname"><em>readstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the full contents of a (text) file into a string. </p>
<p>The contents of the receiving string are replaced. For efficiency, this function finds the size of the file and reserves space in the string before pulling in the content.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>of the file. </td></tr>
    <tr><td class="paramname">s</td><td>reference to the receiving string. </td></tr>
    <tr><td class="paramname">readstate</td><td>returns the iostate flags when provided (default: nullptr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the read into string was successful. </dd></dl>

</div>
</div>
<a id="af0c13e8ff9e09d7fa7218c9b024eee6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c13e8ff9e09d7fa7218c9b024eee6e">&#9670;&nbsp;</a></span>get_Chunk_pq_field_numbers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::get_Chunk_pq_field_numbers </td>
          <td>(</td>
          <td class="paramtype">PGresult *&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve field column numbers for chunks query to make sure the correct field numbers are used. </p>
<p>This is an extra safety measure in case formats are changed in the future and in case of potential database version mismatch.</p>
<p>This function updates the field numbers in <code>pq_chunk_field</code>. The field names that this version assumes are in the variable <code>pq_chunk_fieldnames</code>. The fields are enumerated with <code>pq_LCfields</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>a valid pointer obtained by <code>PQgetResult()</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all the field names were found. </dd></dl>

</div>
</div>
<a id="ac5e9d57226726175af8c8e276edd0c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e9d57226726175af8c8e276edd0c58">&#9670;&nbsp;</a></span>get_DIL_entry_num_superiors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fz::get_DIL_entry_num_superiors </td>
          <td>(</td>
          <td class="paramtype">DIL_entry *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of connections from a DIL entry to Superiors. </p>
<p>Note: Perhaps this function belongs in the utilities.cc library of dil2al.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>pointer to DIL_entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count of number of connections to Superiors. </dd></dl>

</div>
</div>
<a id="aa7838e7b982bd5a885f69f42a8fa929c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7838e7b982bd5a885f69f42a8fa929c">&#9670;&nbsp;</a></span>get_DIL_Graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Detailed_Items_List * fz::get_DIL_Graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To USE and COMPILE : </p>
<p>Load the whole Detailed_Items_List and return a pointer to its data structure.</p>
<ol type="1">
<li>The up-to-date dil2al.hh header file must be on the include path, e.g. by adding -I/home/randalk/src/dil2al.</li>
<li>The necessary functions that are declared there must be compiled in up-to-date object files made accessible, e.g. by adding them in dependencies and in the build command.</li>
</ol>
<p>For an example, see the Makefile of formalizer/tools/dil2graph.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to Detailed_Items_List object, or NULL if unsuccessful. </dd></dl>

</div>
</div>
<a id="a02517c2cf1052f55bb388a0808fdaa1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02517c2cf1052f55bb388a0808fdaa1b">&#9670;&nbsp;</a></span>get_DIL_hierarchy_num_connections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fz::get_DIL_hierarchy_num_connections </td>
          <td>(</td>
          <td class="paramtype">Detailed_Items_List *&#160;</td>
          <td class="paramname"><em>dil</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of connections in a DIL hierarchy. </p>
<p>Note: Perhaps this function belongs in the utilties.cc library of dil2al.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dil</td><td>pointer to DIL hierarchy (Detailed_Items_List). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count of total number of connections in the hierarchy. </dd></dl>

</div>
</div>
<a id="a004bd737f1c412b124eaf7ca6df90603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004bd737f1c412b124eaf7ca6df90603">&#9670;&nbsp;</a></span>get_DIL_Topics_File_List()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; fz::get_DIL_Topics_File_List </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the actual set of Topical DIL Files that exist in the dil2al base directory. </p>
<p>This function requires that <code>basedir</code> is valid, otherwise the <a class="el" href="namespacefz.html#aa23b82243a12ae2b0d35ccb70d785857" title="Execute a shell command and retrieve the standard output as a string. ">shellcmd2str()</a> call will throw a runtime_error. This function does not distinguish between actual files and symlinks (see detect_DIL_Topics_Symlinks()).</p>
<p>Note: Perhaps this function belongs in the utilities.cc library of dil2al.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the absolute file name strings of each Topical DIL File. </dd></dl>

</div>
</div>
<a id="afe38748c6da4110ea71ee010642d3606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe38748c6da4110ea71ee010642d3606">&#9670;&nbsp;</a></span>get_Topic_pq_field_numbers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::get_Topic_pq_field_numbers </td>
          <td>(</td>
          <td class="paramtype">PGresult *&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve field column numbers for topics query to make sure the correct field numbers are used. </p>
<p>This is an extra safety measure in case formats are changed in the future and in case of potential database version mismatch.</p>
<p>This function updates the field numbers in pq_topic_field. The field names that this version assumes are in the variable pq_topic_fieldnames. The fields are enumerated with pq_Tfields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>a valid pointer obtained by PQgetResult(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all the field names were found. </dd></dl>

</div>
</div>
<a id="a569da80848b8001bc12867337f51d1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569da80848b8001bc12867337f51d1c9">&#9670;&nbsp;</a></span>identical_Graphs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::identical_Graphs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>trace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two Graphs to report if they are data-identical. </p>
<p>friend (utility) functions</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph1</td><td>the first <a class="el" href="classfz_1_1Graph.html">Graph</a>. </td></tr>
    <tr><td class="paramname">graph2</td><td>the second <a class="el" href="classfz_1_1Graph.html">Graph</a>. </td></tr>
    <tr><td class="paramname">trace</td><td>if a difference is found then this contains a trace. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two Graphs are equivalent. </dd></dl>

</div>
</div>
<a id="a96f4dc710aff55f6fd9c2e111d7df259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f4dc710aff55f6fd9c2e111d7df259">&#9670;&nbsp;</a></span>identical_Nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::identical_Nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>trace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if two <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> objects contain the same data. </p>
<p>Note that this does not compare the rapid-access Edges_Set supedges and depedges, since they are sets of pointers created as <a class="el" href="classfz_1_1Graph.html">Graph</a> Edges are added. They might end up in a different order, but they ought to be the same ones as in the Edge_Map. </p>

</div>
</div>
<a id="a30be49d20ac6c8ba1b313fc295a235a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30be49d20ac6c8ba1b313fc295a235a2">&#9670;&nbsp;</a></span>is_leapyear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::is_leapyear </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>year</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A simple leap year test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">year</td><td>the year. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it is a leap year. </dd></dl>

</div>
</div>
<a id="add2e1a49e1871f23c757c97c84484676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add2e1a49e1871f23c757c97c84484676">&#9670;&nbsp;</a></span>keyrel_from_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structfz_1_1Topic__Keyword.html">Topic_Keyword</a>&gt; fz::keyrel_from_pq </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>keywordstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>relevancestr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert textual arrays of keywords and keyword-relevance values to a vector of <a class="el" href="structfz_1_1Topic__Keyword.html" title="Type for real-valued Keyword relevance (to Topic), presently assumed to be in the interval [0...">Topic_Keyword</a> pairs. </p>
<p>Keywords are allowed to contain more than one word, separated by spaces. This function strips away the front and back double-quotes that the PGgetvalue() function returns around such composite keywords.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keywordstr</td><td>string containing the textual array of keywords. </td></tr>
    <tr><td class="paramname">relevancestr</td><td>string containing the textual array of relevance values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of <a class="el" href="structfz_1_1Topic__Keyword.html" title="Type for real-valued Keyword relevance (to Topic), presently assumed to be in the interval [0...">Topic_Keyword</a> pairs of (keyword,relevance). </dd></dl>

</div>
</div>
<a id="aef824584d56abd3b06028a3925a9541c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef824584d56abd3b06028a3925a9541c">&#9670;&nbsp;</a></span>load_Edge_parameter_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; fz::load_Edge_parameter_interval </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pq_Efields&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>from_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>num_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load specific <a class="el" href="classfz_1_1Edge.html">Edge</a> parameter column interval from PostgreSQL database. </p>
<p>This interface attempts to hide as much as possible about the Postgres specifics of the operation, in order to preserve a Formalizer database access protocol across different possible underlying database choices.</p>
<p>Note: For this reason, the lowest possible interval start is 0 (not 1, as per SQL row numbering convention).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dbname</td><td>the Postgres database. </td></tr>
    <tr><td class="paramname">schemaname</td><td>the Formalizer schema name (usually provided by Graph_access::pq_schemaname) </td></tr>
    <tr><td class="paramname">param</td><td>the enumerated parameter identifier. </td></tr>
    <tr><td class="paramname">from_row</td><td>the first row in the interval, counting from 0. </td></tr>
    <tr><td class="paramname">num_rows</td><td>the number of rows in the intervial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector with string elements, one for each row. </dd></dl>

</div>
</div>
<a id="a615c9833189de86268653cf1fc95f092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615c9833189de86268653cf1fc95f092">&#9670;&nbsp;</a></span>load_Graph_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::load_Graph_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load all the Nodes, Edges and Topics of the <a class="el" href="classfz_1_1Graph.html">Graph</a> from the PostgreSQL database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>a <a class="el" href="classfz_1_1Graph.html">Graph</a> for the Nodes and Edges, etc, typically empty. </td></tr>
    <tr><td class="paramname">dbname</td><td>database name. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classfz_1_1Graph.html">Graph</a> was successfully loaded from the database. </dd></dl>

</div>
</div>
<a id="a5688f3a5a5bb5066690ccff97430eaaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5688f3a5a5bb5066690ccff97430eaaa">&#9670;&nbsp;</a></span>load_Log_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::load_Log_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the full <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> with all <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks, <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries and Breakpoints from the PostgresSQL database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> for the Chunks, Entries and Breakpoints, typically empty. </td></tr>
    <tr><td class="paramname">pa</td><td>access object with database name and schema name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was succesfully loaded from the database. </dd></dl>

</div>
</div>
<a id="ad24f78e052197d9844de69ba284cfade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24f78e052197d9844de69ba284cfade">&#9670;&nbsp;</a></span>load_Node_parameter_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; fz::load_Node_parameter_interval </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pq_Nfields&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>from_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>num_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load specific <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> parameter column interval from PostgreSQL database. </p>
<p>This interface attempts to hide as much as possible about the Postgres specifics of the operation, in order to preserve a Formalizer database access protocol across different possible underlying database choices.</p>
<p>Note: For this reason, the lowest possible interval start is 0 (not 1, as per SQL row numbering convention).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dbname</td><td>the Postgres database. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
    <tr><td class="paramname">param</td><td>the enumerated parameter identifier. </td></tr>
    <tr><td class="paramname">from_row</td><td>the first row in the interval, counting from 0. </td></tr>
    <tr><td class="paramname">num_rows</td><td>the number of rows in the intervial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector with string elements, one for each row. </dd></dl>

</div>
</div>
<a id="ab99ee1f9eb33cd43975a1e2ba185affc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99ee1f9eb33cd43975a1e2ba185affc">&#9670;&nbsp;</a></span>Log_span_in_days()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double fz::Log_span_in_days </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report the span in days from when the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was started (first cunk) to its most recent chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> for which to report the span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the decimal number of days. </dd></dl>

</div>
</div>
<a id="a99de56e900ef8f39ac539d88521905ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99de56e900ef8f39ac539d88521905ab">&#9670;&nbsp;</a></span>Log_span_in_seconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long fz::Log_span_in_seconds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report the span in seconds from when the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was started (first cunk) to its most recent chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> for which to report the span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of seconds. </dd></dl>

</div>
</div>
<a id="ac852c19de9635df74fca9eab2d419e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac852c19de9635df74fca9eab2d419e5b">&#9670;&nbsp;</a></span>Log_span_years_months_days()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ymd_tuple fz::Log_span_years_months_days </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report the span in years, months and days from when the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was started (first cunk) to its most recent chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> for which to report the span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple of [year, month, day]. </dd></dl>

</div>
</div>
<a id="a7f17dcd15946bcb9a7fd70bf65e6fcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f17dcd15946bcb9a7fd70bf65e6fcc9">&#9670;&nbsp;</a></span>ltrim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; fz::ltrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>t</em> = <code>&quot;&#160;\t\n\r\f\v&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim whitespace from the front of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a string. </td></tr>
    <tr><td class="paramname">t</td><td>a string containing whitespace characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the trimmed string. </dd></dl>

</div>
</div>
<a id="af70525212cc7a8fff346a1540c8c8f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70525212cc7a8fff346a1540c8c8f8a">&#9670;&nbsp;</a></span>main_topic() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfz_1_1Topic.html">Topic</a>* fz::main_topic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Topic__Tags.html">Topic_Tags</a> &amp;&#160;</td>
          <td class="paramname"><em>topictags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the main <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a>, as indicated by the maximum Topic_Relevance value. </p>
<p>friend (utility) functions</p>
<p>Note: This is a friend function in order to ensure that the search for the <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> object is called only when a valid <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, arranged by integer Index-ID. ">Topic_Tags</a> list can provid pointers to them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, arranged by integer Index-ID. ">Topic_Tags</a></td><td>a valid <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, arranged by integer Index-ID. ">Topic_Tags</a> list. </td></tr>
    <tr><td class="paramname">node</td><td>a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> for which the main <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> object (or nullptr if not found). </dd></dl>

</div>
</div>
<a id="a302a9b232573c36c992a057ff655cad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302a9b232573c36c992a057ff655cad7">&#9670;&nbsp;</a></span>main_topic() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfz_1_1Topic.html">Topic</a>* fz::main_topic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the main <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a>, as indicated by the maximum Topic_Relevance value. </p>
<p>Note: This is a friend function in order to ensure that the search for the <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> object is called only when a valid <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, arranged by integer Index-ID. ">Topic_Tags</a> list that is known to a valid <a class="el" href="classfz_1_1Graph.html">Graph</a> can provid pointers to them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_graph</td><td>a valid <a class="el" href="classfz_1_1Graph.html">Graph</a> that has a <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, arranged by integer Index-ID. ">Topic_Tags</a> list. </td></tr>
    <tr><td class="paramname">node</td><td>a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> for which the main <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> object (or nullptr if not found). </dd></dl>

</div>
</div>
<a id="af542142d941cd3b6ed66b5b6ed7bc181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af542142d941cd3b6ed66b5b6ed7bc181">&#9670;&nbsp;</a></span>main_topic() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfz_1_1Topic.html">Topic</a>* fz::main_topic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &amp;&#160;</td>
          <td class="paramname"><em>chunk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the main <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> of a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk's <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a>, as indicated by the maximum Topic_Relevance value. </p>
<p>friend (utility) functions</p>
<p>Note: This is a friend function in order to ensure that the search for the <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> object is called only when a valid <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, arranged by integer Index-ID. ">Topic_Tags</a> list can provid pointers to them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_graph</td><td>a valid <a class="el" href="classfz_1_1Graph.html">Graph</a> with <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, arranged by integer Index-ID. ">Topic_Tags</a> list. </td></tr>
    <tr><td class="paramname">chunk</td><td>a <a class="el" href="classfz_1_1Log__chunk.html" title="Specifies the start time, Node, close time, and set of entries of a Log chunk. ">Log_chunk</a> for which the main <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> object (or nullptr if not found). </dd></dl>

</div>
</div>
<a id="ac5d2b0e332e8c8cb2da50ef8a3fd395f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d2b0e332e8c8cb2da50ef8a3fd395f">&#9670;&nbsp;</a></span>pq_LBlayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::pq_LBlayout </td>
          <td>(</td>
          <td class="paramtype">&quot;id timestamp (0) PRIMARY KEY&quot;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notes about the Postgres <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> layout: </p>
<ul>
<li>About the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry <code>minor_id</code>: Where <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> elements are concerned, we made the assumption in the 2.x data structure that there would never be more than 9 created in the same second. Hence, the minor_id required only 1 digit to store. The situation is different for <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries. First of all, the major part of the ID is only YYYYmmddHHMM (without seconds). Secondly, it is entirely possible that a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk could contain many more than 9 <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries. Therefore, <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry ID storage requires more digit space for the <code>minor_id</code>. In the current version of the data structure (see coreversion), we are assuming that, because the <code>minor_id</code> is encoded as a <code>uint8_t</code>, there can be a maximum of 255 <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries in a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk. The <code>minor_id</code> is given a 3 digit space in the <code>.logentries</code> Postgres table. </li>
</ul>

</div>
</div>
<a id="a7d24b6e4b1323e5d5687d184aa48fb4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d24b6e4b1323e5d5687d184aa48fb4a">&#9670;&nbsp;</a></span>query_call_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::query_call_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>qstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>request_single_row_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch a Postgres query for asynchronous processing in batch or single row mode. </p>
<p>Uses PQsendQuery() and PQsetSingleRowMode().</p>
<p>To receive results, use PQgetResult(), calling that function repeatedly if in single row mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>a valid Postgres connection object. </td></tr>
    <tr><td class="paramname">qstr</td><td>a Postgres query string. </td></tr>
    <tr><td class="paramname">request_single_row_mode</td><td>switches only this query to single row mode if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the query was successfully dispatched. </dd></dl>

</div>
</div>
<a id="a163df4ed695f0e00f7d1ff4c0efbf966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163df4ed695f0e00f7d1ff4c0efbf966">&#9670;&nbsp;</a></span>read_Breakpoints_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::read_Breakpoints_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;&#160;</td>
          <td class="paramname"><em>apq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load full Breakpoints table into Log::breakpoints. </p>
<p>We can only add Breakpoints by adding actual existing <a class="el" href="classfz_1_1Log__chunk.html" title="Specifies the start time, Node, close time, and set of entries of a Log chunk. ">Log_chunk</a> objects (which is a good safety mechanism). This means, that this function can really only be successfully called after calling <code><a class="el" href="namespacefz.html#a807cb2dee4f6e554f8f29042e8d39f72" title="Load full Chunks table into Log::chunks. ">read_Chunks_pq()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apq</td><td>data structure with active database connection pointer and schema name. </td></tr>
    <tr><td class="paramname">log</td><td>a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> object, typically with an existing chunks list but empty Breakpoints list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a807cb2dee4f6e554f8f29042e8d39f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807cb2dee4f6e554f8f29042e8d39f72">&#9670;&nbsp;</a></span>read_Chunks_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::read_Chunks_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;&#160;</td>
          <td class="paramname"><em>apq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>wherestr</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load full Chunks table into Log::chunks. </p>
<p>EXPERIMENTING: With optional WHERE statement! Just in case this function can be reused for load_Log_interval()! </p>

</div>
</div>
<a id="ae33a508dd163fea401543abc5f20a8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33a508dd163fea401543abc5f20a8a2">&#9670;&nbsp;</a></span>read_Entries_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::read_Entries_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;&#160;</td>
          <td class="paramname"><em>apq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>wherestr</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load full Entries table into Log::entries. </p>
<p>We can only add Entries while referring to existing Log_chunks (which is a good safety mechanism). This means, that this function can really only be successfully called after calling <code><a class="el" href="namespacefz.html#a807cb2dee4f6e554f8f29042e8d39f72" title="Load full Chunks table into Log::chunks. ">read_Chunks_pq()</a></code>.</p>
<p>EXPERIMENTING: With optional WHERE statement! Just in case this function can be reused for load_Log_interval()!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apq</td><td>data structure with active database connection pointer and schema name. </td></tr>
    <tr><td class="paramname">log</td><td>a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> object, typically with an existing chunks list but empty Breakpoints list. </td></tr>
    <tr><td class="paramname">wherestr</td><td>An optional WHERE string to constrain which records are retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful. </dd></dl>

</div>
</div>
<a id="ae2f30f53fd171c9a6c7f03cf96c983ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f30f53fd171c9a6c7f03cf96c983ba">&#9670;&nbsp;</a></span>read_Guide_snippet_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::read_Guide_snippet_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1Guide__snippet.html">Guide_snippet</a> &amp;&#160;</td>
          <td class="paramname"><em>snippet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single snippet from a Guide table in the database. </p>
<p>The <code>snippet</code> should specify <code>snippet.tablename</code> and a working <code>idstr()</code> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snippet</td><td>data structure that clearly identifies the snippet and receives the resulting text. </td></tr>
    <tr><td class="paramname">pa</td><td>access data with database name and schema name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f1cf55c9ed8689f087102061c60154a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1cf55c9ed8689f087102061c60154a">&#9670;&nbsp;</a></span>rtrim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; fz::rtrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>t</em> = <code>&quot;&#160;\t\n\r\f\v&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim whitespace from the end of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a string. </td></tr>
    <tr><td class="paramname">t</td><td>a string containing whitespace characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the trimmed string. </dd></dl>

</div>
</div>
<a id="a4a72c04fc5a7860678e9156bd32b5aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a72c04fc5a7860678e9156bd32b5aa1">&#9670;&nbsp;</a></span>safe_cmdline_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, std::string &gt; fz::safe_cmdline_options </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>optindcopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safer parsing of command line parameters. </p>
<p>This wrapper aims to reduce that ways in which parsing command line parameters can lead to segfaults. (The getopt() function is not very safe in that regard.)</p>
<p>Note: This wrapper does use getopt() and getopt() is known to modify argv. Therefore, if you need the original argv, copy it before calling this functions. For example, with <code>std::vector&lt;std::string&gt; cmdargs; for (int i = 0; i &lt; argc; ++i) cmdargs[i] = argv[i];</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>is the argc from main(). </td></tr>
    <tr><td class="paramname">argv</td><td>is the argv from main(). </td></tr>
    <tr><td class="paramname">options</td><td>is the options list in the same format as for getopt(). </td></tr>
    <tr><td class="paramname">optindcopy</td><td>is a variable reference that receives a copy of optind as used by getopt(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59b42530ac38402a5656af5bdcac5be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b42530ac38402a5656af5bdcac5be6">&#9670;&nbsp;</a></span>sample_query_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fz::sample_query_data </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>databufstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function that dumps several rows of data to a string buffer for easy inspection. </p>
<p>A <a class="el" href="namespacefz.html#a7d24b6e4b1323e5d5687d184aa48fb4a" title="Dispatch a Postgres query for asynchronous processing in batch or single row mode. ">query_call_pq()</a> or equivalent should precede this.</p>
<p>To sample all columns simple set cend &gt; number of columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>an active Postgres connection. </td></tr>
    <tr><td class="paramname">rstart</td><td>first row to sample. </td></tr>
    <tr><td class="paramname">rend</td><td>one after last row to sample. </td></tr>
    <tr><td class="paramname">cstart</td><td>first column to sample. </td></tr>
    <tr><td class="paramname">cend</td><td>one after last column to sample. </td></tr>
    <tr><td class="paramname">databufstr</td><td>a string buffer for sampled data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of rows sampled. </dd></dl>

</div>
</div>
<a id="aa23b82243a12ae2b0d35ccb70d785857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23b82243a12ae2b0d35ccb70d785857">&#9670;&nbsp;</a></span>shellcmd2str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::shellcmd2str </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a shell command and retrieve the standard output as a string. </p>
<p>Note that this function will throw a runtime_error if the command could not be executed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>the shell command to execute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing the standard output of the executed command. </dd></dl>

</div>
</div>
<a id="aa1a653de26479eb7d85b850ec2918c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a653de26479eb7d85b850ec2918c2a">&#9670;&nbsp;</a></span>simple_call_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::simple_call_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>astr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a simple action call to a Postgres database. </p>
<p>Note: If the global flag simulate_pq_changes==true then this function does not execute Postgres calls. Instead, the call string will be added to simulated_pq_calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>active database connection. </td></tr>
    <tr><td class="paramname">astr</td><td>action call string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if action call was successful. </dd></dl>

</div>
</div>
<a id="a45a30fb04b5721cd05047bd4088fb8b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a30fb04b5721cd05047bd4088fb8b0">&#9670;&nbsp;</a></span>split() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Out &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fz::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Out&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put pieces of a string into a pre-constructed vector. </p>
<p>See for example how this is used in the <a class="el" href="namespacefz.html#a45a30fb04b5721cd05047bd4088fb8b0" title="Put pieces of a string into a pre-constructed vector. ">split()</a> function below. Borrowed from: <a href="https://stackoverflow.com/questions/236129/how-do-i-iterate-over-the-words-of-a-string">https://stackoverflow.com/questions/236129/how-do-i-iterate-over-the-words-of-a-string</a> Note that this solution does not skip empty tokens, so the following will find 4 items, one of which is empty: std::vector&lt;std::string&gt; x = split("one:two::three", ':');</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a string. </td></tr>
    <tr><td class="paramname">delim</td><td>a delimiter character. </td></tr>
    <tr><td class="paramname">result</td><td>a std::back_insert_iterator for the result container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7dc083b5c0e84d7d715161e462a321f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7dc083b5c0e84d7d715161e462a321f">&#9670;&nbsp;</a></span>split() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; fz::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector containing pieces of a string. </p>
<p>This uses the <a class="el" href="namespacefz.html#a45a30fb04b5721cd05047bd4088fb8b0" title="Put pieces of a string into a pre-constructed vector. ">split()</a> template above. It lets you do things like pass the result directly to a function like this: f(split(s, d, v)) while still having the benefit of a pre-allocated vector if you like.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a string. </td></tr>
    <tr><td class="paramname">delim</td><td>a delimiter character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of strings. </dd></dl>

</div>
</div>
<a id="a1cb865200e35c530ff09a2a5c142c55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb865200e35c530ff09a2a5c142c55a">&#9670;&nbsp;</a></span>store_Graph_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::store_Graph_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(unsigned long, unsigned long)&#160;</td>
          <td class="paramname"><em>progress_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store all the Nodes and Edges of the <a class="el" href="classfz_1_1Graph.html">Graph</a> in the PostgreSQL database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>a <a class="el" href="classfz_1_1Graph.html">Graph</a> containing all of the Nodes and Edges. </td></tr>
    <tr><td class="paramname">dbname</td><td>database name. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
    <tr><td class="paramname">progress_func</td><td>points to an optional progress indicator function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classfz_1_1Graph.html">Graph</a> was successfully stored in the database. </dd></dl>

</div>
</div>
<a id="af8eebdb96e1f6ab62ce592c84ea3e669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8eebdb96e1f6ab62ce592c84ea3e669">&#9670;&nbsp;</a></span>store_Guide_snippet_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::store_Guide_snippet_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Guide__snippet.html">Guide_snippet</a> &amp;&#160;</td>
          <td class="paramname"><em>snippet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a new Guide snippet in the PostgreSQL database. </p>
<p>Creates the table if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snippet</td><td>a guide snippet. </td></tr>
    <tr><td class="paramname">pa</td><td>a standard database access stucture with database name and schema name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the snippet was successfully stored in the database. </dd></dl>

</div>
</div>
<a id="ac534af76c643c9568951e81e51066108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac534af76c643c9568951e81e51066108">&#9670;&nbsp;</a></span>store_Log_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::store_Log_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(unsigned long, unsigned long)&#160;</td>
          <td class="paramname"><em>progressfunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store all the Chunks and Entries of the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> in the PostgreSQL database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> containing all of the Chunks and Entries. </td></tr>
    <tr><td class="paramname">pa</td><td>access object with database name and Formalizer schema name. </td></tr>
    <tr><td class="paramname">progress_func</td><td>points to an optional progress indicator function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was successfully stored in the database. </dd></dl>

</div>
</div>
<a id="ae354d176f2f483264ec225411f7eb122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae354d176f2f483264ec225411f7eb122">&#9670;&nbsp;</a></span>stream_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::stream_to_string </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the full contents of a (text) stream into a string. </p>
<p>This implementation was tested to be faster than the one-liner implementations shown at <a href="https://stackoverflow.com/questions/3203452/how-to-read-entire-stream-into-a-stdstring,">https://stackoverflow.com/questions/3203452/how-to-read-entire-stream-into-a-stdstring,</a> at least as of Oct. 2011. It might be even faster to pre-allocate buffer space according to stream size, as per the example inhttp://www.cplusplus.com/reference/istream/istream/read/, but it isn't immediately clear to me if that also works with STDIN.</p>
<p>Note: This can be used with STDIN (<code>cin</code>) as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>is an open istream. </td></tr>
    <tr><td class="paramname">s</td><td>reference to the receiving string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the read into string was successful. </dd></dl>

</div>
</div>
<a id="a11e5fa50448d4b9ffb38afea0ae0ea1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e5fa50448d4b9ffb38afea0ae0ea1a">&#9670;&nbsp;</a></span>string_to_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::string_to_file </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream::iostate *&#160;</td>
          <td class="paramname"><em>writestate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the full contents of a string to a file. </p>
<p>Note that this function does NOT create a backup of a previous file at the given path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>of the file. </td></tr>
    <tr><td class="paramname">s</td><td>reference to the string. </td></tr>
    <tr><td class="paramname">writestate</td><td>returns the iostate flags when provided (default: nullptr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the write from string was successful. </dd></dl>

</div>
</div>
<a id="a82121e1189c46fe028b6b6e9a073c8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82121e1189c46fe028b6b6e9a073c8d5">&#9670;&nbsp;</a></span>string_to_file_with_backup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::string_to_file_with_backup </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>backupext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>backedup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream::iostate *&#160;</td>
          <td class="paramname"><em>writestate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the full contents of a string to a file, but move an existing file at the given path to a backup name first. </p>
<p>Note that TimeStamp:<a class="el" href="namespacefz.html#abe4308075d0f8dc4c0129d8ee71740e5" title="Generate a Formalizer standardized file backup extension (YYYYmmdd.bak). ">BackupStampYmd()</a> and TimeStamp:<a class="el" href="namespacefz.html#a4932c9514aab01039104a5b0033934d4" title="Generate a Formalizer standardized file backup precise extension (YYYYmmddHHMM.bak). ">BackupStampYmdHM()</a> provide valid Formalizer standardized backup extension tags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>of the file. </td></tr>
    <tr><td class="paramname">s</td><td>reference to the string. </td></tr>
    <tr><td class="paramname">backupext</td><td>is the extension to use for a potential backup of existing. </td></tr>
    <tr><td class="paramname">backedup</td><td>stores a flag to indicate is an existing file was renamed to a backup. </td></tr>
    <tr><td class="paramname">writestate</td><td>returns the iostate flags when provided (default: nullptr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the write from string was successful. </dd></dl>

</div>
</div>
<a id="ad35c1e0f1b89afb3f7d1ecb898710296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35c1e0f1b89afb3f7d1ecb898710296">&#9670;&nbsp;</a></span>TEST_load_Log_interval_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::TEST_load_Log_interval_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log__interval.html">Log_interval</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>t_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>t_to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>EXPERIMENTAL! Load the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks and <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries with ID in a specified interval. </p>
<p>This can be used by smart on-demand <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> caching modes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>A <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> for the Chunks and Entries, typically empty. </td></tr>
    <tr><td class="paramname">pa</td><td>Access object with database name and schema name. </td></tr>
    <tr><td class="paramname">t_from</td><td>Chunk and entry IDs must be &gt;= <code>t_from</code>. </td></tr>
    <tr><td class="paramname">t_to</td><td>Chunk and entry IDs must be &lt;= <code>t_to</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was succesfully loaded from the database. </dd></dl>

</div>
</div>
<a id="a50b50bdd16d9e99e3ff4bf398f3fe68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b50bdd16d9e99e3ff4bf398f3fe68f">&#9670;&nbsp;</a></span>time_stamp_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t fz::time_stamp_time </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>timestr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noerror</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a Formalizer time stamp string into local Unix time. </p>
<p>Formalizer time stamp strings must have this format: 1) [^0-9]YYYYmmddHHMM (e.g. "202008140613", "__202109150714"), and, 2) the year must be &gt;= 1900, or, 3) a negative integer code (e.g. "-2").</p>
<p>Negative integer codes are returned the equivalent negative integer so that special codes can be detected.</p>
<p>Non-digit characters preceding the digits of a proper time stamp are ignored and discarded. (This does not apply to negative integer codes.)</p>
<p>When the 'noerror' flag is set then no error message will be added if an invalid time stamp is encountered. This can be useful when this function is explicitly used to check for empty/unfinished/etc time stamps.</p>
<p>The 1900 test is a useful sanity check, because mangled time stamp strings can often lead to unlikely dates preceding the computing era.</p>
<p>This function is derived from dil2al/utilities.cc:<a class="el" href="namespacefz.html#a50b50bdd16d9e99e3ff4bf398f3fe68f" title="Convert a Formalizer time stamp string into local Unix time. ">time_stamp_time()</a>. Unlike that function, this one does not terminate the program when an invalid time stamp is encountered and uses no configuration flag to elicit such behavior. Instead, the special code RTt_invalid_time_stamp is returned in that case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestr</td><td>a string containing the Formalizer time stamp. </td></tr>
    <tr><td class="paramname">noerror</td><td>suppresses ADDERROR() for invalid time stamps. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>local Unix time in seconds, negative integer code, or RTt_invalid_time_stamp.</dd></dl>
<p>Formalizer time stamp strings must have this format: 1) [^0-9]YYYYmmddHHMM (e.g. "202008140613", "__202109150714"), and, 2) the year must be &gt;= 1900, or, 3) a negative integer code (e.g. "-2").</p>
<p>Negative integer codes are returned the equivalent negative integer so that special codes can be detected.</p>
<p>Non-digit characters preceding the digits of a proper time stamp are ignored and discarded. (This does not apply to negative integer codes.)</p>
<p>When the 'noerror' flag is set then no error message will be added if an invalid time stamp is encountered. This can be useful when this function is explicitly used to check for empty/unfinished/etc time stamps.</p>
<p>The 1900 test is a useful sanity check, because mangled time stamp strings can often lead to unlikely dates preceding the computing era.</p>
<p>This function is derived from dil2al/utilities.cc:<a class="el" href="namespacefz.html#a50b50bdd16d9e99e3ff4bf398f3fe68f" title="Convert a Formalizer time stamp string into local Unix time. ">time_stamp_time()</a>. Unlike that function, this one does not terminate the program when an invalid time stamp is encountered and uses no configuration flag to elicit such behavior. Instead, the special code INVALID_TIME_STAMP is returned in that case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestr</td><td>a string containing the Formalizer time stamp. </td></tr>
    <tr><td class="paramname">noerror</td><td>suppresses ADDERROR() for invalid time stamps. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>local Unix time in seconds, negative integer code, or RTt_invalid_time_stamp. </dd></dl>

</div>
</div>
<a id="a31c5acaefdebe1051c4ff921bc754e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c5acaefdebe1051c4ff921bc754e68">&#9670;&nbsp;</a></span>TimeStamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::TimeStamp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dateformat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate time stamp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dateformat</td><td>a date and time format specifier, e.g. "%Y%m%d%H%M". </td></tr>
    <tr><td class="paramname">t</td><td>a date and time expressed in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The time stamp string. Returns an empty string if t&lt;0. </dd></dl>

</div>
</div>
<a id="a303e1d94ae3679f5fcc99dced6137cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303e1d94ae3679f5fcc99dced6137cb2">&#9670;&nbsp;</a></span>to_precision_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::to_precision_string </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>fillchar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print double to string with specific precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a real number. </td></tr>
    <tr><td class="paramname">p</td><td>precision (default 2). </td></tr>
    <tr><td class="paramname">fillchar</td><td>the fill character (default ' ', i.e. space). </td></tr>
    <tr><td class="paramname">w</td><td>minimum width (default 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string. </dd></dl>

</div>
</div>
<a id="acff76817b33dcd0a0c38c28e238ad2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff76817b33dcd0a0c38c28e238ad2d3">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; fz::trim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>t</em> = <code>&quot;&#160;\t\n\r\f\v&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim whitespace on both ends of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a string. </td></tr>
    <tr><td class="paramname">t</td><td>a string containing whitespace characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the trimmed string. </dd></dl>

</div>
</div>
<a id="a6b5a614340e67aa9ff729f387ca8e987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5a614340e67aa9ff729f387ca8e987">&#9670;&nbsp;</a></span>utf8_safe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::utf8_safe </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>utf8str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter a text string to ensure that it contains valid UTF8 encoded content. </p>
<p>Attempts to assign content to the text parameter as provided, and replaces any invalid UTF8 code points with a replacement character. The default replacement character is the UTF8 'REPLACEMENT CHARACTER' 0xfffd.</p>
<p>If invalid UTF8 code points were encountered and replaced then that is optionally reported through ADDWARNING.</p>
<p>Note 1: ASCII text is valid UTF8 text and will be assigned unaltered. Note 2: This does not test for valid HTML5 at this time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">utf8str</td><td>A string that should contain UTF8 encoded text. </td></tr>
    <tr><td class="paramname">warn</td><td>If true then warn about invalid UTF8 code replacements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A guaranteed utf8 compliant string. </dd></dl>

</div>
</div>
<a id="a045ec1abb4dc382e0b56e345c146de95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045ec1abb4dc382e0b56e345c146de95">&#9670;&nbsp;</a></span>valid_Log_chunk_ID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_Log_chunk_ID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> &amp;&#160;</td>
          <td class="paramname"><em>idT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>formerror</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a <a class="el" href="structfz_1_1Log__TimeStamp.html" title="Timestamp IDs in the format required for Log IDs. ">Log_TimeStamp</a> can be used as a valid <a class="el" href="classfz_1_1Log__chunk__ID.html">Log_chunk_ID</a>. </p>
<p>Note that years before 1999 are disqualified, since the Formalizer did not exist before then.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idT</td><td>reference to an <a class="el" href="structfz_1_1Log__TimeStamp.html" title="Timestamp IDs in the format required for Log IDs. ">Log_TimeStamp</a> object. </td></tr>
    <tr><td class="paramname">formerror</td><td>a string that collects specific error information if there is any. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

</div>
</div>
<a id="a957bdd835342852a8ef5ad94723e34cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a957bdd835342852a8ef5ad94723e34cf">&#9670;&nbsp;</a></span>valid_Log_chunk_ID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_Log_chunk_ID </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>formerror</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> *&#160;</td>
          <td class="paramname"><em>id_timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a string can be used to form a valid <a class="el" href="classfz_1_1Log__chunk__ID.html">Log_chunk_ID</a>. </p>
<p>Checks string length, all digits in time stamp, and time stamp components within valid ranges. Note that years before 1999 are disqualified, since the Formalizer did not exist before then.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_str</td><td>a string of the format YYYYmmddHHMM. </td></tr>
    <tr><td class="paramname">formerror</td><td>a string that collects specific error information if there is any. </td></tr>
    <tr><td class="paramname">id_timestamp</td><td>if not NULL, receives valid components. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

</div>
</div>
<a id="a61ced31e8ffbaf54c00a9f586eaf1dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ced31e8ffbaf54c00a9f586eaf1dd4">&#9670;&nbsp;</a></span>valid_Log_entry_ID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_Log_entry_ID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> &amp;&#160;</td>
          <td class="paramname"><em>idT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>formerror</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a <a class="el" href="structfz_1_1Log__TimeStamp.html" title="Timestamp IDs in the format required for Log IDs. ">Log_TimeStamp</a> can be used as a valid <a class="el" href="classfz_1_1Log__entry__ID.html">Log_entry_ID</a>. </p>
<p>Note that years before 1999 are disqualified, since the Formalizer did not exist before then.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idT</td><td>reference to an <a class="el" href="structfz_1_1Log__TimeStamp.html" title="Timestamp IDs in the format required for Log IDs. ">Log_TimeStamp</a> object. </td></tr>
    <tr><td class="paramname">formerror</td><td>a string that collects specific error information if there is any. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

</div>
</div>
<a id="a8c0d31396e23ba90447163d6b714f1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c0d31396e23ba90447163d6b714f1d5">&#9670;&nbsp;</a></span>valid_Log_entry_ID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_Log_entry_ID </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>formerror</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> *&#160;</td>
          <td class="paramname"><em>id_timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a string can be used to form a valid <a class="el" href="classfz_1_1Log__entry__ID.html">Log_entry_ID</a>. </p>
<p>Checks string length, period separating time stamp from minor ID, all digits in time stamp and minor ID, and time stamp components within valid ranges. Note that years before 1999 are disqualified, since the Formalizer did not exist before then.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_str</td><td>a string of the format YYYYmmddHHMM.num. </td></tr>
    <tr><td class="paramname">formerror</td><td>a string that collects specific error information if there is any. </td></tr>
    <tr><td class="paramname">id_timestamp</td><td>if not NULL, receives valid components. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

</div>
</div>
<a id="aba0e4f3360d11eff1bf1b4553a451180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0e4f3360d11eff1bf1b4553a451180">&#9670;&nbsp;</a></span>valid_Node_ID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_Node_ID </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>formerror</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1ID__TimeStamp.html">ID_TimeStamp</a> *&#160;</td>
          <td class="paramname"><em>id_timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a string can be used to form a valid <a class="el" href="classfz_1_1Node__ID.html" title="Node ID that caches its ID stamp for frequent use. ">Node_ID</a>. </p>
<p>Checks string length, period separating time stamp from minor ID, all digits in time stamp and minor ID, and time stamp components within valid ranges. Note that years before 1999 are disqualified, since the Formalizer did not exist before then.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_str</td><td>a string of the format YYYYmmddHHMMSS.num. </td></tr>
    <tr><td class="paramname">formerror</td><td>a string that collects specific error information if there is any. </td></tr>
    <tr><td class="paramname">id_timestamp</td><td>if not NULL, receives valid components. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

</div>
</div>
<a id="a0c4260c6b3087bdf22ce089216638d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4260c6b3087bdf22ce089216638d79">&#9670;&nbsp;</a></span>valid_Node_ID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_Node_ID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1ID__TimeStamp.html">ID_TimeStamp</a> &amp;&#160;</td>
          <td class="paramname"><em>idT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>formerror</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a <a class="el" href="structfz_1_1ID__TimeStamp.html" title="Timestamp IDs in the format required for Node IDs. ">ID_TimeStamp</a> can be used as a valid <a class="el" href="classfz_1_1Node__ID.html" title="Node ID that caches its ID stamp for frequent use. ">Node_ID</a>. </p>
<p>Note that years before 1999 are disqualified, since the Formalizer did not exist before then.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idT</td><td>reference to an <a class="el" href="structfz_1_1ID__TimeStamp.html" title="Timestamp IDs in the format required for Node IDs. ">ID_TimeStamp</a> object. </td></tr>
    <tr><td class="paramname">formerror</td><td>a string that collects specific error information if there is any. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

</div>
</div>
<a id="af320a36d5d2f05de32419ea52f625e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af320a36d5d2f05de32419ea52f625e1e">&#9670;&nbsp;</a></span>valid_year_month_day()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_year_month_day </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a>&#160;</td>
          <td class="paramname"><em>ymd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a year, month and day form a valid date. </p>
<p>The rules are: 1800 &lt;= year &lt;= 9999 1 &lt;= month &lt;= 12 1 &lt;= day &lt;= max_days_in(month)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ymd</td><td>a tuple of year, month, day numbers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the date is valid. </dd></dl>

</div>
</div>
<a id="a053fc7625765a11b31ee3604a1f225b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053fc7625765a11b31ee3604a1f225b0">&#9670;&nbsp;</a></span>years_months_days()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a> fz::years_months_days </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a>&#160;</td>
          <td class="paramname"><em>ymd1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a>&#160;</td>
          <td class="paramname"><em>ymd2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Express the difference between two dates in terms of the number of Years, Months and Days between them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ymd1</td><td>an earlier year, month, day tuple. </td></tr>
    <tr><td class="paramname">ymd2</td><td>a later year, month, day tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple with the number of years, months and days between them. </dd></dl>

</div>
</div>
<a id="acd0003e81e0cb15861b2dfa5fa1469e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0003e81e0cb15861b2dfa5fa1469e2">&#9670;&nbsp;</a></span>ymd_stamp_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::time_t fz::ymd_stamp_time </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>timestr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noerror</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreHM</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UNIX epoch time equivalent of a Year-Month-Day date-stamp such as 20200914 or 202009140100. </p>
<p>This function uses <code><a class="el" href="namespacefz.html#a50b50bdd16d9e99e3ff4bf398f3fe68f" title="Convert a Formalizer time stamp string into local Unix time. ">time_stamp_time()</a></code> for time stamp format validation and conversion, but it allows pure date stamps consisting of just 8 year, month and day digits, as well as 12 digit time stamps. In the 12 digit case, the last 4 digits can be optionally ignored (set to 0000) during conversion to UNIX epoch time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestr</td><td>a string containing the Formalizer time stamp or date stamp. </td></tr>
    <tr><td class="paramname">noerror</td><td>suppresses ADDERROR() for invalid time stamps. </td></tr>
    <tr><td class="paramname">ignoreHM</td><td>optionally set any hour and minute digits to 0 during conversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>local Unix time in seconds, negative integer code, or RTt_invalid_time_stamp. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aeab0d860bf18ea1cc2acb7577f4f294f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab0d860bf18ea1cc2acb7577f4f294f">&#9670;&nbsp;</a></span>maintime</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfz_1_1ReferenceTime.html">ReferenceTime</a> fz::maintime</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Every program that uses core Formalizer functions that depend on time stamping includes <a class="el" href="ReferenceTime_8hpp_source.html">ReferenceTime.hpp</a> (it is automatically included through <a class="el" href="TimeStamp_8hpp.html" title="This header file declares Formalizer TimeStamp format and operations. ">TimeStamp.hpp</a>). </p>
<p>The <code>maintime</code> object that is defined here provides time status for the main scope of the program. Additioan <a class="el" href="classfz_1_1ReferenceTime.html">ReferenceTime</a> objects can be created as needed. </p>

</div>
</div>
<a id="a891acb04fd8751af330b359683bf1f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891acb04fd8751af330b359683bf1f32">&#9670;&nbsp;</a></span>pq_chunk_fieldnames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::pq_chunk_fieldnames[_pqlc_NUM]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&quot;id&quot;</span>,</div><div class="line">                                                   <span class="stringliteral">&quot;nid&quot;</span>,</div><div class="line">                                                   <span class="stringliteral">&quot;tclose&quot;</span>}</div></div><!-- fragment -->
</div>
</div>
<a id="a593c105236196b2da156f585c6d7ae30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593c105236196b2da156f585c6d7ae30">&#9670;&nbsp;</a></span>pq_edge_fieldnames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::pq_edge_fieldnames[_pqe_NUM]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&quot;id&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;dependency&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;significance&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;importance&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;urgency&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;priority&quot;</span>}</div></div><!-- fragment -->
</div>
</div>
<a id="a75e1faf355d3b06d2b95e06e207f1cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e1faf355d3b06d2b95e06e207f1cb7">&#9670;&nbsp;</a></span>pq_entry_fieldnames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::pq_entry_fieldnames[_pqle_NUM]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&quot;id&quot;</span>,</div><div class="line">                                                   <span class="stringliteral">&quot;nid&quot;</span>,</div><div class="line">                                                   <span class="stringliteral">&quot;text&quot;</span>}</div></div><!-- fragment -->
</div>
</div>
<a id="a4e2e72b75f6a44514c6175b6dd58988c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2e72b75f6a44514c6175b6dd58988c">&#9670;&nbsp;</a></span>pq_node_fieldnames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::pq_node_fieldnames[_pqn_NUM]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&quot;id&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;topics&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;topicrelevance&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;valuation&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;completion&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;required&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;text&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;targetdate&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;tdproperty&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;isperiodic&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;tdperiodic&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;tdevery&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;tdspan&quot;</span>}</div></div><!-- fragment -->
</div>
</div>
<a id="a0e9f249ab6da4a5330fbf47805b36b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9f249ab6da4a5330fbf47805b36b49">&#9670;&nbsp;</a></span>pq_topic_fieldnames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::pq_topic_fieldnames[_pqt_NUM]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&quot;id&quot;</span>,</div><div class="line">                                                   <span class="stringliteral">&quot;supid&quot;</span>,</div><div class="line">                                                   <span class="stringliteral">&quot;tag&quot;</span>,</div><div class="line">                                                   <span class="stringliteral">&quot;title&quot;</span>,</div><div class="line">                                                   <span class="stringliteral">&quot;keyword&quot;</span>,</div><div class="line">                                                   <span class="stringliteral">&quot;relevance&quot;</span>}</div></div><!-- fragment -->
</div>
</div>
<a id="a812e6aee98e3ba6635c8fc4bed8ad57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812e6aee98e3ba6635c8fc4bed8ad57c">&#9670;&nbsp;</a></span>standard</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfz_1_1the__standard__object.html">the_standard_object</a> fz::standard</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This object projects one unique and clear interface with settings for standardized Formalizer programs, including exit hooks and other important requirements. </p>
<p>The standard object for Formalizer programs. </p>

</div>
</div>
<a id="a64dd91504fdcea08cc7617a5314ec6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64dd91504fdcea08cc7617a5314ec6d2">&#9670;&nbsp;</a></span>td_pattern_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::td_pattern_str</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=  {<span class="stringliteral">&quot;patt_daily&quot;</span>,</div><div class="line">                                                <span class="stringliteral">&quot;patt_workdays&quot;</span>,</div><div class="line">                                                <span class="stringliteral">&quot;patt_weekly&quot;</span>,</div><div class="line">                                                <span class="stringliteral">&quot;patt_biweekly&quot;</span>,</div><div class="line">                                                <span class="stringliteral">&quot;patt_monthly&quot;</span>,</div><div class="line">                                                <span class="stringliteral">&quot;patt_endofmonthoffset&quot;</span>,</div><div class="line">                                                <span class="stringliteral">&quot;patt_yearly&quot;</span>,</div><div class="line">                                                <span class="stringliteral">&quot;OLD_patt_span&quot;</span>,</div><div class="line">                                                <span class="stringliteral">&quot;patt_nonperiodic&quot;</span>}</div></div><!-- fragment -->
</div>
</div>
<a id="a5946fa5b803240f1c0cd734f214c8c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5946fa5b803240f1c0cd734f214c8c15">&#9670;&nbsp;</a></span>td_property_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::td_property_str</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&quot;unspecified&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;inherit&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;variable&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;fixed&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;exact&quot;</span>}</div></div><!-- fragment -->
</div>
</div>
<a id="ab47d47929bea0b332de69408d4880092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47d47929bea0b332de69408d4880092">&#9670;&nbsp;</a></span>tdpatt_by_pqtdpatt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, td_pattern&gt; fz::tdpatt_by_pqtdpatt</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {{<span class="stringliteral">&quot;patt_daily&quot;</span>,td_pattern::patt_daily},</div><div class="line">                                                              {<span class="stringliteral">&quot;patt_workdays&quot;</span>,td_pattern::patt_workdays},</div><div class="line">                                                              {<span class="stringliteral">&quot;patt_weekly&quot;</span>,td_pattern::patt_weekly},</div><div class="line">                                                              {<span class="stringliteral">&quot;patt_biweekly&quot;</span>,td_pattern::patt_biweekly},</div><div class="line">                                                              {<span class="stringliteral">&quot;patt_monthly&quot;</span>,td_pattern::patt_monthly},</div><div class="line">                                                              {<span class="stringliteral">&quot;patt_endofmonthoffset&quot;</span>,td_pattern::patt_endofmonthoffset},</div><div class="line">                                                              {<span class="stringliteral">&quot;patt_yearly&quot;</span>,td_pattern::patt_yearly},</div><div class="line">                                                              {<span class="stringliteral">&quot;OLD_patt_span&quot;</span>,td_pattern::OLD_patt_span},</div><div class="line">                                                              {<span class="stringliteral">&quot;patt_nonperiodic&quot;</span>,td_pattern::patt_nonperiodic}}</div></div><!-- fragment -->
</div>
</div>
<a id="acd3867ed7aa9968c6dc3743c08621727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3867ed7aa9968c6dc3743c08621727">&#9670;&nbsp;</a></span>tdprop_by_pqtdprop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, <a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">td_property</a>&gt; fz::tdprop_by_pqtdprop</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {{<span class="stringliteral">&quot;unspecified&quot;</span>, td_property::unspecified},</div><div class="line">                                                               {<span class="stringliteral">&quot;inherit&quot;</span>, td_property::inherit},</div><div class="line">                                                               {<span class="stringliteral">&quot;variable&quot;</span>, td_property::variable},</div><div class="line">                                                               {<span class="stringliteral">&quot;fixed&quot;</span>, td_property::fixed},</div><div class="line">                                                               {<span class="stringliteral">&quot;exact&quot;</span>, td_property::exact}}</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
