<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Formalizer: fz Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="formalizer-logo-20200907-41x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Formalizer
   &#160;<span id="projectnumber">2.0.0-0.1</span>
   </div>
   <div id="projectbrief">The Formalizer System Support Environment</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">fz Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>fzserverpq is the Postgres-compatible version of the C++ implementation of teh Formalizer data server.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Edge.html">Edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Edge__ID.html">Edge_ID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfz_1_1Edge.html">Edge</a> ID that caches its ID stamp for frequent use.  <a href="classfz_1_1Edge__ID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Edge__ID__key.html">Edge_ID_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standardized Formalizer <a class="el" href="classfz_1_1Edge.html">Edge</a> ID key.  <a href="structfz_1_1Edge__ID__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Edge__pq.html">Edge_pq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data types conversion helper class that can deliver the Postgres <a class="el" href="classfz_1_1Edge.html">Edge</a> table equivalent INSERT value expression for all data content in an <a class="el" href="classfz_1_1Edge.html">Edge</a>.  <a href="classfz_1_1Edge__pq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Error__Instance.html">Error_Instance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Errors.html">Errors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintain a queue of recent errors encountered in ErrQ and provide them on demand.  <a href="classfz_1_1Errors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1formalizer__base__streams.html">formalizer_base_streams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1formalizer__standard__program.html">formalizer_standard_program</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure registers a <code>standard</code> object with a set of expected parameters and functions for any standardized Formalizer program.  <a href="structfz_1_1formalizer__standard__program.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Graph.html">Graph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Graph__access.html">Graph_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A standardized way to access the <a class="el" href="classfz_1_1Graph.html">Graph</a> database.  <a href="structfz_1_1Graph__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Guide__snippet.html">Guide_snippet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic data structure for Guide snippets.  <a href="structfz_1_1Guide__snippet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1ID__exception.html">ID_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declared here for reference before further detailing.  <a href="classfz_1_1ID__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1ID__TimeStamp.html">ID_TimeStamp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timestamp IDs in the format required for <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> IDs.  <a href="structfz_1_1ID__TimeStamp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html">Log</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><h3><a class="el" href="classfz_1_1Log.html" title="Log">Log</a></h3>
 <a href="classfz_1_1Log.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__Breakpoints.html">Log_Breakpoints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><h3><a class="el" href="classfz_1_1Log.html" title="Log">Log</a> Breakpoints (section starts)</h3>
 <a href="classfz_1_1Log__Breakpoints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__by__Node__chainable.html">Log_by_Node_chainable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> components that are chainable as belonging to a <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a>.  <a href="classfz_1_1Log__by__Node__chainable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This data structure is used to follow a chain by-Node through the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> that can lead to <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks or <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries.  <a href="structfz_1_1Log__chain__target.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the start time, <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a>, close time, and set of entries of a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk.  <a href="classfz_1_1Log__chunk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__chunk__ID.html">Log_chunk_ID</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standardized Formalizer <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk ID key.  <a href="structfz_1_1Log__chunk__ID__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Log__chunks__Deque.html">Log_chunks_Deque</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><h3><a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks (deque list)</h3>
 <a href="structfz_1_1Log__chunks__Deque.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__data.html">Log_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfz_1_1Log.html" title="Log">Log</a> data base class providing shared parameters and functions.  <a href="classfz_1_1Log__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__entry.html">Log_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__entry__ID.html">Log_entry_ID</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standardized Formalizer <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry ID key.  <a href="structfz_1_1Log__entry__ID__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Log__target.html">Log_target</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfz_1_1Log.html" title="Log">Log</a> objects are principally identified by their ID key, but when used as a linked target, e.g.  <a href="structfz_1_1Log__target.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timestamp IDs in the format required for <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> IDs.  <a href="structfz_1_1Log__TimeStamp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(A woefully incomplete class documentation.)  <a href="classfz_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Node__ID.html">Node_ID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> ID that caches its ID stamp for frequent use.  <a href="classfz_1_1Node__ID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standardized Formalizer <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> ID key.  <a href="structfz_1_1Node__ID__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Node__pq.html">Node_pq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data types conversion helper class that can deliver the Postgres <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> table equivalent INSERT value expression for all data content in a <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a>.  <a href="classfz_1_1Node__pq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Node__Targets__cursor.html">Node_Targets_cursor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used by <code>Log::setup_Chunk_nodeprevnext()</code> to build a proper chain.  <a href="structfz_1_1Node__Targets__cursor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A standardized way to access the Formalizer database.  <a href="structfz_1_1Postgres__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1ReferenceTime.html">ReferenceTime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1render__environment.html">render_environment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration for a template rendering environment.  <a href="structfz_1_1render__environment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1render__varpos.html">render_varpos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Simulate__PQ__Changes.html">Simulate_PQ_Changes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simulation class that enables Postgres call testing.  <a href="classfz_1_1Simulate__PQ__Changes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1template__variable__values.html">template_variable_values</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1template__varvalues.html">template_varvalues</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Topic.html">Topic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for real-valued <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> relevance (of <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a>), presently assumed to be in the interval [0.0,1.0].  <a href="classfz_1_1Topic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Topic__Keyword.html">Topic_Keyword</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for real-valued Keyword relevance (to <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a>), presently assumed to be in the interval [0.0,1.0].  <a href="structfz_1_1Topic__Keyword.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Topic__pq.html">Topic_pq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data types conversion helper class that can deliver the Postgres Topics table equivalent INSERT value expression for all data content in a <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a>.  <a href="classfz_1_1Topic__pq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Topic__Tags.html">Topic_Tags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> tag data, indexed by <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> ID.  <a href="classfz_1_1Topic__Tags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a90159dddcbd84757ff883b64042ea46a"><td class="memItemLeft" align="right" valign="top"><a id="a90159dddcbd84757ff883b64042ea46a"></a>
typedef float&#160;</td><td class="memItemRight" valign="bottom"><b>Keyword_Relevance</b></td></tr>
<tr class="separator:a90159dddcbd84757ff883b64042ea46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afddacf07ad964643983aa625bd00aba8"><td class="memItemLeft" align="right" valign="top"><a id="afddacf07ad964643983aa625bd00aba8"></a>
typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>Topic_ID</b></td></tr>
<tr class="separator:afddacf07ad964643983aa625bd00aba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef696382cc8a859adcdb76740012048"><td class="memItemLeft" align="right" valign="top"><a id="a4ef696382cc8a859adcdb76740012048"></a>
typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a4ef696382cc8a859adcdb76740012048">Topic_Relevance</a></td></tr>
<tr class="memdesc:a4ef696382cc8a859adcdb76740012048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for unique <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> IDs. <br /></td></tr>
<tr class="separator:a4ef696382cc8a859adcdb76740012048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ec4277595878f1f77ac6a29bdf24a8"><td class="memItemLeft" align="right" valign="top"><a id="a71ec4277595878f1f77ac6a29bdf24a8"></a>
typedef std::vector&lt; <a class="el" href="classfz_1_1Topic.html">Topic</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Topic_Tags_Vector</b></td></tr>
<tr class="separator:a71ec4277595878f1f77ac6a29bdf24a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9db5b90dfbfb5dc9a5e41a142f667f"><td class="memItemLeft" align="right" valign="top"><a id="afd9db5b90dfbfb5dc9a5e41a142f667f"></a>
typedef std::map&lt; Topic_ID, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Topics_Set</b></td></tr>
<tr class="separator:afd9db5b90dfbfb5dc9a5e41a142f667f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cb31bb2e4314340751a857568610fe"><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; <a class="el" href="classfz_1_1Edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a22cb31bb2e4314340751a857568610fe">Edges_Set</a></td></tr>
<tr class="memdesc:a22cb31bb2e4314340751a857568610fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">targetdate: For details, see the description at <a href="https://docs.google.com/document/d/1rYPFgzFgjkF1xGx3uABiXiaDR5sfmOzqYQRqSntcyyY/edit#heading=h.nu3mb52d1k6n">https://docs.google.com/document/d/1rYPFgzFgjkF1xGx3uABiXiaDR5sfmOzqYQRqSntcyyY/edit#heading=h.nu3mb52d1k6n</a>.  <a href="#a22cb31bb2e4314340751a857568610fe">More...</a><br /></td></tr>
<tr class="separator:a22cb31bb2e4314340751a857568610fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f704d7393e5b2d14f9095f8210ce4a"><td class="memItemLeft" align="right" valign="top"><a id="a41f704d7393e5b2d14f9095f8210ce4a"></a>
typedef std::map&lt; <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a>, <a class="el" href="classfz_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Node_Map</b></td></tr>
<tr class="separator:a41f704d7393e5b2d14f9095f8210ce4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722a9e6a79f45a3980877988f9984b63"><td class="memItemLeft" align="right" valign="top"><a id="a722a9e6a79f45a3980877988f9984b63"></a>
typedef std::map&lt; <a class="el" href="structfz_1_1Edge__ID__key.html">Edge_ID_key</a>, <a class="el" href="classfz_1_1Edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Edge_Map</b></td></tr>
<tr class="separator:a722a9e6a79f45a3980877988f9984b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c125ce4a1d727d1fa039f07d6e6b15"><td class="memItemLeft" align="right" valign="top"><a id="af5c125ce4a1d727d1fa039f07d6e6b15"></a>
typedef std::vector&lt; <a class="el" href="classfz_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Node_Index</b></td></tr>
<tr class="separator:af5c125ce4a1d727d1fa039f07d6e6b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005101cd3360f7440301c8c033b397f8"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; const <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a>, std::unique_ptr&lt; <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a005101cd3360f7440301c8c033b397f8">Log_entries_Map</a></td></tr>
<tr class="memdesc:a005101cd3360f7440301c8c033b397f8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><h3><a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries (map)</h3>
 <a href="#a005101cd3360f7440301c8c033b397f8">More...</a><br /></td></tr>
<tr class="separator:a005101cd3360f7440301c8c033b397f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33950887af9a1dfe223b82b40edc2b1f"><td class="memItemLeft" align="right" valign="top"><a id="a33950887af9a1dfe223b82b40edc2b1f"></a>
typedef std::pair&lt; Log_entries_Map::iterator, Log_entries_Map::iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a33950887af9a1dfe223b82b40edc2b1f">Log_entry_iterator_interval</a></td></tr>
<tr class="memdesc:a33950887af9a1dfe223b82b40edc2b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interval type for the Log_entries_Map;. <br /></td></tr>
<tr class="separator:a33950887af9a1dfe223b82b40edc2b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac6ef6feef733ab3e80d6b13d788618"><td class="memItemLeft" align="right" valign="top"><a id="a5ac6ef6feef733ab3e80d6b13d788618"></a>
typedef std::deque&lt; std::unique_ptr&lt; <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a5ac6ef6feef733ab3e80d6b13d788618">Log_chunk_ptr_deque</a></td></tr>
<tr class="memdesc:a5ac6ef6feef733ab3e80d6b13d788618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for this container type. <br /></td></tr>
<tr class="separator:a5ac6ef6feef733ab3e80d6b13d788618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54d7dcc5daf1d7c28a31a9ea2f2064a"><td class="memItemLeft" align="right" valign="top"><a id="ac54d7dcc5daf1d7c28a31a9ea2f2064a"></a>
typedef std::pair&lt; Log_chunk_ptr_deque::size_type, Log_chunk_ptr_deque::size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ac54d7dcc5daf1d7c28a31a9ea2f2064a">Log_chunk_index_interval</a></td></tr>
<tr class="memdesc:ac54d7dcc5daf1d7c28a31a9ea2f2064a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interval types for the <a class="el" href="structfz_1_1Log__chunks__Deque.html" title="Log chunks (deque list)">Log_chunks_Deque</a>. <br /></td></tr>
<tr class="separator:ac54d7dcc5daf1d7c28a31a9ea2f2064a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c3dec7a01d6cd67e148cbe8068787a"><td class="memItemLeft" align="right" valign="top"><a id="a75c3dec7a01d6cd67e148cbe8068787a"></a>
typedef std::pair&lt; <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a>, <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_chunk_ID_interval</b></td></tr>
<tr class="separator:a75c3dec7a01d6cd67e148cbe8068787a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19097fed21f7b5e73117677bb009ba08"><td class="memItemLeft" align="right" valign="top"><a id="a19097fed21f7b5e73117677bb009ba08"></a>
typedef std::deque&lt; <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a19097fed21f7b5e73117677bb009ba08">Log_chunk_ID_key_deque</a></td></tr>
<tr class="memdesc:a19097fed21f7b5e73117677bb009ba08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for this container type. <br /></td></tr>
<tr class="separator:a19097fed21f7b5e73117677bb009ba08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fa686034d8685dd4cd88b74e9e5132"><td class="memItemLeft" align="right" valign="top"><a id="a03fa686034d8685dd4cd88b74e9e5132"></a>
typedef <a class="el" href="structfz_1_1Log__target.html">Log_target</a>&lt; <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a>, <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_chunk_target</b></td></tr>
<tr class="separator:a03fa686034d8685dd4cd88b74e9e5132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b4d76cf439608a0de4a4d1282c742f"><td class="memItemLeft" align="right" valign="top"><a id="ae0b4d76cf439608a0de4a4d1282c742f"></a>
typedef <a class="el" href="structfz_1_1Log__target.html">Log_target</a>&lt; <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a>, <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_entry_target</b></td></tr>
<tr class="separator:ae0b4d76cf439608a0de4a4d1282c742f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7628e7ec4a0b6dd62dd1b38614ae2944"><td class="memItemLeft" align="right" valign="top"><a id="a7628e7ec4a0b6dd62dd1b38614ae2944"></a>
typedef std::pair&lt; bool, <a class="el" href="classfz_1_1Log__data.html">Log_data</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_ptr_pair</b></td></tr>
<tr class="separator:a7628e7ec4a0b6dd62dd1b38614ae2944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fad9a0772bcfce865af13b7a659a4c6"><td class="memItemLeft" align="right" valign="top"><a id="a4fad9a0772bcfce865af13b7a659a4c6"></a>
typedef std::tuple&lt; bool, <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a>, <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_key_tuple</b></td></tr>
<tr class="separator:a4fad9a0772bcfce865af13b7a659a4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa45880b9bbad1bcf026d98b71df765"><td class="memItemLeft" align="right" valign="top"><a id="affa45880b9bbad1bcf026d98b71df765"></a>
typedef std::tuple&lt; bool, <a class="el" href="structfz_1_1Log__target.html">Log_chunk_target</a>, <a class="el" href="structfz_1_1Log__target.html">Log_entry_target</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_target_tuple</b></td></tr>
<tr class="separator:affa45880b9bbad1bcf026d98b71df765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac707a16b6f3ce32e16ceeb269cb05967"><td class="memItemLeft" align="right" valign="top"><a id="ac707a16b6f3ce32e16ceeb269cb05967"></a>
typedef std::vector&lt; <a class="el" href="structfz_1_1render__varpos.html">render_varpos</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>template_varpos</b></td></tr>
<tr class="separator:ac707a16b6f3ce32e16ceeb269cb05967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6816aa2a6ca096b5918902e6e261cc68"><td class="memItemLeft" align="right" valign="top"><a id="a6816aa2a6ca096b5918902e6e261cc68"></a>
typedef std::tuple&lt; unsigned int, unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ymd_tuple</b></td></tr>
<tr class="separator:a6816aa2a6ca096b5918902e6e261cc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab6fa1d38b1f961757e7f352be3764d8f"><td class="memItemLeft" align="right" valign="top"><a id="ab6fa1d38b1f961757e7f352be3764d8f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>pq_Tfields</b> { <br />
&#160;&#160;<b>pqt_id</b>, 
<b>pqt_supid</b>, 
<b>pqt_tag</b>, 
<b>pqt_title</b>, 
<br />
&#160;&#160;<b>pqt_keyword</b>, 
<b>pqt_relevance</b>, 
<b>_pqt_NUM</b>
<br />
 }</td></tr>
<tr class="separator:ab6fa1d38b1f961757e7f352be3764d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7349c0b699f57fccff3f53513df94839"><td class="memItemLeft" align="right" valign="top"><a id="a7349c0b699f57fccff3f53513df94839"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>pq_Nfields</b> { <br />
&#160;&#160;<b>pqn_id</b>, 
<b>pqn_topics</b>, 
<b>pqn_topicrelevance</b>, 
<b>pqn_valuation</b>, 
<br />
&#160;&#160;<b>pqn_completion</b>, 
<b>pqn_required</b>, 
<b>pqn_text</b>, 
<b>pqn_targetdate</b>, 
<br />
&#160;&#160;<b>pqn_tdproperty</b>, 
<b>pqn_isperiodic</b>, 
<b>pqn_tdperiodic</b>, 
<b>pqn_tdevery</b>, 
<br />
&#160;&#160;<b>pqn_tdspan</b>, 
<b>_pqn_NUM</b>
<br />
 }</td></tr>
<tr class="separator:a7349c0b699f57fccff3f53513df94839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbebf38d141f22704b7eedd52437b28"><td class="memItemLeft" align="right" valign="top"><a id="a2fbebf38d141f22704b7eedd52437b28"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>pq_Efields</b> { <br />
&#160;&#160;<b>pqe_id</b>, 
<b>pqe_dependency</b>, 
<b>pqe_significance</b>, 
<b>pqe_importance</b>, 
<br />
&#160;&#160;<b>pqe_urgency</b>, 
<b>pqe_priority</b>, 
<b>_pqe_NUM</b>
<br />
 }</td></tr>
<tr class="separator:a2fbebf38d141f22704b7eedd52437b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c45e5e183774ed3322e5c3d445b3f70"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">td_property</a> { <br />
&#160;&#160;<b>unspecified</b>, 
<b>inherit</b>, 
<b>variable</b>, 
<b>fixed</b>, 
<br />
&#160;&#160;<b>exact</b>, 
<b>_tdprop_num</b>
<br />
 }<tr class="memdesc:a6c45e5e183774ed3322e5c3d445b3f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">For more information about td_property values, as well as future expansions, please see the Formalizer documentation section <a href="https://docs.google.com/document/d/1rYPFgzFgjkF1xGx3uABiXiaDR5sfmOzqYQRqSntcyyY/edit#heading=h.nu3mb52d1k6n">Target date parameters in Graph v2.0+</a>.  <a href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6c45e5e183774ed3322e5c3d445b3f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457fe66ad9a864a8062ed33117e53841"><td class="memItemLeft" align="right" valign="top"><a id="a457fe66ad9a864a8062ed33117e53841"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>td_pattern</b> { <br />
&#160;&#160;<b>patt_daily</b>, 
<b>patt_workdays</b>, 
<b>patt_weekly</b>, 
<b>patt_biweekly</b>, 
<br />
&#160;&#160;<b>patt_monthly</b>, 
<b>patt_endofmonthoffset</b>, 
<b>patt_yearly</b>, 
<b>OLD_patt_span</b>, 
<br />
&#160;&#160;<b>patt_nonperiodic</b>, 
<b>_patt_num</b>
<br />
 }</td></tr>
<tr class="separator:a457fe66ad9a864a8062ed33117e53841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef05dd6bfa4d4a09d3eace4949b6fab0"><td class="memItemLeft" align="right" valign="top"><a id="aef05dd6bfa4d4a09d3eace4949b6fab0"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ReferenceTime_t</b> : std::time_t { <b>RTt_invalid_time_stamp</b> = -34403, 
<b>RTt_unspecified</b> = -1, 
<b>RTt_unix_epoch_start</b> = 0
 }</td></tr>
<tr class="separator:aef05dd6bfa4d4a09d3eace4949b6fab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a7b508456ccb1691f487ed136d52d4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a95a7b508456ccb1691f487ed136d52d4">exit_status_code</a> { <br />
&#160;&#160;<b>exit_ok</b>, 
<b>exit_general_error</b>, 
<b>exit_database_error</b>, 
<b>exit_unknown_option</b>, 
<br />
&#160;&#160;<b>exit_cancel</b>, 
<b>exit_conversion_error</b>, 
<b>exit_DIL_error</b>, 
<b>exit_unable_to_stack_clean_exit</b>, 
<br />
&#160;&#160;<b>exit_command_line_error</b>, 
<b>exit_file_error</b>, 
<a class="el" href="namespacefz.html#a95a7b508456ccb1691f487ed136d52d4a705b1561a859fa4dfba9b3e3045d9f24">exit_NUMENUMS</a>
<br />
 }<tr class="memdesc:a95a7b508456ccb1691f487ed136d52d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standardized exit codes for the Formalizer environment.  <a href="namespacefz.html#a95a7b508456ccb1691f487ed136d52d4">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a95a7b508456ccb1691f487ed136d52d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbc7396c54a5297ce62bfad68c98cb2"><td class="memItemLeft" align="right" valign="top"><a id="a2cbc7396c54a5297ce62bfad68c98cb2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>render_error_t</b> { <br />
&#160;&#160;<b>rerr_ok</b> = 0, 
<b>rerr_missing_value</b> = 1, 
<b>rerr_empty_template</b> = 2, 
<b>rerr_no_variable_values</b> = 3, 
<br />
&#160;&#160;<b>rerr_empty_variable_label</b> = 4, 
<b>rerr_unused_variable_value</b> = 5
<br />
 }</td></tr>
<tr class="separator:a2cbc7396c54a5297ce62bfad68c98cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a20fc3f13405d901ac7ecbf65ae2ae712"><td class="memItemLeft" align="right" valign="top"><a id="a20fc3f13405d901ac7ecbf65ae2ae712"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>coreversion</b> ()</td></tr>
<tr class="separator:a20fc3f13405d901ac7ecbf65ae2ae712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7838e7b982bd5a885f69f42a8fa929c"><td class="memItemLeft" align="right" valign="top">Detailed_Items_List *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aa7838e7b982bd5a885f69f42a8fa929c">get_DIL_Graph</a> ()</td></tr>
<tr class="memdesc:aa7838e7b982bd5a885f69f42a8fa929c"><td class="mdescLeft">&#160;</td><td class="mdescRight">To USE and COMPILE :  <a href="#aa7838e7b982bd5a885f69f42a8fa929c">More...</a><br /></td></tr>
<tr class="separator:aa7838e7b982bd5a885f69f42a8fa929c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004bd737f1c412b124eaf7ca6df90603"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a004bd737f1c412b124eaf7ca6df90603">get_DIL_Topics_File_List</a> ()</td></tr>
<tr class="memdesc:a004bd737f1c412b124eaf7ca6df90603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the actual set of Topical DIL Files that exist in the dil2al base directory.  <a href="#a004bd737f1c412b124eaf7ca6df90603">More...</a><br /></td></tr>
<tr class="separator:a004bd737f1c412b124eaf7ca6df90603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e9d57226726175af8c8e276edd0c58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ac5e9d57226726175af8c8e276edd0c58">get_DIL_entry_num_superiors</a> (DIL_entry *e)</td></tr>
<tr class="memdesc:ac5e9d57226726175af8c8e276edd0c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of connections from a DIL entry to Superiors.  <a href="#ac5e9d57226726175af8c8e276edd0c58">More...</a><br /></td></tr>
<tr class="separator:ac5e9d57226726175af8c8e276edd0c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02517c2cf1052f55bb388a0808fdaa1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a02517c2cf1052f55bb388a0808fdaa1b">get_DIL_hierarchy_num_connections</a> (Detailed_Items_List *dil)</td></tr>
<tr class="memdesc:a02517c2cf1052f55bb388a0808fdaa1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of connections in a DIL hierarchy.  <a href="#a02517c2cf1052f55bb388a0808fdaa1b">More...</a><br /></td></tr>
<tr class="separator:a02517c2cf1052f55bb388a0808fdaa1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd066a32696261830f98ca59ce4a7f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a3cd066a32696261830f98ca59ce4a7f0">Clean_Exit</a> (int ecode)</td></tr>
<tr class="memdesc:a3cd066a32696261830f98ca59ce4a7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after yourself before you exit.  <a href="#a3cd066a32696261830f98ca59ce4a7f0">More...</a><br /></td></tr>
<tr class="separator:a3cd066a32696261830f98ca59ce4a7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bde9da1de78d7bc0492b22eba9630e8"><td class="memItemLeft" align="right" valign="top">PGconn *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a9bde9da1de78d7bc0492b22eba9630e8">connection_setup_pq</a> (std::string <a class="el" href="namespacefz.html#ad4fdce135d088325b93bd26431b1f1c2">dbname</a>)</td></tr>
<tr class="memdesc:a9bde9da1de78d7bc0492b22eba9630e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up a connection with an existing Postgres database.  <a href="#a9bde9da1de78d7bc0492b22eba9630e8">More...</a><br /></td></tr>
<tr class="separator:a9bde9da1de78d7bc0492b22eba9630e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a653de26479eb7d85b850ec2918c2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aa1a653de26479eb7d85b850ec2918c2a">simple_call_pq</a> (PGconn *conn, std::string astr)</td></tr>
<tr class="memdesc:aa1a653de26479eb7d85b850ec2918c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a simple action call to a Postgres database.  <a href="#aa1a653de26479eb7d85b850ec2918c2a">More...</a><br /></td></tr>
<tr class="separator:aa1a653de26479eb7d85b850ec2918c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d24b6e4b1323e5d5687d184aa48fb4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a7d24b6e4b1323e5d5687d184aa48fb4a">query_call_pq</a> (PGconn *conn, std::string qstr, bool request_single_row_mode)</td></tr>
<tr class="memdesc:a7d24b6e4b1323e5d5687d184aa48fb4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch a Postgres query for asynchronous processing in batch or single row mode.  <a href="#a7d24b6e4b1323e5d5687d184aa48fb4a">More...</a><br /></td></tr>
<tr class="separator:a7d24b6e4b1323e5d5687d184aa48fb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b42530ac38402a5656af5bdcac5be6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a59b42530ac38402a5656af5bdcac5be6">sample_query_data</a> (PGconn *conn, unsigned int rstart, unsigned int rend, unsigned int cstart, unsigned int cend, std::string &amp;databufstr)</td></tr>
<tr class="memdesc:a59b42530ac38402a5656af5bdcac5be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that dumps several rows of data to a string buffer for easy inspection.  <a href="#a59b42530ac38402a5656af5bdcac5be6">More...</a><br /></td></tr>
<tr class="separator:a59b42530ac38402a5656af5bdcac5be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44280392e614e1145d3c5a27aa640b59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a44280392e614e1145d3c5a27aa640b59">create_Formalizer_schema_pq</a> (PGconn *conn, std::string schemaname)</td></tr>
<tr class="memdesc:a44280392e614e1145d3c5a27aa640b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new database schema for Formalizer data.  <a href="#a44280392e614e1145d3c5a27aa640b59">More...</a><br /></td></tr>
<tr class="separator:a44280392e614e1145d3c5a27aa640b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26caa1b821a4715dbec90c174a95e97"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab26caa1b821a4715dbec90c174a95e97">array_from_pq</a> (std::string pq_array_str)</td></tr>
<tr class="memdesc:ab26caa1b821a4715dbec90c174a95e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a single string containing Postgres query output that represents an array into a vector of strings.  <a href="#ab26caa1b821a4715dbec90c174a95e97">More...</a><br /></td></tr>
<tr class="separator:ab26caa1b821a4715dbec90c174a95e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852bc7a9cba819521f01ce09cc041461"><td class="memItemLeft" align="right" valign="top"><a id="a852bc7a9cba819521f01ce09cc041461"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>TimeStamp_pq</b> (time_t t)</td></tr>
<tr class="separator:a852bc7a9cba819521f01ce09cc041461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fbfbcaecf4e5f56afa2956d83ba595"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a38fbfbcaecf4e5f56afa2956d83ba595">targetdate_from_timestamp_pq</a> (std::string pqtimestamp)</td></tr>
<tr class="memdesc:a38fbfbcaecf4e5f56afa2956d83ba595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Postgres query result time stamp strings to Unix time for <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> target date parameter.  <a href="#a38fbfbcaecf4e5f56afa2956d83ba595">More...</a><br /></td></tr>
<tr class="separator:a38fbfbcaecf4e5f56afa2956d83ba595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e121747c47e1ca49747225bf5496af"><td class="memItemLeft" align="right" valign="top"><a id="ae3e121747c47e1ca49747225bf5496af"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae3e121747c47e1ca49747225bf5496af">is_not_digit</a> (int c)</td></tr>
<tr class="memdesc:ae3e121747c47e1ca49747225bf5496af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invere of &lt;cctype&gt;:isdigit(). <br /></td></tr>
<tr class="separator:ae3e121747c47e1ca49747225bf5496af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23b82243a12ae2b0d35ccb70d785857"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aa23b82243a12ae2b0d35ccb70d785857">shellcmd2str</a> (std::string cmd)</td></tr>
<tr class="memdesc:aa23b82243a12ae2b0d35ccb70d785857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a shell command and retrieve the standard output as a string.  <a href="#aa23b82243a12ae2b0d35ccb70d785857">More...</a><br /></td></tr>
<tr class="separator:aa23b82243a12ae2b0d35ccb70d785857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53786005231752fd441f9114609caec7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a53786005231752fd441f9114609caec7">to_precision_string</a> (double d, unsigned int p)</td></tr>
<tr class="memdesc:a53786005231752fd441f9114609caec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print double to string with specific precision.  <a href="#a53786005231752fd441f9114609caec7">More...</a><br /></td></tr>
<tr class="separator:a53786005231752fd441f9114609caec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a30fb04b5721cd05047bd4088fb8b0"><td class="memTemplParams" colspan="2">template&lt;typename Out &gt; </td></tr>
<tr class="memitem:a45a30fb04b5721cd05047bd4088fb8b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefz.html#a45a30fb04b5721cd05047bd4088fb8b0">split</a> (const std::string &amp;s, char delim, Out result)</td></tr>
<tr class="memdesc:a45a30fb04b5721cd05047bd4088fb8b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put pieces of a string into a pre-constructed vector.  <a href="#a45a30fb04b5721cd05047bd4088fb8b0">More...</a><br /></td></tr>
<tr class="separator:a45a30fb04b5721cd05047bd4088fb8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7dc083b5c0e84d7d715161e462a321f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab7dc083b5c0e84d7d715161e462a321f">split</a> (const std::string &amp;s, char delim)</td></tr>
<tr class="memdesc:ab7dc083b5c0e84d7d715161e462a321f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing pieces of a string.  <a href="#ab7dc083b5c0e84d7d715161e462a321f">More...</a><br /></td></tr>
<tr class="separator:ab7dc083b5c0e84d7d715161e462a321f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f17dcd15946bcb9a7fd70bf65e6fcc9"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a7f17dcd15946bcb9a7fd70bf65e6fcc9">ltrim</a> (std::string &amp;s, const char *t=&quot; \\\)</td></tr>
<tr class="memdesc:a7f17dcd15946bcb9a7fd70bf65e6fcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim whitespace from the front of a string.  <a href="#a7f17dcd15946bcb9a7fd70bf65e6fcc9">More...</a><br /></td></tr>
<tr class="separator:a7f17dcd15946bcb9a7fd70bf65e6fcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1cf55c9ed8689f087102061c60154a"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a8f1cf55c9ed8689f087102061c60154a">rtrim</a> (std::string &amp;s, const char *t=&quot; \\\)</td></tr>
<tr class="memdesc:a8f1cf55c9ed8689f087102061c60154a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim whitespace from the end of a string.  <a href="#a8f1cf55c9ed8689f087102061c60154a">More...</a><br /></td></tr>
<tr class="separator:a8f1cf55c9ed8689f087102061c60154a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff76817b33dcd0a0c38c28e238ad2d3"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#acff76817b33dcd0a0c38c28e238ad2d3">trim</a> (std::string &amp;s, const char *t=&quot; \\\)</td></tr>
<tr class="memdesc:acff76817b33dcd0a0c38c28e238ad2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim whitespace on both ends of a string.  <a href="#acff76817b33dcd0a0c38c28e238ad2d3">More...</a><br /></td></tr>
<tr class="separator:acff76817b33dcd0a0c38c28e238ad2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e5fa50448d4b9ffb38afea0ae0ea1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a11e5fa50448d4b9ffb38afea0ae0ea1a">string_to_file</a> (std::string path, std::string &amp;s, std::ofstream::iostate *writestate)</td></tr>
<tr class="memdesc:a11e5fa50448d4b9ffb38afea0ae0ea1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the full contents of a string to a file.  <a href="#a11e5fa50448d4b9ffb38afea0ae0ea1a">More...</a><br /></td></tr>
<tr class="separator:a11e5fa50448d4b9ffb38afea0ae0ea1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82121e1189c46fe028b6b6e9a073c8d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a82121e1189c46fe028b6b6e9a073c8d5">string_to_file_with_backup</a> (std::string path, std::string &amp;s, std::string backupext, bool &amp;backedup, std::ofstream::iostate *writestate)</td></tr>
<tr class="memdesc:a82121e1189c46fe028b6b6e9a073c8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the full contents of a string to a file, but move an existing file at the given path to a backup name first.  <a href="#a82121e1189c46fe028b6b6e9a073c8d5">More...</a><br /></td></tr>
<tr class="separator:a82121e1189c46fe028b6b6e9a073c8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac311316b5a762d53489ec1135d88479"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aac311316b5a762d53489ec1135d88479">file_to_string</a> (std::string path, std::string &amp;s, std::ifstream::iostate *readstate)</td></tr>
<tr class="memdesc:aac311316b5a762d53489ec1135d88479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the full contents of a (text) file into a string.  <a href="#aac311316b5a762d53489ec1135d88479">More...</a><br /></td></tr>
<tr class="separator:aac311316b5a762d53489ec1135d88479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4ae42399db02b1b71a5d5771f16139"><td class="memItemLeft" align="right" valign="top"><a id="a7e4ae42399db02b1b71a5d5771f16139"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>string_from_file</b> (std::string path, std::ifstream::iostate *readstate=nullptr)</td></tr>
<tr class="separator:a7e4ae42399db02b1b71a5d5771f16139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae354d176f2f483264ec225411f7eb122"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae354d176f2f483264ec225411f7eb122">stream_to_string</a> (std::istream &amp;in, std::string &amp;s)</td></tr>
<tr class="memdesc:ae354d176f2f483264ec225411f7eb122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the full contents of a (text) stream into a string.  <a href="#ae354d176f2f483264ec225411f7eb122">More...</a><br /></td></tr>
<tr class="separator:ae354d176f2f483264ec225411f7eb122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe69e72e6cc57d40e3738f2bb2d7b1bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#abe69e72e6cc57d40e3738f2bb2d7b1bc">create_Enum_Types_pq</a> (PGconn *conn, std::string schemaname)</td></tr>
<tr class="memdesc:abe69e72e6cc57d40e3738f2bb2d7b1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create enumerated types in database for <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> and <a class="el" href="classfz_1_1Edge.html">Edge</a> data.  <a href="#abe69e72e6cc57d40e3738f2bb2d7b1bc">More...</a><br /></td></tr>
<tr class="separator:abe69e72e6cc57d40e3738f2bb2d7b1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2359bd1e82e68f38bd9d900588887fde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a2359bd1e82e68f38bd9d900588887fde">create_Topics_table_pq</a> (PGconn *conn, std::string schemaname)</td></tr>
<tr class="memdesc:a2359bd1e82e68f38bd9d900588887fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new database table for Topics.  <a href="#a2359bd1e82e68f38bd9d900588887fde">More...</a><br /></td></tr>
<tr class="separator:a2359bd1e82e68f38bd9d900588887fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75375e8fb94d22f2facb4085afe93de9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a75375e8fb94d22f2facb4085afe93de9">create_Nodes_table_pq</a> (PGconn *conn, std::string schemaname)</td></tr>
<tr class="memdesc:a75375e8fb94d22f2facb4085afe93de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new database table for Nodes.  <a href="#a75375e8fb94d22f2facb4085afe93de9">More...</a><br /></td></tr>
<tr class="separator:a75375e8fb94d22f2facb4085afe93de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2da8c677f43a85e7f86d9074e468962"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ad2da8c677f43a85e7f86d9074e468962">create_Edges_table_pq</a> (PGconn *conn, std::string schemaname)</td></tr>
<tr class="memdesc:ad2da8c677f43a85e7f86d9074e468962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new database table for Edges.  <a href="#ad2da8c677f43a85e7f86d9074e468962">More...</a><br /></td></tr>
<tr class="separator:ad2da8c677f43a85e7f86d9074e468962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d3d52c28b498e4b986abd91d3797ee"><td class="memItemLeft" align="right" valign="top"><a id="a59d3d52c28b498e4b986abd91d3797ee"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>add_Topic_pq</b> (PGconn *conn, std::string schemaname, const <a class="el" href="classfz_1_1Topic.html">Topic</a> *topic)</td></tr>
<tr class="separator:a59d3d52c28b498e4b986abd91d3797ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5d35ee88b8f0e2ab786e64ded407c5"><td class="memItemLeft" align="right" valign="top"><a id="a0d5d35ee88b8f0e2ab786e64ded407c5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>add_Node_pq</b> (PGconn *conn, std::string schemaname, const <a class="el" href="classfz_1_1Node.html">Node</a> *node)</td></tr>
<tr class="separator:a0d5d35ee88b8f0e2ab786e64ded407c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad481d21955c0be457141a73c619a3fbf"><td class="memItemLeft" align="right" valign="top"><a id="ad481d21955c0be457141a73c619a3fbf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>add_Edge_pq</b> (PGconn *conn, std::string schemaname, const <a class="el" href="classfz_1_1Edge.html">Edge</a> *edge)</td></tr>
<tr class="separator:ad481d21955c0be457141a73c619a3fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb865200e35c530ff09a2a5c142c55a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a1cb865200e35c530ff09a2a5c142c55a">store_Graph_pq</a> (const <a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, std::string <a class="el" href="namespacefz.html#ad4fdce135d088325b93bd26431b1f1c2">dbname</a>, std::string schemaname, void(*progress_func)(unsigned long, unsigned long))</td></tr>
<tr class="memdesc:a1cb865200e35c530ff09a2a5c142c55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store all the Nodes and Edges of the <a class="el" href="classfz_1_1Graph.html">Graph</a> in the PostgreSQL database.  <a href="#a1cb865200e35c530ff09a2a5c142c55a">More...</a><br /></td></tr>
<tr class="separator:a1cb865200e35c530ff09a2a5c142c55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615c9833189de86268653cf1fc95f092"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a615c9833189de86268653cf1fc95f092">load_Graph_pq</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, std::string <a class="el" href="namespacefz.html#ad4fdce135d088325b93bd26431b1f1c2">dbname</a>, std::string schemaname)</td></tr>
<tr class="memdesc:a615c9833189de86268653cf1fc95f092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all the Nodes, Edges and Topics of the <a class="el" href="classfz_1_1Graph.html">Graph</a> from the PostgreSQL database.  <a href="#a615c9833189de86268653cf1fc95f092">More...</a><br /></td></tr>
<tr class="separator:a615c9833189de86268653cf1fc95f092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24f78e052197d9844de69ba284cfade"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ad24f78e052197d9844de69ba284cfade">load_Node_parameter_interval</a> (std::string <a class="el" href="namespacefz.html#ad4fdce135d088325b93bd26431b1f1c2">dbname</a>, std::string schemaname, pq_Nfields param, unsigned long from_row, unsigned long num_rows)</td></tr>
<tr class="memdesc:ad24f78e052197d9844de69ba284cfade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load specific <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> parameter column interval from PostgreSQL database.  <a href="#ad24f78e052197d9844de69ba284cfade">More...</a><br /></td></tr>
<tr class="separator:ad24f78e052197d9844de69ba284cfade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef824584d56abd3b06028a3925a9541c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aef824584d56abd3b06028a3925a9541c">load_Edge_parameter_interval</a> (std::string <a class="el" href="namespacefz.html#ad4fdce135d088325b93bd26431b1f1c2">dbname</a>, std::string schemaname, pq_Efields param, unsigned long from_row, unsigned long num_rows)</td></tr>
<tr class="memdesc:aef824584d56abd3b06028a3925a9541c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load specific <a class="el" href="classfz_1_1Edge.html">Edge</a> parameter column interval from PostgreSQL database.  <a href="#aef824584d56abd3b06028a3925a9541c">More...</a><br /></td></tr>
<tr class="separator:aef824584d56abd3b06028a3925a9541c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0e4f3360d11eff1bf1b4553a451180"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aba0e4f3360d11eff1bf1b4553a451180">valid_Node_ID</a> (std::string id_str, std::string &amp;formerror, <a class="el" href="structfz_1_1ID__TimeStamp.html">ID_TimeStamp</a> *id_timestamp)</td></tr>
<tr class="memdesc:aba0e4f3360d11eff1bf1b4553a451180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a string can be used to form a valid <a class="el" href="classfz_1_1Node__ID.html" title="Node ID that caches its ID stamp for frequent use. ">Node_ID</a>.  <a href="#aba0e4f3360d11eff1bf1b4553a451180">More...</a><br /></td></tr>
<tr class="separator:aba0e4f3360d11eff1bf1b4553a451180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4260c6b3087bdf22ce089216638d79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a0c4260c6b3087bdf22ce089216638d79">valid_Node_ID</a> (const <a class="el" href="structfz_1_1ID__TimeStamp.html">ID_TimeStamp</a> &amp;idT, std::string &amp;formerror)</td></tr>
<tr class="memdesc:a0c4260c6b3087bdf22ce089216638d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a <a class="el" href="structfz_1_1ID__TimeStamp.html" title="Timestamp IDs in the format required for Node IDs. ">ID_TimeStamp</a> can be used as a valid <a class="el" href="classfz_1_1Node__ID.html" title="Node ID that caches its ID stamp for frequent use. ">Node_ID</a>.  <a href="#a0c4260c6b3087bdf22ce089216638d79">More...</a><br /></td></tr>
<tr class="separator:a0c4260c6b3087bdf22ce089216638d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572283837fdf4fbab8814064feb3b1b1"><td class="memItemLeft" align="right" valign="top"><a id="a572283837fdf4fbab8814064feb3b1b1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Node_ID_TimeStamp_to_string</b> (const <a class="el" href="structfz_1_1ID__TimeStamp.html">ID_TimeStamp</a> idT)</td></tr>
<tr class="separator:a572283837fdf4fbab8814064feb3b1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1fc7e58ce04c390313b84700a15419"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#acf1fc7e58ce04c390313b84700a15419">create_Guide_table</a> (PGconn *conn, const std::string schemaname, const std::string guidetable, const std::string guidetablelayout)</td></tr>
<tr class="memdesc:acf1fc7e58ce04c390313b84700a15419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the table for Guide snippets if it does not already exist.  <a href="#acf1fc7e58ce04c390313b84700a15419">More...</a><br /></td></tr>
<tr class="separator:acf1fc7e58ce04c390313b84700a15419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c32b58a7df84713dc2a5554fc25c0b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a3c32b58a7df84713dc2a5554fc25c0b2">store_Guide_snippet_pq</a> (const <a class="el" href="structfz_1_1Guide__snippet.html">Guide_snippet</a> &amp;snippet, std::string <a class="el" href="namespacefz.html#ad4fdce135d088325b93bd26431b1f1c2">dbname</a>, std::string schemaname)</td></tr>
<tr class="memdesc:a3c32b58a7df84713dc2a5554fc25c0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a new Guide snippet in the PostgreSQL database.  <a href="#a3c32b58a7df84713dc2a5554fc25c0b2">More...</a><br /></td></tr>
<tr class="separator:a3c32b58a7df84713dc2a5554fc25c0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f47cae19dab82915dc813045ee3cfe"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab2f47cae19dab82915dc813045ee3cfe">Entries_total_text</a> (<a class="el" href="namespacefz.html#a005101cd3360f7440301c8c033b397f8">Log_entries_Map</a> &amp;entries)</td></tr>
<tr class="memdesc:ab2f47cae19dab82915dc813045ee3cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the total number of characters in <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry description text in the specified map.  <a href="#ab2f47cae19dab82915dc813045ee3cfe">More...</a><br /></td></tr>
<tr class="separator:ab2f47cae19dab82915dc813045ee3cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad749cc98362cd5b1af14cb171ead68fb"><td class="memItemLeft" align="right" valign="top"><a id="ad749cc98362cd5b1af14cb171ead68fb"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Log_entry_ID_TimeStamp_to_string</b> (const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> idT)</td></tr>
<tr class="separator:ad749cc98362cd5b1af14cb171ead68fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbff141b73f7b28f4d4b128ead8ba5d"><td class="memItemLeft" align="right" valign="top"><a id="acbbff141b73f7b28f4d4b128ead8ba5d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Log_chunk_ID_TimeStamp_to_string</b> (const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> idT)</td></tr>
<tr class="separator:acbbff141b73f7b28f4d4b128ead8ba5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a11e58e46a7c11d34572de05a7ebd8"><td class="memItemLeft" align="right" valign="top"><a id="a87a11e58e46a7c11d34572de05a7ebd8"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Log_TimeStamp_to_Ymd_string</b> (const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> idT)</td></tr>
<tr class="separator:a87a11e58e46a7c11d34572de05a7ebd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ced31e8ffbaf54c00a9f586eaf1dd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a61ced31e8ffbaf54c00a9f586eaf1dd4">valid_Log_entry_ID</a> (const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> &amp;idT, std::string &amp;formerror)</td></tr>
<tr class="memdesc:a61ced31e8ffbaf54c00a9f586eaf1dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a <a class="el" href="structfz_1_1Log__TimeStamp.html" title="Timestamp IDs in the format required for Log IDs. ">Log_TimeStamp</a> can be used as a valid <a class="el" href="classfz_1_1Log__entry__ID.html">Log_entry_ID</a>.  <a href="#a61ced31e8ffbaf54c00a9f586eaf1dd4">More...</a><br /></td></tr>
<tr class="separator:a61ced31e8ffbaf54c00a9f586eaf1dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045ec1abb4dc382e0b56e345c146de95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a045ec1abb4dc382e0b56e345c146de95">valid_Log_chunk_ID</a> (const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> &amp;idT, std::string &amp;formerror)</td></tr>
<tr class="memdesc:a045ec1abb4dc382e0b56e345c146de95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a <a class="el" href="structfz_1_1Log__TimeStamp.html" title="Timestamp IDs in the format required for Log IDs. ">Log_TimeStamp</a> can be used as a valid <a class="el" href="classfz_1_1Log__chunk__ID.html">Log_chunk_ID</a>.  <a href="#a045ec1abb4dc382e0b56e345c146de95">More...</a><br /></td></tr>
<tr class="separator:a045ec1abb4dc382e0b56e345c146de95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0d31396e23ba90447163d6b714f1d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a8c0d31396e23ba90447163d6b714f1d5">valid_Log_entry_ID</a> (std::string id_str, std::string &amp;formerror, <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> *id_timestamp)</td></tr>
<tr class="memdesc:a8c0d31396e23ba90447163d6b714f1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a string can be used to form a valid <a class="el" href="classfz_1_1Log__entry__ID.html">Log_entry_ID</a>.  <a href="#a8c0d31396e23ba90447163d6b714f1d5">More...</a><br /></td></tr>
<tr class="separator:a8c0d31396e23ba90447163d6b714f1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957bdd835342852a8ef5ad94723e34cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a957bdd835342852a8ef5ad94723e34cf">valid_Log_chunk_ID</a> (std::string id_str, std::string &amp;formerror, <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> *id_timestamp)</td></tr>
<tr class="memdesc:a957bdd835342852a8ef5ad94723e34cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a string can be used to form a valid <a class="el" href="classfz_1_1Log__chunk__ID.html">Log_chunk_ID</a>.  <a href="#a957bdd835342852a8ef5ad94723e34cf">More...</a><br /></td></tr>
<tr class="separator:a957bdd835342852a8ef5ad94723e34cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae767b87541ed3adf95ef80fb4cab307e"><td class="memItemLeft" align="right" valign="top">std::time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae767b87541ed3adf95ef80fb4cab307e">ActualTime</a> ()</td></tr>
<tr class="memdesc:ae767b87541ed3adf95ef80fb4cab307e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly provide the actual system time.  <a href="#ae767b87541ed3adf95ef80fb4cab307e">More...</a><br /></td></tr>
<tr class="separator:ae767b87541ed3adf95ef80fb4cab307e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdf2285bd874038959c3aca55feac8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a5cdf2285bd874038959c3aca55feac8d">error_summary_wrapper</a> ()</td></tr>
<tr class="memdesc:a5cdf2285bd874038959c3aca55feac8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapped version of ERRWARN_SUMMARY that can be stacked.  <a href="#a5cdf2285bd874038959c3aca55feac8d">More...</a><br /></td></tr>
<tr class="separator:a5cdf2285bd874038959c3aca55feac8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dba8841daadafb13e8b74c2ea661b9"><td class="memItemLeft" align="right" valign="top"><a id="ae7dba8841daadafb13e8b74c2ea661b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae7dba8841daadafb13e8b74c2ea661b9">clean_exit_wrapper</a> ()</td></tr>
<tr class="memdesc:ae7dba8841daadafb13e8b74c2ea661b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This does everyting that <code><a class="el" href="namespacefz.html#a3cd066a32696261830f98ca59ce4a7f0" title="Clean up after yourself before you exit. ">fz::Clean_Exit()</a></code> does, and it is stacked. <br /></td></tr>
<tr class="separator:ae7dba8841daadafb13e8b74c2ea661b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a72c04fc5a7860678e9156bd32b5aa1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a4a72c04fc5a7860678e9156bd32b5aa1">safe_cmdline_options</a> (int argc, char *argv[], std::string options, int &amp;optindcopy)</td></tr>
<tr class="memdesc:a4a72c04fc5a7860678e9156bd32b5aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The standard object for Formalizer programs.  <a href="#a4a72c04fc5a7860678e9156bd32b5aa1">More...</a><br /></td></tr>
<tr class="separator:a4a72c04fc5a7860678e9156bd32b5aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac327c945f41c63fef32c002d058fb7c"><td class="memItemLeft" align="right" valign="top"><a id="aac327c945f41c63fef32c002d058fb7c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aac327c945f41c63fef32c002d058fb7c">key_pause</a> ()</td></tr>
<tr class="memdesc:aac327c945f41c63fef32c002d058fb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A very simple function to wait for ENTER to be pressed. <br /></td></tr>
<tr class="separator:aac327c945f41c63fef32c002d058fb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d90c0e807ecdc776567257c7ba93b9"><td class="memItemLeft" align="right" valign="top">std::time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a29d90c0e807ecdc776567257c7ba93b9">time_stamp_time</a> (std::string timestr, bool noerror)</td></tr>
<tr class="memdesc:a29d90c0e807ecdc776567257c7ba93b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Formalizer time stamp string into local Unix time.  <a href="#a29d90c0e807ecdc776567257c7ba93b9">More...</a><br /></td></tr>
<tr class="separator:a29d90c0e807ecdc776567257c7ba93b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b13840120d2acc08fa2fb25a6c3d6a4"><td class="memItemLeft" align="right" valign="top"><a id="a7b13840120d2acc08fa2fb25a6c3d6a4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>TimeStamp</b> (const char *dateformat, std::time_t t)</td></tr>
<tr class="separator:a7b13840120d2acc08fa2fb25a6c3d6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58effa18dd1037431893b3ad00de2005"><td class="memItemLeft" align="right" valign="top"><a id="a58effa18dd1037431893b3ad00de2005"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a58effa18dd1037431893b3ad00de2005">TimeStampYmdHM</a> (std::time_t t)</td></tr>
<tr class="memdesc:a58effa18dd1037431893b3ad00de2005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Formalizer standardized date and time stamp (YYYYmmddHHMM). <br /></td></tr>
<tr class="separator:a58effa18dd1037431893b3ad00de2005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f965a9972440886cdbba23dee898e6e"><td class="memItemLeft" align="right" valign="top"><a id="a8f965a9972440886cdbba23dee898e6e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a8f965a9972440886cdbba23dee898e6e">DateStampYmd</a> (std::time_t t)</td></tr>
<tr class="memdesc:a8f965a9972440886cdbba23dee898e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Formalizer standardized date stamp (YYYYmmdd). <br /></td></tr>
<tr class="separator:a8f965a9972440886cdbba23dee898e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4308075d0f8dc4c0129d8ee71740e5"><td class="memItemLeft" align="right" valign="top"><a id="abe4308075d0f8dc4c0129d8ee71740e5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#abe4308075d0f8dc4c0129d8ee71740e5">BackupStampYmd</a> ()</td></tr>
<tr class="memdesc:abe4308075d0f8dc4c0129d8ee71740e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Formalizer standardized file backup extension (YYYYmmdd.bak). <br /></td></tr>
<tr class="separator:abe4308075d0f8dc4c0129d8ee71740e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4932c9514aab01039104a5b0033934d4"><td class="memItemLeft" align="right" valign="top"><a id="a4932c9514aab01039104a5b0033934d4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a4932c9514aab01039104a5b0033934d4">BackupStampYmdHM</a> ()</td></tr>
<tr class="memdesc:a4932c9514aab01039104a5b0033934d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Formalizer standardized file backup precise extension (YYYYmmddHHMM.bak). <br /></td></tr>
<tr class="separator:a4932c9514aab01039104a5b0033934d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30be49d20ac6c8ba1b313fc295a235a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a30be49d20ac6c8ba1b313fc295a235a2">is_leapyear</a> (unsigned int year)</td></tr>
<tr class="memdesc:a30be49d20ac6c8ba1b313fc295a235a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple leap year test.  <a href="#a30be49d20ac6c8ba1b313fc295a235a2">More...</a><br /></td></tr>
<tr class="separator:a30be49d20ac6c8ba1b313fc295a235a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af320a36d5d2f05de32419ea52f625e1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#af320a36d5d2f05de32419ea52f625e1e">valid_year_month_day</a> (<a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a> ymd)</td></tr>
<tr class="memdesc:af320a36d5d2f05de32419ea52f625e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a year, month and day form a valid date.  <a href="#af320a36d5d2f05de32419ea52f625e1e">More...</a><br /></td></tr>
<tr class="separator:af320a36d5d2f05de32419ea52f625e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053fc7625765a11b31ee3604a1f225b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a053fc7625765a11b31ee3604a1f225b0">years_months_days</a> (<a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a> ymd1, <a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a> ymd2)</td></tr>
<tr class="memdesc:a053fc7625765a11b31ee3604a1f225b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Express the difference between two dates in terms of the number of Years, Months and Days between them.  <a href="#a053fc7625765a11b31ee3604a1f225b0">More...</a><br /></td></tr>
<tr class="separator:a053fc7625765a11b31ee3604a1f225b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bfa54595aa468eba2c7e5fda819ecf"><td class="memItemLeft" align="right" valign="top"><a id="a84bfa54595aa468eba2c7e5fda819ecf"></a>
<a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>years_months_days</b> (std::time_t t1, std::time_t t2)</td></tr>
<tr class="separator:a84bfa54595aa468eba2c7e5fda819ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7dc82ea6c4ab29ef2cbb51d09e7b8a"><td class="memItemLeft" align="right" valign="top"><a id="a8a7dc82ea6c4ab29ef2cbb51d09e7b8a"></a>
<a class="el" href="classfz_1_1Errors.html">Errors</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ErrQ</b> (DEFAULT_ERRLOGPATH)</td></tr>
<tr class="separator:a8a7dc82ea6c4ab29ef2cbb51d09e7b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf44b9878517c39c7fc3b53d7c7f56a6"><td class="memItemLeft" align="right" valign="top"><a id="acf44b9878517c39c7fc3b53d7c7f56a6"></a>
<a class="el" href="classfz_1_1Errors.html">Errors</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WarnQ</b> (DEFAULT_WARNLOGPATH)</td></tr>
<tr class="separator:acf44b9878517c39c7fc3b53d7c7f56a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b84c36d3ebbf295bcbd154874858b3"><td class="memItemLeft" align="right" valign="top"><a id="a34b84c36d3ebbf295bcbd154874858b3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>identical_Topics</b> (const <a class="el" href="classfz_1_1Topic.html">Topic</a> &amp;topic1, const <a class="el" href="classfz_1_1Topic.html">Topic</a> &amp;topic2, std::string &amp;trace)</td></tr>
<tr class="separator:a34b84c36d3ebbf295bcbd154874858b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e57f175450656687c5ca428725d97bd"><td class="memItemLeft" align="right" valign="top"><a id="a9e57f175450656687c5ca428725d97bd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>identical_Topic_Tags</b> (<a class="el" href="classfz_1_1Topic__Tags.html">Topic_Tags</a> &amp;ttags1, <a class="el" href="classfz_1_1Topic__Tags.html">Topic_Tags</a> &amp;ttags2, std::string &amp;trace)</td></tr>
<tr class="separator:a9e57f175450656687c5ca428725d97bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa017a0d639d3d67ac4b304efa514eae9"><td class="memItemLeft" align="right" valign="top"><a id="aa017a0d639d3d67ac4b304efa514eae9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>identical_Node_ID_key</b> (const <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a> &amp;key1, const <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a> &amp;key2, std::string &amp;trace)</td></tr>
<tr class="separator:aa017a0d639d3d67ac4b304efa514eae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f4dc710aff55f6fd9c2e111d7df259"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a96f4dc710aff55f6fd9c2e111d7df259">identical_Nodes</a> (<a class="el" href="classfz_1_1Node.html">Node</a> &amp;node1, <a class="el" href="classfz_1_1Node.html">Node</a> &amp;node2, std::string &amp;trace)</td></tr>
<tr class="memdesc:a96f4dc710aff55f6fd9c2e111d7df259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> objects contain the same data.  <a href="#a96f4dc710aff55f6fd9c2e111d7df259">More...</a><br /></td></tr>
<tr class="separator:a96f4dc710aff55f6fd9c2e111d7df259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3bb9d1734c1f79ca4d1f2c0e269d93"><td class="memItemLeft" align="right" valign="top"><a id="afe3bb9d1734c1f79ca4d1f2c0e269d93"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>identical_Edge_ID_key</b> (const <a class="el" href="structfz_1_1Edge__ID__key.html">Edge_ID_key</a> &amp;key1, const <a class="el" href="structfz_1_1Edge__ID__key.html">Edge_ID_key</a> &amp;key2, std::string &amp;trace)</td></tr>
<tr class="separator:afe3bb9d1734c1f79ca4d1f2c0e269d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c6c4def4995096eab72c38358ffdeb"><td class="memItemLeft" align="right" valign="top"><a id="ae7c6c4def4995096eab72c38358ffdeb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>identical_Edges</b> (<a class="el" href="classfz_1_1Edge.html">Edge</a> &amp;edge1, <a class="el" href="classfz_1_1Edge.html">Edge</a> &amp;edge2, std::string &amp;trace)</td></tr>
<tr class="separator:ae7c6c4def4995096eab72c38358ffdeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569da80848b8001bc12867337f51d1c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a569da80848b8001bc12867337f51d1c9">identical_Graphs</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph1, <a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph2, std::string &amp;trace)</td></tr>
<tr class="memdesc:a569da80848b8001bc12867337f51d1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two Graphs to report if they are data-identical.  <a href="#a569da80848b8001bc12867337f51d1c9">More...</a><br /></td></tr>
<tr class="separator:a569da80848b8001bc12867337f51d1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7549e0f879bb89ae170db487ced95cd9"><td class="memItemLeft" align="right" valign="top"><a id="a7549e0f879bb89ae170db487ced95cd9"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_enum_td_property</b> (&quot;('unspecified','inherit','variable','fixed','exact')&quot;)</td></tr>
<tr class="separator:a7549e0f879bb89ae170db487ced95cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8eb5b2d3cc88e7c31c21f894fb41795"><td class="memItemLeft" align="right" valign="top"><a id="ab8eb5b2d3cc88e7c31c21f894fb41795"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_enum_td_pattern</b> (&quot;('patt_daily','patt_workdays','patt_weekly','patt_biweekly','patt_monthly','patt_endofmonthoffset','patt_yearly','OLD_patt_span','patt_nonperiodic')&quot;)</td></tr>
<tr class="separator:ab8eb5b2d3cc88e7c31c21f894fb41795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e2e0c10e0a99c02075317aeeb6c1c5"><td class="memItemLeft" align="right" valign="top"><a id="a27e2e0c10e0a99c02075317aeeb6c1c5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_nodelayout</b> (&quot;id char(16) PRIMARY KEY,&quot; &quot;topics smallint[],&quot; &quot;topicrelevance real[],&quot; &quot;valuation real,&quot; &quot;completion real,&quot; &quot;required integer,&quot; &quot;text text,&quot; &quot;targetdate timestamp (0),&quot; &quot;tdproperty <a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">td_property</a>,&quot; &quot;isperiodic boolean,&quot; &quot;tdperiodic td_pattern,&quot; &quot;tdevery integer,&quot; &quot;tdspan integer&quot;)</td></tr>
<tr class="separator:a27e2e0c10e0a99c02075317aeeb6c1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73614ef8b5bc9f7003d3bac5de7813bf"><td class="memItemLeft" align="right" valign="top"><a id="a73614ef8b5bc9f7003d3bac5de7813bf"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_edgelayout</b> (&quot;id char(33),&quot; &quot;dependency real,&quot; &quot;significance real,&quot; &quot;importance real,&quot; &quot;urgency real,&quot; &quot;priority real&quot;)</td></tr>
<tr class="separator:a73614ef8b5bc9f7003d3bac5de7813bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95d4dae6638078251973dce703bc6da"><td class="memItemLeft" align="right" valign="top"><a id="ac95d4dae6638078251973dce703bc6da"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_topiclayout</b> (&quot;id smallint,&quot; &quot;supid smallint,&quot; &quot;tag text,&quot; &quot;title text,&quot; &quot;keyword text[],&quot; &quot;relevance real[]&quot;)</td></tr>
<tr class="separator:ac95d4dae6638078251973dce703bc6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe38748c6da4110ea71ee010642d3606"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#afe38748c6da4110ea71ee010642d3606">get_Topic_pq_field_numbers</a> (PGresult *res)</td></tr>
<tr class="memdesc:afe38748c6da4110ea71ee010642d3606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve field column numbers for topics query to make sure the correct field numbers are used.  <a href="#afe38748c6da4110ea71ee010642d3606">More...</a><br /></td></tr>
<tr class="separator:afe38748c6da4110ea71ee010642d3606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c85e3e526a0195ae67354ec8da0961"><td class="memItemLeft" align="right" valign="top"><a id="a66c85e3e526a0195ae67354ec8da0961"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_Node_pq_field_numbers</b> (PGresult *res)</td></tr>
<tr class="separator:a66c85e3e526a0195ae67354ec8da0961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d83157fc9e0622a67f569ec7b4e821"><td class="memItemLeft" align="right" valign="top"><a id="af8d83157fc9e0622a67f569ec7b4e821"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_Edge_pq_field_numbers</b> (PGresult *res)</td></tr>
<tr class="separator:af8d83157fc9e0622a67f569ec7b4e821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2e1a49e1871f23c757c97c84484676"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structfz_1_1Topic__Keyword.html">Topic_Keyword</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#add2e1a49e1871f23c757c97c84484676">keyrel_from_pq</a> (std::string keywordstr, std::string relevancestr)</td></tr>
<tr class="memdesc:add2e1a49e1871f23c757c97c84484676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert textual arrays of keywords and keyword-relevance values to a vector of <a class="el" href="structfz_1_1Topic__Keyword.html" title="Type for real-valued Keyword relevance (to Topic), presently assumed to be in the interval [0...">Topic_Keyword</a> pairs.  <a href="#add2e1a49e1871f23c757c97c84484676">More...</a><br /></td></tr>
<tr class="separator:add2e1a49e1871f23c757c97c84484676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2218c0801453155ac1531a857fd4e6"><td class="memItemLeft" align="right" valign="top"><a id="a0f2218c0801453155ac1531a857fd4e6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>read_Topics_pq</b> (PGconn *conn, std::string schemaname, <a class="el" href="classfz_1_1Topic__Tags.html">Topic_Tags</a> &amp;topictags)</td></tr>
<tr class="separator:a0f2218c0801453155ac1531a857fd4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de97e67d19ad7d3d8bd98bd13f2cb27"><td class="memItemLeft" align="right" valign="top"><a id="a9de97e67d19ad7d3d8bd98bd13f2cb27"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>node_topics_from_pq</b> (<a class="el" href="classfz_1_1Node.html">Node</a> &amp;node, std::string topicsstr, std::string topicrelevancestr)</td></tr>
<tr class="separator:a9de97e67d19ad7d3d8bd98bd13f2cb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658f2d4bdcf3d5fced3a350eed24d1a3"><td class="memItemLeft" align="right" valign="top"><a id="a658f2d4bdcf3d5fced3a350eed24d1a3"></a>
<a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">td_property</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tdproperty_from_pq</b> (std::string pqtdproperty)</td></tr>
<tr class="separator:a658f2d4bdcf3d5fced3a350eed24d1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47cf2abbaba0b2f748c0d170a543c5c"><td class="memItemLeft" align="right" valign="top"><a id="aa47cf2abbaba0b2f748c0d170a543c5c"></a>
td_pattern&#160;</td><td class="memItemRight" valign="bottom"><b>tdpattern_from_pq</b> (std::string pqtdpattern)</td></tr>
<tr class="separator:aa47cf2abbaba0b2f748c0d170a543c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a879fdf29f58852f12083396988690"><td class="memItemLeft" align="right" valign="top"><a id="af4a879fdf29f58852f12083396988690"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>read_Nodes_pq</b> (PGconn *conn, std::string schemaname, <a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="separator:af4a879fdf29f58852f12083396988690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80adfe467cc24306945531b24fc2d766"><td class="memItemLeft" align="right" valign="top"><a id="a80adfe467cc24306945531b24fc2d766"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>read_Edges_pq</b> (PGconn *conn, std::string schemaname, <a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="separator:a80adfe467cc24306945531b24fc2d766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70525212cc7a8fff346a1540c8c8f8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfz_1_1Topic.html">Topic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#af70525212cc7a8fff346a1540c8c8f8a">main_topic</a> (<a class="el" href="classfz_1_1Topic__Tags.html">Topic_Tags</a> &amp;topictags, <a class="el" href="classfz_1_1Node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:af70525212cc7a8fff346a1540c8c8f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the main <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> of a <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a>, as indicated by the maximum Topic_Relevance value.  <a href="#af70525212cc7a8fff346a1540c8c8f8a">More...</a><br /></td></tr>
<tr class="separator:af70525212cc7a8fff346a1540c8c8f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302a9b232573c36c992a057ff655cad7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfz_1_1Topic.html">Topic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a302a9b232573c36c992a057ff655cad7">main_topic</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;_graph, <a class="el" href="classfz_1_1Node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:a302a9b232573c36c992a057ff655cad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the main <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> of a <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a>, as indicated by the maximum Topic_Relevance value.  <a href="#a302a9b232573c36c992a057ff655cad7">More...</a><br /></td></tr>
<tr class="separator:a302a9b232573c36c992a057ff655cad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af542142d941cd3b6ed66b5b6ed7bc181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfz_1_1Topic.html">Topic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#af542142d941cd3b6ed66b5b6ed7bc181">main_topic</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;_graph, <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &amp;chunk)</td></tr>
<tr class="memdesc:af542142d941cd3b6ed66b5b6ed7bc181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the main <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> of a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk's <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a>, as indicated by the maximum Topic_Relevance value.  <a href="#af542142d941cd3b6ed66b5b6ed7bc181">More...</a><br /></td></tr>
<tr class="separator:af542142d941cd3b6ed66b5b6ed7bc181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bdf475eb9d5fb9b7dfe97fe594498b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Log_chunks_Deque::size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a16bdf475eb9d5fb9b7dfe97fe594498b">Breakpoint_Indices</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:a16bdf475eb9d5fb9b7dfe97fe594498b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This converts the list of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> breakpoint <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk IDs into a list of indices into the list of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks (in Log::chunks).  <a href="#a16bdf475eb9d5fb9b7dfe97fe594498b">More...</a><br /></td></tr>
<tr class="separator:a16bdf475eb9d5fb9b7dfe97fe594498b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99de56e900ef8f39ac539d88521905ab"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a99de56e900ef8f39ac539d88521905ab">Log_span_in_seconds</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:a99de56e900ef8f39ac539d88521905ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the span in seconds from when the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was started (first cunk) to its most recent chunk.  <a href="#a99de56e900ef8f39ac539d88521905ab">More...</a><br /></td></tr>
<tr class="separator:a99de56e900ef8f39ac539d88521905ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99ee1f9eb33cd43975a1e2ba185affc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab99ee1f9eb33cd43975a1e2ba185affc">Log_span_in_days</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:ab99ee1f9eb33cd43975a1e2ba185affc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the span in days from when the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was started (first cunk) to its most recent chunk.  <a href="#ab99ee1f9eb33cd43975a1e2ba185affc">More...</a><br /></td></tr>
<tr class="separator:ab99ee1f9eb33cd43975a1e2ba185affc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac852c19de9635df74fca9eab2d419e5b"><td class="memItemLeft" align="right" valign="top">ymd_tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ac852c19de9635df74fca9eab2d419e5b">Log_span_years_months_days</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:ac852c19de9635df74fca9eab2d419e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the span in years, months and days from when the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was started (first cunk) to its most recent chunk.  <a href="#ac852c19de9635df74fca9eab2d419e5b">More...</a><br /></td></tr>
<tr class="separator:ac852c19de9635df74fca9eab2d419e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac009eb8797e3b0c24c3f4bf60941797"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Log_chunks_Deque::size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aac009eb8797e3b0c24c3f4bf60941797">Chunks_per_Breakpoint</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:aac009eb8797e3b0c24c3f4bf60941797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the frequency distribution for the number of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks per <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> breakpoint.  <a href="#aac009eb8797e3b0c24c3f4bf60941797">More...</a><br /></td></tr>
<tr class="separator:aac009eb8797e3b0c24c3f4bf60941797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0563de3c4cc5d0ad43ea49f58b6bd6"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aba0563de3c4cc5d0ad43ea49f58b6bd6">Chunks_total_minutes</a> (<a class="el" href="structfz_1_1Log__chunks__Deque.html">Log_chunks_Deque</a> &amp;chunks)</td></tr>
<tr class="memdesc:aba0563de3c4cc5d0ad43ea49f58b6bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the total number of minutes logged for all <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks in the specified deque.  <a href="#aba0563de3c4cc5d0ad43ea49f58b6bd6">More...</a><br /></td></tr>
<tr class="separator:aba0563de3c4cc5d0ad43ea49f58b6bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c5acaefdebe1051c4ff921bc754e68"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a31c5acaefdebe1051c4ff921bc754e68">TimeStamp</a> (const char *dateformat, time_t t)</td></tr>
<tr class="memdesc:a31c5acaefdebe1051c4ff921bc754e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate time stamp.  <a href="#a31c5acaefdebe1051c4ff921bc754e68">More...</a><br /></td></tr>
<tr class="separator:a31c5acaefdebe1051c4ff921bc754e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad4fdce135d088325b93bd26431b1f1c2"><td class="memItemLeft" align="right" valign="top"><a id="ad4fdce135d088325b93bd26431b1f1c2"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ad4fdce135d088325b93bd26431b1f1c2">dbname</a></td></tr>
<tr class="memdesc:ad4fdce135d088325b93bd26431b1f1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postgres database name. <br /></td></tr>
<tr class="separator:ad4fdce135d088325b93bd26431b1f1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cd30cfc5dc53430122ba5e9f7f3fc7"><td class="memItemLeft" align="right" valign="top"><a id="ad4cd30cfc5dc53430122ba5e9f7f3fc7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ad4cd30cfc5dc53430122ba5e9f7f3fc7">errhint</a></td></tr>
<tr class="memdesc:ad4cd30cfc5dc53430122ba5e9f7f3fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global variable that can be updated to give a better hint about where exactly an error occurred. <br /></td></tr>
<tr class="separator:ad4cd30cfc5dc53430122ba5e9f7f3fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6eca7b9586ecff715a8ad5bd26efb3e"><td class="memItemLeft" align="right" valign="top"><a id="ab6eca7b9586ecff715a8ad5bd26efb3e"></a>
<a class="el" href="classfz_1_1Errors.html">Errors</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ErrQ</b></td></tr>
<tr class="separator:ab6eca7b9586ecff715a8ad5bd26efb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcb97eafaecf389dd6dd7a9cbde00ed"><td class="memItemLeft" align="right" valign="top"><a id="aafcb97eafaecf389dd6dd7a9cbde00ed"></a>
<a class="el" href="classfz_1_1Errors.html">Errors</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WarnQ</b></td></tr>
<tr class="separator:aafcb97eafaecf389dd6dd7a9cbde00ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba84cce5b733cf4ca721bd800103b1c4"><td class="memItemLeft" align="right" valign="top"><a id="aba84cce5b733cf4ca721bd800103b1c4"></a>
<a class="el" href="classfz_1_1Simulate__PQ__Changes.html">Simulate_PQ_Changes</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SimPQ</b></td></tr>
<tr class="separator:aba84cce5b733cf4ca721bd800103b1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5946fa5b803240f1c0cd734f214c8c15"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>td_property_str</b> [_tdprop_num]</td></tr>
<tr class="separator:a5946fa5b803240f1c0cd734f214c8c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64dd91504fdcea08cc7617a5314ec6d2"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>td_pattern_str</b> [_patt_num]</td></tr>
<tr class="separator:a64dd91504fdcea08cc7617a5314ec6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd4b0fb0c54c1b32ee6a18e72bfccf1"><td class="memItemLeft" align="right" valign="top"><a id="a5bd4b0fb0c54c1b32ee6a18e72bfccf1"></a>
<a class="el" href="structfz_1_1formalizer__base__streams.html">formalizer_base_streams</a>&#160;</td><td class="memItemRight" valign="bottom"><b>base</b></td></tr>
<tr class="separator:a5bd4b0fb0c54c1b32ee6a18e72bfccf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1175f0f5292c6aa0a3ef62087b19acc9"><td class="memItemLeft" align="right" valign="top"><a id="a1175f0f5292c6aa0a3ef62087b19acc9"></a>
<a class="el" href="structfz_1_1formalizer__standard__program.html">formalizer_standard_program</a>&#160;</td><td class="memItemRight" valign="bottom"><b>standard</b></td></tr>
<tr class="separator:a1175f0f5292c6aa0a3ef62087b19acc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9f249ab6da4a5330fbf47805b36b49"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_topic_fieldnames</b> [_pqt_NUM]</td></tr>
<tr class="separator:a0e9f249ab6da4a5330fbf47805b36b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2e72b75f6a44514c6175b6dd58988c"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_node_fieldnames</b> [_pqn_NUM]</td></tr>
<tr class="separator:a4e2e72b75f6a44514c6175b6dd58988c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593c105236196b2da156f585c6d7ae30"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_edge_fieldnames</b> [_pqe_NUM]</td></tr>
<tr class="separator:a593c105236196b2da156f585c6d7ae30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40054abc0cdb4156693ceafa10eda38a"><td class="memItemLeft" align="right" valign="top"><a id="a40054abc0cdb4156693ceafa10eda38a"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>pq_topic_field</b> [_pqt_NUM]</td></tr>
<tr class="separator:a40054abc0cdb4156693ceafa10eda38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4a02a14d1fd045bd92c84b18c51cc1"><td class="memItemLeft" align="right" valign="top"><a id="a1a4a02a14d1fd045bd92c84b18c51cc1"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>pq_node_field</b> [_pqn_NUM]</td></tr>
<tr class="separator:a1a4a02a14d1fd045bd92c84b18c51cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae856eb9ebccda1813f38aef6ebed04b4"><td class="memItemLeft" align="right" valign="top"><a id="ae856eb9ebccda1813f38aef6ebed04b4"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>pq_edge_field</b> [_pqe_NUM]</td></tr>
<tr class="separator:ae856eb9ebccda1813f38aef6ebed04b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3867ed7aa9968c6dc3743c08621727"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">td_property</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tdprop_by_pqtdprop</b></td></tr>
<tr class="separator:acd3867ed7aa9968c6dc3743c08621727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47d47929bea0b332de69408d4880092"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, td_pattern &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tdpatt_by_pqtdpatt</b></td></tr>
<tr class="separator:ab47d47929bea0b332de69408d4880092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab0d860bf18ea1cc2acb7577f4f294f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfz_1_1ReferenceTime.html">ReferenceTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aeab0d860bf18ea1cc2acb7577f4f294f">maintime</a></td></tr>
<tr class="memdesc:aeab0d860bf18ea1cc2acb7577f4f294f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Every program that uses core Formalizer functions that depend on time stamping includes <a class="el" href="ReferenceTime_8hpp_source.html">ReferenceTime.hpp</a> (it is automatically included through <a class="el" href="TimeStamp_8hpp_source.html">TimeStamp.hpp</a>).  <a href="#aeab0d860bf18ea1cc2acb7577f4f294f">More...</a><br /></td></tr>
<tr class="separator:aeab0d860bf18ea1cc2acb7577f4f294f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>fzserverpq is the Postgres-compatible version of the C++ implementation of teh Formalizer data server. </p>
<p>A simmple set of templating functions.</p>
<p>This source file was separated out of Graphtypes.cpp in order to produce a separate compiled .obj file for <a class="el" href="classfz_1_1Graph.html">Graph</a> comparison (friend) helper utility functions.</p>
<p>General collection of functions used in various Core and Tool programs.</p>
<p>On Ubuntu, to install the libpq libraries, including the libpq-fe.h header file, do: sudo apt-get install libpq-dev You may also have to add /usr/include or /usr/include/postgresql to the CPATH or to the includes in the Makefile, e.g.</p>
<p>For more information see: <a href="https://docs.google.com/document/d/1rYPFgzFgjkF1xGx3uABiXiaDR5sfmOzqYQRqSntcyyY/edit#heading=h.tarhfe395l5v">https://docs.google.com/document/d/1rYPFgzFgjkF1xGx3uABiXiaDR5sfmOzqYQRqSntcyyY/edit#heading=h.tarhfe395l5v</a> <a href="https://trello.com/c/S7SZUyeU">https://trello.com/c/S7SZUyeU</a></p>
<p>-I/usr/include/postgresql.</p>
<p>Those functions will not be needed by every program that needs the <a class="el" href="classfz_1_1Graph.html">Graph</a> data type header.</p>
<p>In many cases, this can be a small fast replacement for a feature-rich templating library such as <code>inja</code>. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a22cb31bb2e4314340751a857568610fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cb31bb2e4314340751a857568610fe">&#9670;&nbsp;</a></span>Edges_Set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="classfz_1_1Edge.html">Edge</a>*&gt; <a class="el" href="namespacefz.html#a22cb31bb2e4314340751a857568610fe">fz::Edges_Set</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>targetdate: For details, see the description at <a href="https://docs.google.com/document/d/1rYPFgzFgjkF1xGx3uABiXiaDR5sfmOzqYQRqSntcyyY/edit#heading=h.nu3mb52d1k6n">https://docs.google.com/document/d/1rYPFgzFgjkF1xGx3uABiXiaDR5sfmOzqYQRqSntcyyY/edit#heading=h.nu3mb52d1k6n</a>. </p>
<p>topics: <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> tags specify logical categories to which a <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> belongs. A <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> can belong to many categories, and new topic categories can be defined freely. By convention, every <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> must have at least 1 topic tag at all times. Since <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> storage can now be independent of <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> tagging there is no strict implementation reason for this. It has backward compatibility value. See the historical node for more. (historical) In the dil2al implementation of a <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> (DIL_entry), most of the <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> data is stored in a 'DIL File', also known as a <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> or Topical File. Every <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> had to be stored in at least one such file (but could be copied in multiple such files), so that <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> data was stored. A <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> could not belong to zero DIL Files. </p>

</div>
</div>
<a id="a005101cd3360f7440301c8c033b397f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005101cd3360f7440301c8c033b397f8">&#9670;&nbsp;</a></span>Log_entries_Map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;const <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a>,std::unique_ptr&lt;<a class="el" href="classfz_1_1Log__entry.html">Log_entry</a>&gt; &gt; <a class="el" href="namespacefz.html#a005101cd3360f7440301c8c033b397f8">fz::Log_entries_Map</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><h3><a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries (map)</h3>
</p>
<p>A map of smart pointers to <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries, referenced by <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry ID key. This is how entries are connected in the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> data structure.</p>
<p>Consecutive entries (ordered by ID) are the primary records of the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a>, as stored in database format. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a95a7b508456ccb1691f487ed136d52d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a7b508456ccb1691f487ed136d52d4">&#9670;&nbsp;</a></span>exit_status_code</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefz.html#a95a7b508456ccb1691f487ed136d52d4">fz::exit_status_code</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standardized exit codes for the Formalizer environment. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a95a7b508456ccb1691f487ed136d52d4a705b1561a859fa4dfba9b3e3045d9f24"></a>exit_NUMENUMS&#160;</td><td class="fielddoc"><p>this one simplifies corresponding array definition, e.g. char[exit_NUMENUMS] </p>
</td></tr>
</table>

</div>
</div>
<a id="a6c45e5e183774ed3322e5c3d445b3f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c45e5e183774ed3322e5c3d445b3f70">&#9670;&nbsp;</a></span>td_property</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">fz::td_property</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For more information about td_property values, as well as future expansions, please see the Formalizer documentation section <a href="https://docs.google.com/document/d/1rYPFgzFgjkF1xGx3uABiXiaDR5sfmOzqYQRqSntcyyY/edit#heading=h.nu3mb52d1k6n">Target date parameters in Graph v2.0+</a>. </p>
<p>Also consider Note 2 of the documentation of dil2graph.cc:get_Node_Target_Date() about target date hints in the <a class="el" href="classfz_1_1Graph.html">Graph</a> 2.0+ format parameters. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae767b87541ed3adf95ef80fb4cab307e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae767b87541ed3adf95ef80fb4cab307e">&#9670;&nbsp;</a></span>ActualTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::time_t fz::ActualTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly provide the actual system time. </p>
<p>This function is called where an emulated time status cannot be applied, such as when generating time stamps for backup files. </p>

</div>
</div>
<a id="ab26caa1b821a4715dbec90c174a95e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26caa1b821a4715dbec90c174a95e97">&#9670;&nbsp;</a></span>array_from_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; fz::array_from_pq </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pq_array_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a single string containing Postgres query output that represents an array into a vector of strings. </p>
<p>The Postgres array should be enclosed in curly brackets.</p>
<p>WARNING: This function assumes that every comma indicates a next element of the array. It does not consider the case where array elements may be quoted text that contains commas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pq_array_str</td><td>the Postgres query output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of strings, one for each array element. </dd></dl>

</div>
</div>
<a id="a16bdf475eb9d5fb9b7dfe97fe594498b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bdf475eb9d5fb9b7dfe97fe594498b">&#9670;&nbsp;</a></span>Breakpoint_Indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Log_chunks_Deque::size_type&gt; fz::Breakpoint_Indices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This converts the list of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> breakpoint <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk IDs into a list of indices into the list of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks (in Log::chunks). </p>
<p>Note: All <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks must be loaded into memory before calling this function.</p>
<p>If a breakpoint was not found then the corresponding element of the vector of indices has the value log::num_Chunks(), pointing beyond all valid <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks in the deque.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> object where all <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks are in the chunks deque. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of indices into log::chunks. </dd></dl>

</div>
</div>
<a id="aac009eb8797e3b0c24c3f4bf60941797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac009eb8797e3b0c24c3f4bf60941797">&#9670;&nbsp;</a></span>Chunks_per_Breakpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Log_chunks_Deque::size_type&gt; fz::Chunks_per_Breakpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the frequency distribution for the number of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks per <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> breakpoint. </p>
<p>Note: All <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks must be loaded into memory before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> object where all <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks are in the chunks deque. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of counts. </dd></dl>

</div>
</div>
<a id="aba0563de3c4cc5d0ad43ea49f58b6bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0563de3c4cc5d0ad43ea49f58b6bd6">&#9670;&nbsp;</a></span>Chunks_total_minutes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long fz::Chunks_total_minutes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1Log__chunks__Deque.html">Log_chunks_Deque</a> &amp;&#160;</td>
          <td class="paramname"><em>chunks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the total number of minutes logged for all <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks in the specified deque. </p>
<p>Sum of durations of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunks</td><td>a deque containing a sorted list <a class="el" href="classfz_1_1Log__chunk.html" title="Specifies the start time, Node, close time, and set of entries of a Log chunk. ">Log_chunk</a> pointers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum total of time logged in minutes. </dd></dl>

</div>
</div>
<a id="a3cd066a32696261830f98ca59ce4a7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd066a32696261830f98ca59ce4a7f0">&#9670;&nbsp;</a></span>Clean_Exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::Clean_Exit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ecode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up after yourself before you exit. </p>
<p>Call this to exit the program and log any remaining errors in the queue.</p>
<p>The ERRWARN_SUMMARY() macro can be used to print a summary report before calling this function. After this function the queues will be empty.</p>
<p>Note: If you are using <a class="el" href="standard_8hpp.html" title="This header file declares standard structures and functions that should be used with any standardized...">standard.hpp</a> (which every Formalizer program should) then do not use this function. The correct exit processes will be set up by member functions and initialization of the <code>fz::standard</code> object instead. In your program, you can then simply call <code>exit(error_code)</code> or <code>standard.exit(error_code)</code>. Both will do the same thing. </p>

</div>
</div>
<a id="a9bde9da1de78d7bc0492b22eba9630e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bde9da1de78d7bc0492b22eba9630e8">&#9670;&nbsp;</a></span>connection_setup_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PGconn * fz::connection_setup_pq </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up a connection with an existing Postgres database. </p>
<p>This also prepares a safe search search path. The database needs to exist. If necessary, create it with the command <code>createdb [databasename]</code> (which defaults to the user name).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2da8c677f43a85e7f86d9074e468962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2da8c677f43a85e7f86d9074e468962">&#9670;&nbsp;</a></span>create_Edges_table_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Edges_table_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new database table for Edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>active database connection. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if table was successfully created. </dd></dl>

</div>
</div>
<a id="abe69e72e6cc57d40e3738f2bb2d7b1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe69e72e6cc57d40e3738f2bb2d7b1bc">&#9670;&nbsp;</a></span>create_Enum_Types_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Enum_Types_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create enumerated types in database for <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> and <a class="el" href="classfz_1_1Edge.html">Edge</a> data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>active database connection. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if types were successfully created. </dd></dl>

</div>
</div>
<a id="a44280392e614e1145d3c5a27aa640b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44280392e614e1145d3c5a27aa640b59">&#9670;&nbsp;</a></span>create_Formalizer_schema_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Formalizer_schema_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new database schema for Formalizer data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>active database connection. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if schema was successfully created. </dd></dl>

</div>
</div>
<a id="acf1fc7e58ce04c390313b84700a15419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1fc7e58ce04c390313b84700a15419">&#9670;&nbsp;</a></span>create_Guide_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Guide_table </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>guidetable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>guidetablelayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the table for Guide snippets if it does not already exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>is an open database connection. </td></tr>
    <tr><td class="paramname">schemaname</td><td>is the Formalizer schema name (usually Graph_access::pq_schemaname). </td></tr>
    <tr><td class="paramname">guidetable</td><td>is the Guide table name (e.g. "guide_system"). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75375e8fb94d22f2facb4085afe93de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75375e8fb94d22f2facb4085afe93de9">&#9670;&nbsp;</a></span>create_Nodes_table_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Nodes_table_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new database table for Nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>active database connection. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if table was successfully created. </dd></dl>

</div>
</div>
<a id="a2359bd1e82e68f38bd9d900588887fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2359bd1e82e68f38bd9d900588887fde">&#9670;&nbsp;</a></span>create_Topics_table_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Topics_table_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new database table for Topics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>active database connection. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if table was successfully created. </dd></dl>

</div>
</div>
<a id="ab2f47cae19dab82915dc813045ee3cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f47cae19dab82915dc813045ee3cfe">&#9670;&nbsp;</a></span>Entries_total_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long fz::Entries_total_text </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacefz.html#a005101cd3360f7440301c8c033b397f8">Log_entries_Map</a> &amp;&#160;</td>
          <td class="paramname"><em>entries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the total number of characters in <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry description text in the specified map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entries</td><td>a map containing <a class="el" href="structfz_1_1Log__entry__ID__key.html" title="Standardized Formalizer Log entry ID key. ">Log_entry_ID_key</a> and <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> smart pointer pairs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum total of text characters. </dd></dl>

</div>
</div>
<a id="a5cdf2285bd874038959c3aca55feac8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdf2285bd874038959c3aca55feac8d">&#9670;&nbsp;</a></span>error_summary_wrapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::error_summary_wrapper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wrapped version of ERRWARN_SUMMARY that can be stacked. </p>
<p>This can be suppressed either by setting base.out to nullptr or by setting the standard.quiet flag. (Note that this flag receives a copy of any formalizer_standard_program::quiet when <a class="el" href="structfz_1_1formalizer__standard__program.html#a96b26e4e551e8de1b1bad082d67ba600" title="You can call this instead of std::exit() if you like, same thing, same stack. ">formalizer_standard_program::exit()</a> is used.) </p>

</div>
</div>
<a id="aac311316b5a762d53489ec1135d88479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac311316b5a762d53489ec1135d88479">&#9670;&nbsp;</a></span>file_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::file_to_string </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ifstream::iostate *&#160;</td>
          <td class="paramname"><em>readstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the full contents of a (text) file into a string. </p>
<p>The contents of the receiving string are replaced. For efficiency, this function finds the size of the file and reserves space in the string before pulling in the content.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>of the file. </td></tr>
    <tr><td class="paramname">s</td><td>reference to the receiving string. </td></tr>
    <tr><td class="paramname">readstate</td><td>returns the iostate flags when provided (default: nullptr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the read into string was successful. </dd></dl>

</div>
</div>
<a id="ac5e9d57226726175af8c8e276edd0c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e9d57226726175af8c8e276edd0c58">&#9670;&nbsp;</a></span>get_DIL_entry_num_superiors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fz::get_DIL_entry_num_superiors </td>
          <td>(</td>
          <td class="paramtype">DIL_entry *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of connections from a DIL entry to Superiors. </p>
<p>Note: Perhaps this function belongs in the utilities.cc library of dil2al.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>pointer to DIL_entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count of number of connections to Superiors. </dd></dl>

</div>
</div>
<a id="aa7838e7b982bd5a885f69f42a8fa929c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7838e7b982bd5a885f69f42a8fa929c">&#9670;&nbsp;</a></span>get_DIL_Graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Detailed_Items_List * fz::get_DIL_Graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To USE and COMPILE : </p>
<p>Load the whole Detailed_Items_List and return a pointer to its data structure.</p>
<ol type="1">
<li>The up-to-date dil2al.hh header file must be on the include path, e.g. by adding -I/home/randalk/src/dil2al.</li>
<li>The necessary functions that are declared there must be compiled in up-to-date object files made accessible, e.g. by adding them in dependencies and in the build command.</li>
</ol>
<p>For an example, see the Makefile of formalizer/tools/dil2graph.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to Detailed_Items_List object, or NULL if unsuccessful. </dd></dl>

</div>
</div>
<a id="a02517c2cf1052f55bb388a0808fdaa1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02517c2cf1052f55bb388a0808fdaa1b">&#9670;&nbsp;</a></span>get_DIL_hierarchy_num_connections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fz::get_DIL_hierarchy_num_connections </td>
          <td>(</td>
          <td class="paramtype">Detailed_Items_List *&#160;</td>
          <td class="paramname"><em>dil</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of connections in a DIL hierarchy. </p>
<p>Note: Perhaps this function belongs in the utilties.cc library of dil2al.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dil</td><td>pointer to DIL hierarchy (Detailed_Items_List). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count of total number of connections in the hierarchy. </dd></dl>

</div>
</div>
<a id="a004bd737f1c412b124eaf7ca6df90603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004bd737f1c412b124eaf7ca6df90603">&#9670;&nbsp;</a></span>get_DIL_Topics_File_List()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; fz::get_DIL_Topics_File_List </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the actual set of Topical DIL Files that exist in the dil2al base directory. </p>
<p>This function requires that <code>basedir</code> is valid, otherwise the <a class="el" href="namespacefz.html#aa23b82243a12ae2b0d35ccb70d785857" title="Execute a shell command and retrieve the standard output as a string. ">shellcmd2str()</a> call will throw a runtime_error. This function does not distinguish between actual files and symlinks (see detect_DIL_Topics_Symlinks()).</p>
<p>Note: Perhaps this function belongs in the utilities.cc library of dil2al.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the absolute file name strings of each Topical DIL File. </dd></dl>

</div>
</div>
<a id="afe38748c6da4110ea71ee010642d3606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe38748c6da4110ea71ee010642d3606">&#9670;&nbsp;</a></span>get_Topic_pq_field_numbers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::get_Topic_pq_field_numbers </td>
          <td>(</td>
          <td class="paramtype">PGresult *&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve field column numbers for topics query to make sure the correct field numbers are used. </p>
<p>This is an extra safety measure in case formats are changed in the future and in case of potential database version mismatch.</p>
<p>This function updates the field numbers in pq_topic_field. The field names that this version assumes are in the variable pq_topic_fieldnames. The fields are enumerated with pq_Tfields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>a valid pointer obtained by PQgetResult(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all the field names were found. </dd></dl>

</div>
</div>
<a id="a569da80848b8001bc12867337f51d1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569da80848b8001bc12867337f51d1c9">&#9670;&nbsp;</a></span>identical_Graphs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::identical_Graphs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>trace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two Graphs to report if they are data-identical. </p>
<p>friend (utility) functions</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph1</td><td>the first <a class="el" href="classfz_1_1Graph.html">Graph</a>. </td></tr>
    <tr><td class="paramname">graph2</td><td>the second <a class="el" href="classfz_1_1Graph.html">Graph</a>. </td></tr>
    <tr><td class="paramname">trace</td><td>if a difference is found then this contains a trace. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two Graphs are equivalent. </dd></dl>

</div>
</div>
<a id="a96f4dc710aff55f6fd9c2e111d7df259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f4dc710aff55f6fd9c2e111d7df259">&#9670;&nbsp;</a></span>identical_Nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::identical_Nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>trace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if two <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> objects contain the same data. </p>
<p>Note that this does not compare the rapid-access Edges_Set supedges and depedges, since they are sets of pointers created as <a class="el" href="classfz_1_1Graph.html">Graph</a> Edges are added. They might end up in a different order, but they ought to be the same ones as in the Edge_Map. </p>

</div>
</div>
<a id="a30be49d20ac6c8ba1b313fc295a235a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30be49d20ac6c8ba1b313fc295a235a2">&#9670;&nbsp;</a></span>is_leapyear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::is_leapyear </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>year</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A simple leap year test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">year</td><td>the year. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it is a leap year. </dd></dl>

</div>
</div>
<a id="add2e1a49e1871f23c757c97c84484676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add2e1a49e1871f23c757c97c84484676">&#9670;&nbsp;</a></span>keyrel_from_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structfz_1_1Topic__Keyword.html">Topic_Keyword</a>&gt; fz::keyrel_from_pq </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>keywordstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>relevancestr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert textual arrays of keywords and keyword-relevance values to a vector of <a class="el" href="structfz_1_1Topic__Keyword.html" title="Type for real-valued Keyword relevance (to Topic), presently assumed to be in the interval [0...">Topic_Keyword</a> pairs. </p>
<p>Keywords are allowed to contain more than one word, separated by spaces. This function strips away the front and back double-quotes that the PGgetvalue() function returns around such composite keywords.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keywordstr</td><td>string containing the textual array of keywords. </td></tr>
    <tr><td class="paramname">relevancestr</td><td>string containing the textual array of relevance values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of <a class="el" href="structfz_1_1Topic__Keyword.html" title="Type for real-valued Keyword relevance (to Topic), presently assumed to be in the interval [0...">Topic_Keyword</a> pairs of (keyword,relevance). </dd></dl>

</div>
</div>
<a id="aef824584d56abd3b06028a3925a9541c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef824584d56abd3b06028a3925a9541c">&#9670;&nbsp;</a></span>load_Edge_parameter_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; fz::load_Edge_parameter_interval </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pq_Efields&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>from_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>num_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load specific <a class="el" href="classfz_1_1Edge.html">Edge</a> parameter column interval from PostgreSQL database. </p>
<p>This interface attempts to hide as much as possible about the Postgres specifics of the operation, in order to preserve a Formalizer database access protocol across different possible underlying database choices.</p>
<p>Note: For this reason, the lowest possible interval start is 0 (not 1, as per SQL row numbering convention).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dbname</td><td>the Postgres database. </td></tr>
    <tr><td class="paramname">schemaname</td><td>the Formalizer schema name (usually provided by Graph_access::pq_schemaname) </td></tr>
    <tr><td class="paramname">param</td><td>the enumerated parameter identifier. </td></tr>
    <tr><td class="paramname">from_row</td><td>the first row in the interval, counting from 0. </td></tr>
    <tr><td class="paramname">num_rows</td><td>the number of rows in the intervial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector with string elements, one for each row. </dd></dl>

</div>
</div>
<a id="a615c9833189de86268653cf1fc95f092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615c9833189de86268653cf1fc95f092">&#9670;&nbsp;</a></span>load_Graph_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::load_Graph_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load all the Nodes, Edges and Topics of the <a class="el" href="classfz_1_1Graph.html">Graph</a> from the PostgreSQL database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>a <a class="el" href="classfz_1_1Graph.html">Graph</a> for the Nodes and Edges, etc, typically empty. </td></tr>
    <tr><td class="paramname">dbname</td><td>database name. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classfz_1_1Graph.html">Graph</a> was successfully loaded from the database. </dd></dl>

</div>
</div>
<a id="ad24f78e052197d9844de69ba284cfade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24f78e052197d9844de69ba284cfade">&#9670;&nbsp;</a></span>load_Node_parameter_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; fz::load_Node_parameter_interval </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pq_Nfields&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>from_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>num_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load specific <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> parameter column interval from PostgreSQL database. </p>
<p>This interface attempts to hide as much as possible about the Postgres specifics of the operation, in order to preserve a Formalizer database access protocol across different possible underlying database choices.</p>
<p>Note: For this reason, the lowest possible interval start is 0 (not 1, as per SQL row numbering convention).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dbname</td><td>the Postgres database. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
    <tr><td class="paramname">param</td><td>the enumerated parameter identifier. </td></tr>
    <tr><td class="paramname">from_row</td><td>the first row in the interval, counting from 0. </td></tr>
    <tr><td class="paramname">num_rows</td><td>the number of rows in the intervial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector with string elements, one for each row. </dd></dl>

</div>
</div>
<a id="ab99ee1f9eb33cd43975a1e2ba185affc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99ee1f9eb33cd43975a1e2ba185affc">&#9670;&nbsp;</a></span>Log_span_in_days()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double fz::Log_span_in_days </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report the span in days from when the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was started (first cunk) to its most recent chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> for which to report the span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the decimal number of days. </dd></dl>

</div>
</div>
<a id="a99de56e900ef8f39ac539d88521905ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99de56e900ef8f39ac539d88521905ab">&#9670;&nbsp;</a></span>Log_span_in_seconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long fz::Log_span_in_seconds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report the span in seconds from when the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was started (first cunk) to its most recent chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> for which to report the span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of seconds. </dd></dl>

</div>
</div>
<a id="ac852c19de9635df74fca9eab2d419e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac852c19de9635df74fca9eab2d419e5b">&#9670;&nbsp;</a></span>Log_span_years_months_days()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ymd_tuple fz::Log_span_years_months_days </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report the span in years, months and days from when the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was started (first cunk) to its most recent chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> for which to report the span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple of [year, month, day]. </dd></dl>

</div>
</div>
<a id="a7f17dcd15946bcb9a7fd70bf65e6fcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f17dcd15946bcb9a7fd70bf65e6fcc9">&#9670;&nbsp;</a></span>ltrim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; fz::ltrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>t</em> = <code>&quot;&#160;\t\n\r\f\v&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim whitespace from the front of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a string. </td></tr>
    <tr><td class="paramname">t</td><td>a string containing whitespace characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the trimmed string. </dd></dl>

</div>
</div>
<a id="af70525212cc7a8fff346a1540c8c8f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70525212cc7a8fff346a1540c8c8f8a">&#9670;&nbsp;</a></span>main_topic() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfz_1_1Topic.html">Topic</a>* fz::main_topic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Topic__Tags.html">Topic_Tags</a> &amp;&#160;</td>
          <td class="paramname"><em>topictags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the main <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> of a <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a>, as indicated by the maximum Topic_Relevance value. </p>
<p>friend (utility) functions</p>
<p>Note: This is a friend function in order to ensure that the search for the <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> object is called only when a valid <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, indexed by Topic ID. ">Topic_Tags</a> list can provid pointers to them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, indexed by Topic ID. ">Topic_Tags</a></td><td>a valid <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, indexed by Topic ID. ">Topic_Tags</a> list. </td></tr>
    <tr><td class="paramname">node</td><td>a <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> for which the main <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> object (or nullptr if not found). </dd></dl>

</div>
</div>
<a id="a302a9b232573c36c992a057ff655cad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302a9b232573c36c992a057ff655cad7">&#9670;&nbsp;</a></span>main_topic() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfz_1_1Topic.html">Topic</a>* fz::main_topic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the main <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> of a <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a>, as indicated by the maximum Topic_Relevance value. </p>
<p>Note: This is a friend function in order to ensure that the search for the <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> object is called only when a valid <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, indexed by Topic ID. ">Topic_Tags</a> list that is known to a valid <a class="el" href="classfz_1_1Graph.html">Graph</a> can provid pointers to them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_graph</td><td>a valid <a class="el" href="classfz_1_1Graph.html">Graph</a> that has a <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, indexed by Topic ID. ">Topic_Tags</a> list. </td></tr>
    <tr><td class="paramname">node</td><td>a <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> for which the main <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> object (or nullptr if not found). </dd></dl>

</div>
</div>
<a id="af542142d941cd3b6ed66b5b6ed7bc181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af542142d941cd3b6ed66b5b6ed7bc181">&#9670;&nbsp;</a></span>main_topic() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfz_1_1Topic.html">Topic</a>* fz::main_topic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &amp;&#160;</td>
          <td class="paramname"><em>chunk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the main <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> of a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk's <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a>, as indicated by the maximum Topic_Relevance value. </p>
<p>friend (utility) functions</p>
<p>Note: This is a friend function in order to ensure that the search for the <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> object is called only when a valid <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, indexed by Topic ID. ">Topic_Tags</a> list can provid pointers to them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_graph</td><td>a valid <a class="el" href="classfz_1_1Graph.html">Graph</a> with <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, indexed by Topic ID. ">Topic_Tags</a> list. </td></tr>
    <tr><td class="paramname">chunk</td><td>a <a class="el" href="classfz_1_1Log__chunk.html" title="Specifies the start time, Node, close time, and set of entries of a Log chunk. ">Log_chunk</a> for which the main <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="classfz_1_1Topic.html" title="Type for real-valued Topic relevance (of Node), presently assumed to be in the interval [0...">Topic</a> object (or nullptr if not found). </dd></dl>

</div>
</div>
<a id="a7d24b6e4b1323e5d5687d184aa48fb4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d24b6e4b1323e5d5687d184aa48fb4a">&#9670;&nbsp;</a></span>query_call_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::query_call_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>qstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>request_single_row_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch a Postgres query for asynchronous processing in batch or single row mode. </p>
<p>Uses PQsendQuery() and PQsetSingleRowMode().</p>
<p>To receive results, use PQgetResult(), calling that function repeatedly if in single row mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>a valid Postgres connection object. </td></tr>
    <tr><td class="paramname">qstr</td><td>a Postgres query string. </td></tr>
    <tr><td class="paramname">request_single_row_mode</td><td>switches only this query to single row mode if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the query was successfully dispatched. </dd></dl>

</div>
</div>
<a id="a8f1cf55c9ed8689f087102061c60154a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1cf55c9ed8689f087102061c60154a">&#9670;&nbsp;</a></span>rtrim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; fz::rtrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>t</em> = <code>&quot;&#160;\t\n\r\f\v&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim whitespace from the end of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a string. </td></tr>
    <tr><td class="paramname">t</td><td>a string containing whitespace characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the trimmed string. </dd></dl>

</div>
</div>
<a id="a4a72c04fc5a7860678e9156bd32b5aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a72c04fc5a7860678e9156bd32b5aa1">&#9670;&nbsp;</a></span>safe_cmdline_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, std::string &gt; fz::safe_cmdline_options </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>optindcopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The standard object for Formalizer programs. </p>
<p>Safer parsing of command line parameters.</p>
<p>This wrapper aims to reduce that ways in which parsing command line parameters can lead to segfaults. (The getopt() function is not very safe in that regard.)</p>
<p>Note: This wrapper does use getopt() and getopt() is known to modify argv. Therefore, if you need the original argv, copy it before calling this functions. For example, with <code>std::vector&lt;std::string&gt; cmdargs; for (int i = 0; i &lt; argc; ++i) cmdargs[i] = argv[i];</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>is the argc from main(). </td></tr>
    <tr><td class="paramname">argv</td><td>is the argv from main(). </td></tr>
    <tr><td class="paramname">options</td><td>is the options list in the same format as for getopt(). </td></tr>
    <tr><td class="paramname">optindcopy</td><td>is a variable reference that receives a copy of optind as used by getopt(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59b42530ac38402a5656af5bdcac5be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b42530ac38402a5656af5bdcac5be6">&#9670;&nbsp;</a></span>sample_query_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fz::sample_query_data </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>databufstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function that dumps several rows of data to a string buffer for easy inspection. </p>
<p>A <a class="el" href="namespacefz.html#a7d24b6e4b1323e5d5687d184aa48fb4a" title="Dispatch a Postgres query for asynchronous processing in batch or single row mode. ">query_call_pq()</a> or equivalent should precede this.</p>
<p>To sample all columns simple set cend &gt; number of columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>an active Postgres connection. </td></tr>
    <tr><td class="paramname">rstart</td><td>first row to sample. </td></tr>
    <tr><td class="paramname">rend</td><td>one after last row to sample. </td></tr>
    <tr><td class="paramname">cstart</td><td>first column to sample. </td></tr>
    <tr><td class="paramname">cend</td><td>one after last column to sample. </td></tr>
    <tr><td class="paramname">databufstr</td><td>a string buffer for sampled data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of rows sampled. </dd></dl>

</div>
</div>
<a id="aa23b82243a12ae2b0d35ccb70d785857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23b82243a12ae2b0d35ccb70d785857">&#9670;&nbsp;</a></span>shellcmd2str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::shellcmd2str </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a shell command and retrieve the standard output as a string. </p>
<p>Note that this function will throw a runtime_error if the command could not be executed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>the shell command to execute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing the standard output of the executed command. </dd></dl>

</div>
</div>
<a id="aa1a653de26479eb7d85b850ec2918c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a653de26479eb7d85b850ec2918c2a">&#9670;&nbsp;</a></span>simple_call_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::simple_call_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>astr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a simple action call to a Postgres database. </p>
<p>Note: If the global flag simulate_pq_changes==true then this function does not execute Postgres calls. Instead, the call string will be added to simulated_pq_calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>active database connection. </td></tr>
    <tr><td class="paramname">astr</td><td>action call string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if action call was successful. </dd></dl>

</div>
</div>
<a id="a45a30fb04b5721cd05047bd4088fb8b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a30fb04b5721cd05047bd4088fb8b0">&#9670;&nbsp;</a></span>split() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Out &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fz::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Out&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put pieces of a string into a pre-constructed vector. </p>
<p>See for example how this is used in the <a class="el" href="namespacefz.html#a45a30fb04b5721cd05047bd4088fb8b0" title="Put pieces of a string into a pre-constructed vector. ">split()</a> function below. Borrowed from: <a href="https://stackoverflow.com/questions/236129/how-do-i-iterate-over-the-words-of-a-string">https://stackoverflow.com/questions/236129/how-do-i-iterate-over-the-words-of-a-string</a> Note that this solution does not skip empty tokens, so the following will find 4 items, one of which is empty: std::vector&lt;std::string&gt; x = split("one:two::three", ':');</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a string. </td></tr>
    <tr><td class="paramname">delim</td><td>a delimiter character. </td></tr>
    <tr><td class="paramname">result</td><td>a std::back_insert_iterator for the result container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7dc083b5c0e84d7d715161e462a321f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7dc083b5c0e84d7d715161e462a321f">&#9670;&nbsp;</a></span>split() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; fz::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector containing pieces of a string. </p>
<p>This uses the <a class="el" href="namespacefz.html#a45a30fb04b5721cd05047bd4088fb8b0" title="Put pieces of a string into a pre-constructed vector. ">split()</a> template above. It lets you do things like pass the result directly to a function like this: f(split(s, d, v)) while still having the benefit of a pre-allocated vector if you like.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a string. </td></tr>
    <tr><td class="paramname">delim</td><td>a delimiter character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of strings. </dd></dl>

</div>
</div>
<a id="a1cb865200e35c530ff09a2a5c142c55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb865200e35c530ff09a2a5c142c55a">&#9670;&nbsp;</a></span>store_Graph_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::store_Graph_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(unsigned long, unsigned long)&#160;</td>
          <td class="paramname"><em>progress_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store all the Nodes and Edges of the <a class="el" href="classfz_1_1Graph.html">Graph</a> in the PostgreSQL database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>a <a class="el" href="classfz_1_1Graph.html">Graph</a> containing all of the Nodes and Edges. </td></tr>
    <tr><td class="paramname">dbname</td><td>database name. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
    <tr><td class="paramname">progress_func</td><td>points to an optional progress indicator function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classfz_1_1Graph.html">Graph</a> was successfully stored in the database. </dd></dl>

</div>
</div>
<a id="a3c32b58a7df84713dc2a5554fc25c0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c32b58a7df84713dc2a5554fc25c0b2">&#9670;&nbsp;</a></span>store_Guide_snippet_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::store_Guide_snippet_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Guide__snippet.html">Guide_snippet</a> &amp;&#160;</td>
          <td class="paramname"><em>snippet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a new Guide snippet in the PostgreSQL database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snippet</td><td>a guide snippet. </td></tr>
    <tr><td class="paramname">dbname</td><td>database name. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the snippet was successfully stored in the database. </dd></dl>

</div>
</div>
<a id="ae354d176f2f483264ec225411f7eb122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae354d176f2f483264ec225411f7eb122">&#9670;&nbsp;</a></span>stream_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::stream_to_string </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the full contents of a (text) stream into a string. </p>
<p>This implementation was tested to be faster than the one-liner implementations shown at <a href="https://stackoverflow.com/questions/3203452/how-to-read-entire-stream-into-a-stdstring,">https://stackoverflow.com/questions/3203452/how-to-read-entire-stream-into-a-stdstring,</a> at least as of Oct. 2011. It might be even faster to pre-allocate buffer space according to stream size, as per the example inhttp://www.cplusplus.com/reference/istream/istream/read/, but it isn't immediately clear to me if that also works with STDIN.</p>
<p>Note: This can be used with STDIN (<code>cin</code>) as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>is an open istream. </td></tr>
    <tr><td class="paramname">s</td><td>reference to the receiving string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the read into string was successful. </dd></dl>

</div>
</div>
<a id="a11e5fa50448d4b9ffb38afea0ae0ea1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e5fa50448d4b9ffb38afea0ae0ea1a">&#9670;&nbsp;</a></span>string_to_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::string_to_file </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream::iostate *&#160;</td>
          <td class="paramname"><em>writestate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the full contents of a string to a file. </p>
<p>Note that this function does NOT create a backup of a previous file at the given path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>of the file. </td></tr>
    <tr><td class="paramname">s</td><td>reference to the string. </td></tr>
    <tr><td class="paramname">writestate</td><td>returns the iostate flags when provided (default: nullptr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the write from string was successful. </dd></dl>

</div>
</div>
<a id="a82121e1189c46fe028b6b6e9a073c8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82121e1189c46fe028b6b6e9a073c8d5">&#9670;&nbsp;</a></span>string_to_file_with_backup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::string_to_file_with_backup </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>backupext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>backedup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream::iostate *&#160;</td>
          <td class="paramname"><em>writestate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the full contents of a string to a file, but move an existing file at the given path to a backup name first. </p>
<p>Note that TimeStamp:<a class="el" href="namespacefz.html#abe4308075d0f8dc4c0129d8ee71740e5" title="Generate a Formalizer standardized file backup extension (YYYYmmdd.bak). ">BackupStampYmd()</a> and TimeStamp:<a class="el" href="namespacefz.html#a4932c9514aab01039104a5b0033934d4" title="Generate a Formalizer standardized file backup precise extension (YYYYmmddHHMM.bak). ">BackupStampYmdHM()</a> provide valid Formalizer standardized backup extension tags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>of the file. </td></tr>
    <tr><td class="paramname">s</td><td>reference to the string. </td></tr>
    <tr><td class="paramname">backupext</td><td>is the extension to use for a potential backup of existing. </td></tr>
    <tr><td class="paramname">backedup</td><td>stores a flag to indicate is an existing file was renamed to a backup. </td></tr>
    <tr><td class="paramname">writestate</td><td>returns the iostate flags when provided (default: nullptr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the write from string was successful. </dd></dl>

</div>
</div>
<a id="a38fbfbcaecf4e5f56afa2956d83ba595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38fbfbcaecf4e5f56afa2956d83ba595">&#9670;&nbsp;</a></span>targetdate_from_timestamp_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t fz::targetdate_from_timestamp_pq </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pqtimestamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert Postgres query result time stamp strings to Unix time for <a class="el" href="classfz_1_1Node.html" title="(A woefully incomplete class documentation.) ">Node</a> target date parameter. </p>
<p>The format returned by PQgetvalue() is '2015-01-03 16:00:00'. As long as DATESTYLE has not been altered (e.g. with 'set datestyle to DMY'), the standard ISO format is YMD. It might be best to confirm that. Empty or 'infinity' (or other non-numerical time stamps) are interpreted as unspecified, for which -1 is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pqtimestamp</td><td>a time stamp string obtained via PQgetvalue(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unix time stamp as seconds since 00:00:00 UTC, January 1, 1970 or -1 when unspecified or invalid format. </dd></dl>

</div>
</div>
<a id="a29d90c0e807ecdc776567257c7ba93b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d90c0e807ecdc776567257c7ba93b9">&#9670;&nbsp;</a></span>time_stamp_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t fz::time_stamp_time </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>timestr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noerror</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a Formalizer time stamp string into local Unix time. </p>
<p>Formalizer time stamp strings must have this format: 1) [^0-9]YYYYmmddHHMM (e.g. "202008140613", "__202109150714"), and, 2) the year must be &gt;= 1900, or, 3) a negative integer code (e.g. "-2").</p>
<p>Negative integer codes are returned the equivalent negative integer so that special codes can be detected.</p>
<p>Non-digit characters preceding the digits of a proper time stamp are ignored and discarded. (This does not apply to negative integer codes.)</p>
<p>When the 'noerror' flag is set then no error message will be added if an invalid time stamp is encountered. This can be useful when this function is explicitly used to check for empty/unfinished/etc time stamps.</p>
<p>The 1900 test is a useful sanity check, because mangled time stamp strings can often lead to unlikely dates preceding the computing era.</p>
<p>This function is derived from dil2al/utilities.cc:<a class="el" href="namespacefz.html#a29d90c0e807ecdc776567257c7ba93b9" title="Convert a Formalizer time stamp string into local Unix time. ">time_stamp_time()</a>. Unlike that function, this one does not terminate the program when an invalid time stamp is encountered and uses no configuration flag to elicit such behavior. Instead, the special code INVALID_TIME_STAMP is returned in that case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestr</td><td>a string containing the Formalizer time stamp. </td></tr>
    <tr><td class="paramname">noerror</td><td>suppresses ADDERROR() for invalid time stamps. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>local Unix time in seconds, negative integer code, or INVALID_TIME_STAMP. </dd></dl>

</div>
</div>
<a id="a31c5acaefdebe1051c4ff921bc754e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c5acaefdebe1051c4ff921bc754e68">&#9670;&nbsp;</a></span>TimeStamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::TimeStamp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dateformat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate time stamp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dateformat</td><td>a date and time format specifier, e.g. "%Y%m%d%H%M". </td></tr>
    <tr><td class="paramname">t</td><td>a date and time expressed in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The time stamp string. Returns an empty string if t&lt;0. </dd></dl>

</div>
</div>
<a id="a53786005231752fd441f9114609caec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53786005231752fd441f9114609caec7">&#9670;&nbsp;</a></span>to_precision_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::to_precision_string </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print double to string with specific precision. </p>
<p>Note: Perhaps this should be moved to general utility functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a real number. </td></tr>
    <tr><td class="paramname">p</td><td>precision (default 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string. </dd></dl>

</div>
</div>
<a id="acff76817b33dcd0a0c38c28e238ad2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff76817b33dcd0a0c38c28e238ad2d3">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; fz::trim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>t</em> = <code>&quot;&#160;\t\n\r\f\v&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim whitespace on both ends of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a string. </td></tr>
    <tr><td class="paramname">t</td><td>a string containing whitespace characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the trimmed string. </dd></dl>

</div>
</div>
<a id="a045ec1abb4dc382e0b56e345c146de95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045ec1abb4dc382e0b56e345c146de95">&#9670;&nbsp;</a></span>valid_Log_chunk_ID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_Log_chunk_ID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> &amp;&#160;</td>
          <td class="paramname"><em>idT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>formerror</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a <a class="el" href="structfz_1_1Log__TimeStamp.html" title="Timestamp IDs in the format required for Log IDs. ">Log_TimeStamp</a> can be used as a valid <a class="el" href="classfz_1_1Log__chunk__ID.html">Log_chunk_ID</a>. </p>
<p>Note that years before 1999 are disqualified, since the Formalizer did not exist before then.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idT</td><td>reference to an <a class="el" href="structfz_1_1Log__TimeStamp.html" title="Timestamp IDs in the format required for Log IDs. ">Log_TimeStamp</a> object. </td></tr>
    <tr><td class="paramname">formerror</td><td>a string that collects specific error information if there is any. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

</div>
</div>
<a id="a957bdd835342852a8ef5ad94723e34cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a957bdd835342852a8ef5ad94723e34cf">&#9670;&nbsp;</a></span>valid_Log_chunk_ID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_Log_chunk_ID </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>formerror</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> *&#160;</td>
          <td class="paramname"><em>id_timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a string can be used to form a valid <a class="el" href="classfz_1_1Log__chunk__ID.html">Log_chunk_ID</a>. </p>
<p>Checks string length, all digits in time stamp, and time stamp components within valid ranges. Note that years before 1999 are disqualified, since the Formalizer did not exist before then.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_str</td><td>a string of the format YYYYmmddHHMM. </td></tr>
    <tr><td class="paramname">formerror</td><td>a string that collects specific error information if there is any. </td></tr>
    <tr><td class="paramname">id_timestamp</td><td>if not NULL, receives valid components. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

</div>
</div>
<a id="a61ced31e8ffbaf54c00a9f586eaf1dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ced31e8ffbaf54c00a9f586eaf1dd4">&#9670;&nbsp;</a></span>valid_Log_entry_ID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_Log_entry_ID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> &amp;&#160;</td>
          <td class="paramname"><em>idT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>formerror</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a <a class="el" href="structfz_1_1Log__TimeStamp.html" title="Timestamp IDs in the format required for Log IDs. ">Log_TimeStamp</a> can be used as a valid <a class="el" href="classfz_1_1Log__entry__ID.html">Log_entry_ID</a>. </p>
<p>Note that years before 1999 are disqualified, since the Formalizer did not exist before then.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idT</td><td>reference to an <a class="el" href="structfz_1_1Log__TimeStamp.html" title="Timestamp IDs in the format required for Log IDs. ">Log_TimeStamp</a> object. </td></tr>
    <tr><td class="paramname">formerror</td><td>a string that collects specific error information if there is any. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

</div>
</div>
<a id="a8c0d31396e23ba90447163d6b714f1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c0d31396e23ba90447163d6b714f1d5">&#9670;&nbsp;</a></span>valid_Log_entry_ID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_Log_entry_ID </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>formerror</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> *&#160;</td>
          <td class="paramname"><em>id_timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a string can be used to form a valid <a class="el" href="classfz_1_1Log__entry__ID.html">Log_entry_ID</a>. </p>
<p>Checks string length, period separating time stamp from minor ID, all digits in time stamp and minor ID, and time stamp components within valid ranges. Note that years before 1999 are disqualified, since the Formalizer did not exist before then.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_str</td><td>a string of the format YYYYmmddHHMM.num. </td></tr>
    <tr><td class="paramname">formerror</td><td>a string that collects specific error information if there is any. </td></tr>
    <tr><td class="paramname">id_timestamp</td><td>if not NULL, receives valid components. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

</div>
</div>
<a id="aba0e4f3360d11eff1bf1b4553a451180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0e4f3360d11eff1bf1b4553a451180">&#9670;&nbsp;</a></span>valid_Node_ID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_Node_ID </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>formerror</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1ID__TimeStamp.html">ID_TimeStamp</a> *&#160;</td>
          <td class="paramname"><em>id_timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a string can be used to form a valid <a class="el" href="classfz_1_1Node__ID.html" title="Node ID that caches its ID stamp for frequent use. ">Node_ID</a>. </p>
<p>Checks string length, period separating time stamp from minor ID, all digits in time stamp and minor ID, and time stamp components within valid ranges. Note that years before 1999 are disqualified, since the Formalizer did not exist before then.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_str</td><td>a string of the format YYYYmmddHHMMSS.num. </td></tr>
    <tr><td class="paramname">formerror</td><td>a string that collects specific error information if there is any. </td></tr>
    <tr><td class="paramname">id_timestamp</td><td>if not NULL, receives valid components. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

</div>
</div>
<a id="a0c4260c6b3087bdf22ce089216638d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4260c6b3087bdf22ce089216638d79">&#9670;&nbsp;</a></span>valid_Node_ID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_Node_ID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1ID__TimeStamp.html">ID_TimeStamp</a> &amp;&#160;</td>
          <td class="paramname"><em>idT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>formerror</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a <a class="el" href="structfz_1_1ID__TimeStamp.html" title="Timestamp IDs in the format required for Node IDs. ">ID_TimeStamp</a> can be used as a valid <a class="el" href="classfz_1_1Node__ID.html" title="Node ID that caches its ID stamp for frequent use. ">Node_ID</a>. </p>
<p>Note that years before 1999 are disqualified, since the Formalizer did not exist before then.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idT</td><td>reference to an <a class="el" href="structfz_1_1ID__TimeStamp.html" title="Timestamp IDs in the format required for Node IDs. ">ID_TimeStamp</a> object. </td></tr>
    <tr><td class="paramname">formerror</td><td>a string that collects specific error information if there is any. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

</div>
</div>
<a id="af320a36d5d2f05de32419ea52f625e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af320a36d5d2f05de32419ea52f625e1e">&#9670;&nbsp;</a></span>valid_year_month_day()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_year_month_day </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a>&#160;</td>
          <td class="paramname"><em>ymd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a year, month and day form a valid date. </p>
<p>The rules are: 1800 &lt;= year &lt;= 9999 1 &lt;= month &lt;= 12 1 &lt;= day &lt;= max_days_in(month)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ymd</td><td>a tuple of year, month, day numbers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the date is valid. </dd></dl>

</div>
</div>
<a id="a053fc7625765a11b31ee3604a1f225b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053fc7625765a11b31ee3604a1f225b0">&#9670;&nbsp;</a></span>years_months_days()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a> fz::years_months_days </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a>&#160;</td>
          <td class="paramname"><em>ymd1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a>&#160;</td>
          <td class="paramname"><em>ymd2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Express the difference between two dates in terms of the number of Years, Months and Days between them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ymd1</td><td>an earlier year, month, day tuple. </td></tr>
    <tr><td class="paramname">ymd2</td><td>a later year, month, day tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple with the number of years, months and days between them. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aeab0d860bf18ea1cc2acb7577f4f294f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab0d860bf18ea1cc2acb7577f4f294f">&#9670;&nbsp;</a></span>maintime</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfz_1_1ReferenceTime.html">ReferenceTime</a> fz::maintime</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Every program that uses core Formalizer functions that depend on time stamping includes <a class="el" href="ReferenceTime_8hpp_source.html">ReferenceTime.hpp</a> (it is automatically included through <a class="el" href="TimeStamp_8hpp_source.html">TimeStamp.hpp</a>). </p>
<p>The <code>maintime</code> object that is defined here provides time status for the main scope of the program. Additioan <a class="el" href="classfz_1_1ReferenceTime.html">ReferenceTime</a> objects can be created as needed. </p>

</div>
</div>
<a id="a593c105236196b2da156f585c6d7ae30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593c105236196b2da156f585c6d7ae30">&#9670;&nbsp;</a></span>pq_edge_fieldnames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::pq_edge_fieldnames[_pqe_NUM]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&quot;id&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;dependency&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;significance&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;importance&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;urgency&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;priority&quot;</span>}</div></div><!-- fragment -->
</div>
</div>
<a id="a4e2e72b75f6a44514c6175b6dd58988c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2e72b75f6a44514c6175b6dd58988c">&#9670;&nbsp;</a></span>pq_node_fieldnames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::pq_node_fieldnames[_pqn_NUM]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&quot;id&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;topics&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;topicrelevance&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;valuation&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;completion&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;required&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;text&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;targetdate&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;tdproperty&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;isperiodic&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;tdperiodic&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;tdevery&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;tdspan&quot;</span>}</div></div><!-- fragment -->
</div>
</div>
<a id="a0e9f249ab6da4a5330fbf47805b36b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9f249ab6da4a5330fbf47805b36b49">&#9670;&nbsp;</a></span>pq_topic_fieldnames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::pq_topic_fieldnames[_pqt_NUM]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&quot;id&quot;</span>,</div><div class="line">                                                   <span class="stringliteral">&quot;supid&quot;</span>,</div><div class="line">                                                   <span class="stringliteral">&quot;tag&quot;</span>,</div><div class="line">                                                   <span class="stringliteral">&quot;title&quot;</span>,</div><div class="line">                                                   <span class="stringliteral">&quot;keyword&quot;</span>,</div><div class="line">                                                   <span class="stringliteral">&quot;relevance&quot;</span>}</div></div><!-- fragment -->
</div>
</div>
<a id="a64dd91504fdcea08cc7617a5314ec6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64dd91504fdcea08cc7617a5314ec6d2">&#9670;&nbsp;</a></span>td_pattern_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::td_pattern_str</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=  {<span class="stringliteral">&quot;patt_daily&quot;</span>,</div><div class="line">                                                <span class="stringliteral">&quot;patt_workdays&quot;</span>,</div><div class="line">                                                <span class="stringliteral">&quot;patt_weekly&quot;</span>,</div><div class="line">                                                <span class="stringliteral">&quot;patt_biweekly&quot;</span>,</div><div class="line">                                                <span class="stringliteral">&quot;patt_monthly&quot;</span>,</div><div class="line">                                                <span class="stringliteral">&quot;patt_endofmonthoffset&quot;</span>,</div><div class="line">                                                <span class="stringliteral">&quot;patt_yearly&quot;</span>,</div><div class="line">                                                <span class="stringliteral">&quot;OLD_patt_span&quot;</span>,</div><div class="line">                                                <span class="stringliteral">&quot;patt_nonperiodic&quot;</span>}</div></div><!-- fragment -->
</div>
</div>
<a id="a5946fa5b803240f1c0cd734f214c8c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5946fa5b803240f1c0cd734f214c8c15">&#9670;&nbsp;</a></span>td_property_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::td_property_str</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&quot;unspecified&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;inherit&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;variable&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;fixed&quot;</span>,</div><div class="line">                                                  <span class="stringliteral">&quot;exact&quot;</span>}</div></div><!-- fragment -->
</div>
</div>
<a id="ab47d47929bea0b332de69408d4880092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47d47929bea0b332de69408d4880092">&#9670;&nbsp;</a></span>tdpatt_by_pqtdpatt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, td_pattern&gt; fz::tdpatt_by_pqtdpatt</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {{<span class="stringliteral">&quot;patt_daily&quot;</span>,td_pattern::patt_daily},</div><div class="line">                                                              {<span class="stringliteral">&quot;patt_workdays&quot;</span>,td_pattern::patt_workdays},</div><div class="line">                                                              {<span class="stringliteral">&quot;patt_weekly&quot;</span>,td_pattern::patt_weekly},</div><div class="line">                                                              {<span class="stringliteral">&quot;patt_biweekly&quot;</span>,td_pattern::patt_biweekly},</div><div class="line">                                                              {<span class="stringliteral">&quot;patt_monthly&quot;</span>,td_pattern::patt_monthly},</div><div class="line">                                                              {<span class="stringliteral">&quot;patt_endofmonthoffset&quot;</span>,td_pattern::patt_endofmonthoffset},</div><div class="line">                                                              {<span class="stringliteral">&quot;patt_yearly&quot;</span>,td_pattern::patt_yearly},</div><div class="line">                                                              {<span class="stringliteral">&quot;OLD_patt_span&quot;</span>,td_pattern::OLD_patt_span},</div><div class="line">                                                              {<span class="stringliteral">&quot;patt_nonperiodic&quot;</span>,td_pattern::patt_nonperiodic}}</div></div><!-- fragment -->
</div>
</div>
<a id="acd3867ed7aa9968c6dc3743c08621727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3867ed7aa9968c6dc3743c08621727">&#9670;&nbsp;</a></span>tdprop_by_pqtdprop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, <a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">td_property</a>&gt; fz::tdprop_by_pqtdprop</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {{<span class="stringliteral">&quot;unspecified&quot;</span>, td_property::unspecified},</div><div class="line">                                                               {<span class="stringliteral">&quot;inherit&quot;</span>, td_property::inherit},</div><div class="line">                                                               {<span class="stringliteral">&quot;variable&quot;</span>, td_property::variable},</div><div class="line">                                                               {<span class="stringliteral">&quot;fixed&quot;</span>, td_property::fixed},</div><div class="line">                                                               {<span class="stringliteral">&quot;exact&quot;</span>, td_property::exact}}</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
