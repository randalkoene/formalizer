<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Formalizer: fz Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="formalizer-logo-20200907-41x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Formalizer
   &#160;<span id="projectnumber">2.0.0-0.1</span>
   </div>
   <div id="projectbrief">The Formalizer System Support Environment</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">fz Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>On Ubuntu, to install the libpq libraries, including the libpq-fe.h header file, do: sudo apt-get install libpq-dev You may also have to add /usr/include or /usr/include/postgresql to the CPATH or to the includes in the Makefile, e.g.  
<a href="namespacefz.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1uninitialized__char.html">uninitialized_char</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1uninitialized__buffer.html">uninitialized_buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1CGI__Token__Values.html">CGI_Token_Values</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find GET or POST token-value pairs and make them available as maps.  <a href="structfz_1_1CGI__Token__Values.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1configbase.html">configbase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base component for Formalizer configuration file configuration parameter loading and parsing.  <a href="classfz_1_1configbase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1configurable.html">configurable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formalizer standard programs that can use configuration files should include a class that inherits <code>configurable</code> and that provides method implementation for <code><a class="el" href="classfz_1_1configbase.html#ab54418af1a3fd4f99c9433fa76760912" title="This method must be defined in configurable Formalizer components and programs that define a class in...">set_parameter()</a></code>.  <a href="classfz_1_1configurable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1DataCell.html">DataCell</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1DataColumns.html">DataColumns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1DataSheet.html">DataSheet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Debug__LogFile.html">Debug_LogFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantly flushing debug logging to a file.  <a href="classfz_1_1Debug__LogFile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Error__Instance.html">Error_Instance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Stack__Tracer.html">Stack_Tracer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used to collaboratively maintain a stack trace for use in both logged errors and exception handling.  <a href="structfz_1_1Stack__Tracer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Trace__This.html">Trace_This</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1err__configbase.html">err_configbase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Errors.html">Errors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintain a queue of recent errors encountered in ErrQ and provide them on demand.  <a href="classfz_1_1Errors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Simulate__PQ__Changes.html">Simulate_PQ_Changes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simulation class that enables Postgres call testing.  <a href="classfz_1_1Simulate__PQ__Changes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1active__pq.html">active_pq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Communication info for active database connection and specified schema.  <a href="structfz_1_1active__pq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1fzpq__configurable.html">fzpq_configurable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A standardized way to access the Formalizer database.  <a href="structfz_1_1Postgres__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Graph__access.html">Graph_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A standardized way to access the <a class="el" href="classfz_1_1Graph.html">Graph</a> database.  <a href="structfz_1_1Graph__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1NoGraph__exception.html">NoGraph_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when a resident <a class="el" href="classfz_1_1Graph.html">Graph</a> is missing and.  <a href="classfz_1_1NoGraph__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1ID__exception.html">ID_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> ID is of invalid form.  <a href="classfz_1_1ID__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1ID__TimeStamp.html">ID_TimeStamp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timestamp IDs in the format required for <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> IDs.  <a href="structfz_1_1ID__TimeStamp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standardized Formalizer <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> ID key.  <a href="structfz_1_1Node__ID__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Edge__ID__key.html">Edge_ID_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standardized Formalizer <a class="el" href="classfz_1_1Edge.html">Edge</a> ID key.  <a href="structfz_1_1Edge__ID__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Edit__flags.html">Edit_flags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bitmask of flags for the data components of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>.  <a href="classfz_1_1Edit__flags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1tdproperty__binary__pattern.html">tdproperty_binary_pattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Node__data.html">Node_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">On-heap data structure used to specify values for data components of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>.  <a href="structfz_1_1Node__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Edge__data.html">Edge_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">On-heap data structure used to specify values for data components of an <a class="el" href="classfz_1_1Edge.html">Edge</a>.  <a href="structfz_1_1Edge__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Nodes__Stats.html">Nodes_Stats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Node__Branch.html">Node_Branch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Node__Subtree.html">Node_Subtree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Map__of__Subtrees.html">Map_of_Subtrees</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">See how this is used in fzgraphhtml and nodeboard.  <a href="classfz_1_1Map__of__Subtrees.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Prerequisite.html">Prerequisite</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Node__Filter.html">Node_Filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter class that helps construct filter specifications.  <a href="structfz_1_1Node__Filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Set__builder__data.html">Set_builder_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure that specifies <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> grouping categories.  <a href="structfz_1_1Set__builder__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Byte__Map.html">Byte_Map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Graphmod__error.html">Graphmod_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the data structure used by the server to return information about the error that caused a <a class="el" href="classfz_1_1Graph.html">Graph</a> modification request stack to be rejected.  <a href="structfz_1_1Graphmod__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Graphmod__result.html">Graphmod_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the data structure used by the server to return information about the successful results of a <a class="el" href="classfz_1_1Graph.html">Graph</a> modification request.  <a href="structfz_1_1Graphmod__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Graphmod__results.html">Graphmod_results</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the results object that manages the collection of results for all requests on the stack.  <a href="structfz_1_1Graphmod__results.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Graphmod__unshared__results.html">Graphmod_unshared_results</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1TD__Node__shm.html">TD_Node_shm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Batchmod__targetdates.html">Batchmod_targetdates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Batchmod__tpass.html">Batchmod_tpass</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Graphmod__data.html">Graphmod_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the data structure used for elements of the request stack for <a class="el" href="classfz_1_1Graph.html">Graph</a> modification.  <a href="structfz_1_1Graphmod__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Graph__modifications.html">Graph_modifications</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This data structure is the most efficient method to request a stack of <a class="el" href="classfz_1_1Graph.html">Graph</a> modifications.  <a href="classfz_1_1Graph__modifications.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Topic__pq.html">Topic_pq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data types conversion helper class that can deliver the Postgres Topics table equivalent INSERT value expression for all data content in a <a class="el" href="classfz_1_1Topic.html">Topic</a>.  <a href="classfz_1_1Topic__pq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Node__pq.html">Node_pq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data types conversion helper class that can deliver the Postgres <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> table equivalent INSERT value expression for all data content in a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>.  <a href="classfz_1_1Node__pq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Edge__pq.html">Edge_pq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data types conversion helper class that can deliver the Postgres <a class="el" href="classfz_1_1Edge.html">Edge</a> table equivalent INSERT value expression for all data content in an <a class="el" href="classfz_1_1Edge.html">Edge</a>.  <a href="classfz_1_1Edge__pq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Shared__Memory__exception.html">Shared_Memory_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown manager or allocator are requested when none are active.  <a href="classfz_1_1Shared__Memory__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1shared__memory__manager.html">shared_memory_manager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Every shared memory segment (e.g. for a different copy of a <a class="el" href="classfz_1_1Graph.html">Graph</a>) can have its own instance of these references.  <a href="structfz_1_1shared__memory__manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1graph__mem__managers.html">graph_mem_managers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep track of multiple shared memory segments, switch which one is considered active for allocator use, and provide manager and allocator references.  <a href="classfz_1_1graph__mem__managers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1GraphIDcache.html">GraphIDcache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Named__List__String.html">Named_List_String</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Node__ID.html">Node_ID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> ID that caches its ID stamp for frequent use.  <a href="classfz_1_1Node__ID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Edge__ID.html">Edge_ID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfz_1_1Edge.html">Edge</a> ID that caches its ID stamp for frequent use.  <a href="classfz_1_1Edge__ID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Topic__Keyword.html">Topic_Keyword</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Topic.html">Topic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Topic__Tags.html">Topic_Tags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfz_1_1Topic.html">Topic</a> tag data, arranged by integer Index-ID.  <a href="classfz_1_1Topic__Tags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Boolean__Tag__Flags.html">Boolean_Tag_Flags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> class is the principal object type within a Formalizer <a class="el" href="classfz_1_1Graph.html">Graph</a>.  <a href="classfz_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Edge.html">Edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Named__Node__List.html">Named_Node_List</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A named List (or ordered collections) of Nodes.  <a href="structfz_1_1Named__Node__List.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Named__Node__List__Element.html">Named_Node_List_Element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This shared memory data structure is used in Graphmodify and fzserverpq.  <a href="structfz_1_1Named__Node__List__Element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Graph__Config__Options.html">Graph_Config_Options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Graph.html">Graph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Guide__snippet.html">Guide_snippet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic data structure for Guide snippets.  <a href="structfz_1_1Guide__snippet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1JSON__element__data.html">JSON_element_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1JSON__element.html">JSON_element</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1JSON__block.html">JSON_block</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1JSON__data.html">JSON_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1entry__data.html">entry_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A useful data structure for keeping related data together.  <a href="structfz_1_1entry__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1LogIssues.html">LogIssues</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this class to inspect and evaluate the <a class="el" href="classfz_1_1Log.html">Log</a> to discover probable issues.  <a href="classfz_1_1LogIssues.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Breakpoint__pq.html">Breakpoint_pq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data types conversion helper class that can deliver the Postgres Breakpoints table equivalent INSERT value expression for all data content in a Breakpoints.  <a href="classfz_1_1Breakpoint__pq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Logchunk__pq.html">Logchunk_pq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data types conversion helper class that can deliver the Postgres <a class="el" href="classfz_1_1Log.html">Log</a> chunk table equivalent INSERT value expression for all data content in a <a class="el" href="classfz_1_1Log.html">Log</a> chunk.  <a href="classfz_1_1Logchunk__pq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Logentry__pq.html">Logentry_pq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data types conversion helper class that can deliver the Postgres <a class="el" href="classfz_1_1Log.html">Log</a> entries table equivalent INSERT value expression for all data content in a <a class="el" href="classfz_1_1Log.html">Log</a> entry.  <a href="classfz_1_1Logentry__pq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__data.html">Log_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfz_1_1Log.html">Log</a> data base class providing shared parameters and functions.  <a href="classfz_1_1Log__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__by__Node__chainable.html">Log_by_Node_chainable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classfz_1_1Log.html">Log</a> components that are chainable as belonging to a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>.  <a href="classfz_1_1Log__by__Node__chainable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__entry.html">Log_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the start time, <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>, close time, and set of entries of a <a class="el" href="classfz_1_1Log.html">Log</a> chunk.  <a href="classfz_1_1Log__chunk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Log__chunks__Map.html">Log_chunks_Map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__Breakpoints.html">Log_Breakpoints</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html">Log</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Log__filter.html">Log_filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter structure used to set up selective <a class="el" href="classfz_1_1Log.html">Log</a> reading.  <a href="structfz_1_1Log__filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Node__history.html">Node_history</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfz_1_1Log.html">Log</a> history by <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> expressed as a list of <a class="el" href="classfz_1_1Log.html">Log</a> chunks and a list of <a class="el" href="classfz_1_1Log.html">Log</a> entries for each <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> for which there is a history.  <a href="structfz_1_1Node__history.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Node__histories.html">Node_histories</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">These <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> histories are generated (and cached) in a manner where the set of chunks lists only those chunks directly owned by a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>, and where the set of entries lsits only those entries directly owned by a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>.  <a href="classfz_1_1Node__histories.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timestamp IDs in the format required for <a class="el" href="classfz_1_1Log.html">Log</a> IDs.  <a href="structfz_1_1Log__TimeStamp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standardized Formalizer <a class="el" href="classfz_1_1Log.html">Log</a> entry ID key.  <a href="structfz_1_1Log__entry__ID__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standardized Formalizer <a class="el" href="classfz_1_1Log.html">Log</a> chunk ID key.  <a href="structfz_1_1Log__chunk__ID__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Log__target.html">Log_target</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfz_1_1Log.html">Log</a> objects are principally identified by their ID key, but when used as a linked target, e.g.  <a href="structfz_1_1Log__target.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This data structure is used to follow a chain by-Node through the <a class="el" href="classfz_1_1Log.html">Log</a> that can lead to <a class="el" href="classfz_1_1Log.html">Log</a> chunks or <a class="el" href="classfz_1_1Log.html">Log</a> entries.  <a href="structfz_1_1Log__chain__target.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__entry__ID.html">Log_entry_ID</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log__chunk__ID.html">Log_chunk_ID</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1ReferenceTime.html">ReferenceTime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1formalizer__base__streams.html">formalizer_base_streams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The standardized structure for standard stream redirection.  <a href="structfz_1_1formalizer__base__streams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1the__standard__object.html">the_standard_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure registers a <code>standard</code> object with a set of expected parameters and functions for any standardized Formalizer program.  <a href="structfz_1_1the__standard__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1formalizer__standard__program.html">formalizer_standard_program</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a framework for standardized Formalizer programs.  <a href="classfz_1_1formalizer__standard__program.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1main__init__register.html">main_init_register</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes that need an initialization function to be called first-thing upon entering <code>main()</code> (but not before that in the hazardous global variables constructor calls phase) should inherit this class.  <a href="classfz_1_1main__init__register.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1shared__memory__server.html">shared_memory_server</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1GET__token__value.html">GET_token_value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1http__header__data.html">http_header_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to collect HTTP header data and generate HTTP header strings.  <a href="structfz_1_1http__header__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1server__response__text.html">server_response_text</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helpful class for server responses with text data.  <a href="classfz_1_1server__response__text.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1server__response__binary.html">server_response_binary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helpful class for server responses with binary data.  <a href="classfz_1_1server__response__binary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1template__variable__values.html">template_variable_values</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1template__varvalues.html">template_varvalues</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1render__varpos.html">render_varpos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1render__environment.html">render_environment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration for a template rendering environment.  <a href="structfz_1_1render__environment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1time__of__day__t.html">time_of_day_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1NNLmod__update.html">NNLmod_update</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1cmp__cstr.html">cmp_cstr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfz_1_1Node__Targets__cursor.html">Node_Targets_cursor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used by <code>Log::setup_Chunk_nodeprevnext()</code> to build a proper chain.  <a href="structfz_1_1Node__Targets__cursor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a78d4191cbb426307769401251c60dcff"><td class="memItemLeft" align="right" valign="top"><a id="a78d4191cbb426307769401251c60dcff"></a>
typedef std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CGI_Token_Value_Map</b></td></tr>
<tr class="separator:a78d4191cbb426307769401251c60dcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ec4a9353f556467845f99dfd43a9aa"><td class="memItemLeft" align="right" valign="top"><a id="a34ec4a9353f556467845f99dfd43a9aa"></a>
typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a34ec4a9353f556467845f99dfd43a9aa">StackTrace</a></td></tr>
<tr class="memdesc:a34ec4a9353f556467845f99dfd43a9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defining this type for easy swap-in/out of vector, deque, or other container types. <br /></td></tr>
<tr class="separator:a34ec4a9353f556467845f99dfd43a9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48783d041e0591883c4145527c4f9039"><td class="memItemLeft" align="right" valign="top"><a id="a48783d041e0591883c4145527c4f9039"></a>
typedef <a class="el" href="classfz_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Node_ptr</b></td></tr>
<tr class="separator:a48783d041e0591883c4145527c4f9039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfccfcff656c7183c4ecab097c2270f4"><td class="memItemLeft" align="right" valign="top"><a id="adfccfcff656c7183c4ecab097c2270f4"></a>
typedef <a class="el" href="classfz_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Edge_ptr</b></td></tr>
<tr class="separator:adfccfcff656c7183c4ecab097c2270f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afb2fa9fcca209b5524359447fcd7fe"><td class="memItemLeft" align="right" valign="top"><a id="a6afb2fa9fcca209b5524359447fcd7fe"></a>
typedef <a class="el" href="classfz_1_1Graph.html">Graph</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Graph_ptr</b></td></tr>
<tr class="separator:a6afb2fa9fcca209b5524359447fcd7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9241e65e0da6ebbd23c70495d11fa0"><td class="memItemLeft" align="right" valign="top"><a id="a9a9241e65e0da6ebbd23c70495d11fa0"></a>
typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a9a9241e65e0da6ebbd23c70495d11fa0">GraphID8bit</a></td></tr>
<tr class="memdesc:a9a9241e65e0da6ebbd23c70495d11fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formalizer specific base types for ease of modification (fixed size) <br /></td></tr>
<tr class="separator:a9a9241e65e0da6ebbd23c70495d11fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff69939fb338e11b72376788fb3e479"><td class="memItemLeft" align="right" valign="top"><a id="adff69939fb338e11b72376788fb3e479"></a>
typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>GraphIDyear</b></td></tr>
<tr class="separator:adff69939fb338e11b72376788fb3e479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90159dddcbd84757ff883b64042ea46a"><td class="memItemLeft" align="right" valign="top"><a id="a90159dddcbd84757ff883b64042ea46a"></a>
typedef float&#160;</td><td class="memItemRight" valign="bottom"><b>Keyword_Relevance</b></td></tr>
<tr class="separator:a90159dddcbd84757ff883b64042ea46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afddacf07ad964643983aa625bd00aba8"><td class="memItemLeft" align="right" valign="top"><a id="afddacf07ad964643983aa625bd00aba8"></a>
typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#afddacf07ad964643983aa625bd00aba8">Topic_ID</a></td></tr>
<tr class="memdesc:afddacf07ad964643983aa625bd00aba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for real-valued Keyword relevance (to <a class="el" href="classfz_1_1Topic.html">Topic</a>), presently assumed to be in the interval [0.0,1.0]. <br /></td></tr>
<tr class="separator:afddacf07ad964643983aa625bd00aba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef696382cc8a859adcdb76740012048"><td class="memItemLeft" align="right" valign="top"><a id="a4ef696382cc8a859adcdb76740012048"></a>
typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a4ef696382cc8a859adcdb76740012048">Topic_Relevance</a></td></tr>
<tr class="memdesc:a4ef696382cc8a859adcdb76740012048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for unique <a class="el" href="classfz_1_1Topic.html">Topic</a> IDs. <br /></td></tr>
<tr class="separator:a4ef696382cc8a859adcdb76740012048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0b830dbdc40a428e14bf782876cb5c"><td class="memItemLeft" align="right" valign="top"><a id="afa0b830dbdc40a428e14bf782876cb5c"></a>
typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#afa0b830dbdc40a428e14bf782876cb5c">Graphdecimal</a></td></tr>
<tr class="memdesc:afa0b830dbdc40a428e14bf782876cb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for real-valued <a class="el" href="classfz_1_1Topic.html">Topic</a> relevance (of <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>), presently assumed to be in the interval [0.0,1.0]. <br /></td></tr>
<tr class="separator:afa0b830dbdc40a428e14bf782876cb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154799021699adf6ca7cec17a237f670"><td class="memItemLeft" align="right" valign="top"><a id="a154799021699adf6ca7cec17a237f670"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>Graphsigned</b></td></tr>
<tr class="separator:a154799021699adf6ca7cec17a237f670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0363cb224731ef2c142a5cbf9c50efeb"><td class="memItemLeft" align="right" valign="top"><a id="a0363cb224731ef2c142a5cbf9c50efeb"></a>
typedef bool&#160;</td><td class="memItemRight" valign="bottom"><b>Graphflag</b></td></tr>
<tr class="separator:a0363cb224731ef2c142a5cbf9c50efeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea7732e23edac813178c212f8deb641"><td class="memItemLeft" align="right" valign="top"><a id="a1ea7732e23edac813178c212f8deb641"></a>
typedef std::vector&lt; <a class="el" href="classfz_1_1Node.html">Node_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Node_Index</b></td></tr>
<tr class="separator:a1ea7732e23edac813178c212f8deb641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8fd9836dfeac48419a3e0a89f0f8f2"><td class="memItemLeft" align="right" valign="top"><a id="ade8fd9836dfeac48419a3e0a89f0f8f2"></a>
typedef std::multimap&lt; time_t, <a class="el" href="classfz_1_1Node.html">Node_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a></td></tr>
<tr class="memdesc:ade8fd9836dfeac48419a3e0a89f0f8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorting is done by the time_t key comparison function. <br /></td></tr>
<tr class="separator:ade8fd9836dfeac48419a3e0a89f0f8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9b407d216581e0bf362111a958f959"><td class="memItemLeft" align="right" valign="top"><a id="afa9b407d216581e0bf362111a958f959"></a>
typedef std::map&lt; const <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a>, <a class="el" href="classfz_1_1Node.html">Node_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>key_sorted_Nodes</b></td></tr>
<tr class="separator:afa9b407d216581e0bf362111a958f959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afa8497bdab94f3c06049a3632402a5"><td class="memItemLeft" align="right" valign="top"><a id="a7afa8497bdab94f3c06049a3632402a5"></a>
typedef std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Graph_info_label_value_pairs</b></td></tr>
<tr class="separator:a7afa8497bdab94f3c06049a3632402a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d31dd53be55a148b33ff3a70be11d63"><td class="memItemLeft" align="right" valign="top"><a id="a3d31dd53be55a148b33ff3a70be11d63"></a>
typedef std::pair&lt; std::string, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a3d31dd53be55a148b33ff3a70be11d63">Tag_Label_Real_Value</a></td></tr>
<tr class="memdesc:a3d31dd53be55a148b33ff3a70be11d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Such as used with Topics and various possible defined tags. <br /></td></tr>
<tr class="separator:a3d31dd53be55a148b33ff3a70be11d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891f4fc73fdf09b0dfa5b4dce2631244"><td class="memItemLeft" align="right" valign="top"><a id="a891f4fc73fdf09b0dfa5b4dce2631244"></a>
typedef std::vector&lt; <a class="el" href="namespacefz.html#a3d31dd53be55a148b33ff3a70be11d63">Tag_Label_Real_Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Tag_Label_Real_Value_Vector</b></td></tr>
<tr class="separator:a891f4fc73fdf09b0dfa5b4dce2631244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3aa3b263d37dc60210e5b8342bd6039"><td class="memItemLeft" align="right" valign="top"><a id="ab3aa3b263d37dc60210e5b8342bd6039"></a>
typedef std::deque&lt; <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>base_Node_List</b></td></tr>
<tr class="separator:ab3aa3b263d37dc60210e5b8342bd6039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8137bed79571a2b3f92b5d57533e0523"><td class="memItemLeft" align="right" valign="top"><a id="a8137bed79571a2b3f92b5d57533e0523"></a>
typedef std::set&lt; <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a>, std::less&lt; <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>base_Node_Set</b></td></tr>
<tr class="separator:a8137bed79571a2b3f92b5d57533e0523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b12fceddd8928f8ec037a096a022aa"><td class="memItemLeft" align="right" valign="top"><a id="ab1b12fceddd8928f8ec037a096a022aa"></a>
typedef std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>Edit_flags_type</b></td></tr>
<tr class="separator:ab1b12fceddd8928f8ec037a096a022aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df86d9f8829a5d15d973c8dbfa5d4e7"><td class="memItemLeft" align="right" valign="top"><a id="a0df86d9f8829a5d15d973c8dbfa5d4e7"></a>
typedef std::map&lt; <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a>, <a class="el" href="structfz_1_1Node__Branch.html">Node_Branch</a>, std::less&lt; <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Subtree_Branch_Map</b></td></tr>
<tr class="separator:a0df86d9f8829a5d15d973c8dbfa5d4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e038512db99e651fa90ca9987a9204c"><td class="memItemLeft" align="right" valign="top"><a id="a0e038512db99e651fa90ca9987a9204c"></a>
typedef std::map&lt; <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a>, <a class="el" href="structfz_1_1Node__Subtree.html">Node_Subtree</a>, std::less&lt; <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>map_of_subtrees_t</b></td></tr>
<tr class="separator:a0e038512db99e651fa90ca9987a9204c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0ab81021660db114065569784d125a"><td class="memItemLeft" align="right" valign="top"><a id="a8b0ab81021660db114065569784d125a"></a>
typedef std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>cat_translation_map</b></td></tr>
<tr class="separator:a8b0ab81021660db114065569784d125a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0885b44585883a34916c30db3c473d"><td class="memItemLeft" align="right" valign="top"><a id="aec0885b44585883a34916c30db3c473d"></a>
typedef cat_translation_map *&#160;</td><td class="memItemRight" valign="bottom"><b>cat_translation_map_ptr</b></td></tr>
<tr class="separator:aec0885b44585883a34916c30db3c473d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec42076c72022f11008c3bcf9636554"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#abec42076c72022f11008c3bcf9636554">byte_vector_t</a></td></tr>
<tr class="separator:abec42076c72022f11008c3bcf9636554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca61d6e0119b10aa1e72541aea6041c"><td class="memItemLeft" align="right" valign="top"><a id="a9ca61d6e0119b10aa1e72541aea6041c"></a>
typedef bi::allocator&lt; <a class="el" href="structfz_1_1Graphmod__result.html">Graphmod_result</a>, segment_manager_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Graphmod_result_allocator</b></td></tr>
<tr class="separator:a9ca61d6e0119b10aa1e72541aea6041c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88f7ad5c52613cbdab3441bfec21e2b"><td class="memItemLeft" align="right" valign="top"><a id="aa88f7ad5c52613cbdab3441bfec21e2b"></a>
typedef bi::vector&lt; <a class="el" href="structfz_1_1Graphmod__result.html">Graphmod_result</a>, Graphmod_result_allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Graphmod_result_Vector</b></td></tr>
<tr class="separator:aa88f7ad5c52613cbdab3441bfec21e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fdb18b176297572a9f352c246b9dd2"><td class="memItemLeft" align="right" valign="top"><a id="ad3fdb18b176297572a9f352c246b9dd2"></a>
typedef std::vector&lt; <a class="el" href="structfz_1_1Graphmod__result.html">Graphmod_result</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Graphmod_unshared_result_Vector</b></td></tr>
<tr class="separator:ad3fdb18b176297572a9f352c246b9dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f65aa70259f159805797630984f75a"><td class="memItemLeft" align="right" valign="top"><a id="ab9f65aa70259f159805797630984f75a"></a>
typedef bi::offset_ptr&lt; <a class="el" href="structfz_1_1TD__Node__shm.html">TD_Node_shm</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TD_Node_shm_offsetptr</b></td></tr>
<tr class="separator:ab9f65aa70259f159805797630984f75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66842abb8fdbe2884e579824de76a481"><td class="memItemLeft" align="right" valign="top"><a id="a66842abb8fdbe2884e579824de76a481"></a>
typedef bi::offset_ptr&lt; <a class="el" href="structfz_1_1Batchmod__targetdates.html">Batchmod_targetdates</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Batchmod_targetdates_offsetptr</b></td></tr>
<tr class="separator:a66842abb8fdbe2884e579824de76a481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d7eef7381ea8040c24b763563bbc64"><td class="memItemLeft" align="right" valign="top"><a id="a36d7eef7381ea8040c24b763563bbc64"></a>
typedef <a class="el" href="structfz_1_1Batchmod__targetdates.html">Batchmod_targetdates</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Batchmod_targetdates_ptr</b></td></tr>
<tr class="separator:a36d7eef7381ea8040c24b763563bbc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f39fc18d46af4e898649f869bed5b13"><td class="memItemLeft" align="right" valign="top"><a id="a6f39fc18d46af4e898649f869bed5b13"></a>
typedef bi::offset_ptr&lt; <a class="el" href="structfz_1_1Batchmod__tpass.html">Batchmod_tpass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Batchmod_tpass_offsetptr</b></td></tr>
<tr class="separator:a6f39fc18d46af4e898649f869bed5b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c99aaaa0a7eedbe76088dab5fbc3f46"><td class="memItemLeft" align="right" valign="top"><a id="a5c99aaaa0a7eedbe76088dab5fbc3f46"></a>
typedef <a class="el" href="structfz_1_1Batchmod__tpass.html">Batchmod_tpass</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Batchmod_tpass_ptr</b></td></tr>
<tr class="separator:a5c99aaaa0a7eedbe76088dab5fbc3f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed576074a31ccba9bf09681f64ac505"><td class="memItemLeft" align="right" valign="top"><a id="a7ed576074a31ccba9bf09681f64ac505"></a>
typedef bi::allocator&lt; <a class="el" href="structfz_1_1Graphmod__data.html">Graphmod_data</a>, segment_manager_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Graphmod_data_allocator</b></td></tr>
<tr class="separator:a7ed576074a31ccba9bf09681f64ac505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115ae8b5e1de8b90ebe8e352810462ea"><td class="memItemLeft" align="right" valign="top"><a id="a115ae8b5e1de8b90ebe8e352810462ea"></a>
typedef bi::vector&lt; <a class="el" href="structfz_1_1Graphmod__data.html">Graphmod_data</a>, Graphmod_data_allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Graphmod_data_Vector</b></td></tr>
<tr class="separator:a115ae8b5e1de8b90ebe8e352810462ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4361969858babf3a2b83f4f1ebcfa2"><td class="memItemLeft" align="right" valign="top"><a id="a7b4361969858babf3a2b83f4f1ebcfa2"></a>
typedef bi::offset_ptr&lt; <a class="el" href="classfz_1_1Graph.html">Graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a7b4361969858babf3a2b83f4f1ebcfa2">Graph_Graph_ptr</a></td></tr>
<tr class="memdesc:a7b4361969858babf3a2b83f4f1ebcfa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formalizer specific base types for ease of modification (movable pointers) <br /></td></tr>
<tr class="separator:a7b4361969858babf3a2b83f4f1ebcfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f137b9485887472b2e90f09e58b81a2"><td class="memItemLeft" align="right" valign="top"><a id="a2f137b9485887472b2e90f09e58b81a2"></a>
typedef bi::offset_ptr&lt; <a class="el" href="classfz_1_1Topic.html">Topic</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Graph_Topic_ptr</b></td></tr>
<tr class="separator:a2f137b9485887472b2e90f09e58b81a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704383e4e37e129d3e15110221959b64"><td class="memItemLeft" align="right" valign="top"><a id="a704383e4e37e129d3e15110221959b64"></a>
typedef bi::offset_ptr&lt; <a class="el" href="classfz_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Graph_Node_ptr</b></td></tr>
<tr class="separator:a704383e4e37e129d3e15110221959b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32d4a3f39e48c3c3bed7941047f09be"><td class="memItemLeft" align="right" valign="top"><a id="ae32d4a3f39e48c3c3bed7941047f09be"></a>
typedef bi::offset_ptr&lt; <a class="el" href="classfz_1_1Edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Graph_Edge_ptr</b></td></tr>
<tr class="separator:ae32d4a3f39e48c3c3bed7941047f09be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabee04df43b16403996baaf6bd9d2a53"><td class="memItemLeft" align="right" valign="top"><a id="aabee04df43b16403996baaf6bd9d2a53"></a>
typedef bi::managed_shared_memory&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aabee04df43b16403996baaf6bd9d2a53">segment_memory_t</a></td></tr>
<tr class="memdesc:aabee04df43b16403996baaf6bd9d2a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formalizer specific base types for ease of modification (container types) <br /></td></tr>
<tr class="separator:aabee04df43b16403996baaf6bd9d2a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c43a0e49044064df5157fdf2e54c9bf"><td class="memItemLeft" align="right" valign="top"><a id="a6c43a0e49044064df5157fdf2e54c9bf"></a>
typedef bi::managed_shared_memory::segment_manager&#160;</td><td class="memItemRight" valign="bottom"><b>segment_manager_t</b></td></tr>
<tr class="separator:a6c43a0e49044064df5157fdf2e54c9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df91d6271ef48722e999bb4f19d0748"><td class="memItemLeft" align="right" valign="top"><a id="a2df91d6271ef48722e999bb4f19d0748"></a>
typedef bi::allocator&lt; void, segment_manager_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>void_allocator</b></td></tr>
<tr class="separator:a2df91d6271ef48722e999bb4f19d0748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7a4b03c626a978977c7cbbf47ada74"><td class="memItemLeft" align="right" valign="top"><a id="afc7a4b03c626a978977c7cbbf47ada74"></a>
typedef bi::allocator&lt; char, segment_manager_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>char_allocator</b></td></tr>
<tr class="separator:afc7a4b03c626a978977c7cbbf47ada74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0172873e66c5d2c8d3228f2894039acc"><td class="memItemLeft" align="right" valign="top"><a id="a0172873e66c5d2c8d3228f2894039acc"></a>
typedef bi::basic_string&lt; char, std::char_traits&lt; char &gt;, char_allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Keyword_String</b></td></tr>
<tr class="separator:a0172873e66c5d2c8d3228f2894039acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5903f4a75415b67a44e8d2ac513288ab"><td class="memItemLeft" align="right" valign="top"><a id="a5903f4a75415b67a44e8d2ac513288ab"></a>
typedef bi::basic_string&lt; char, std::char_traits&lt; char &gt;, char_allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Topic_String</b></td></tr>
<tr class="separator:a5903f4a75415b67a44e8d2ac513288ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7d99053a5e1d8b106dc6999621ecf0"><td class="memItemLeft" align="right" valign="top"><a id="a9e7d99053a5e1d8b106dc6999621ecf0"></a>
typedef bi::basic_string&lt; char, std::char_traits&lt; char &gt;, char_allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Node_utf8_text</b></td></tr>
<tr class="separator:a9e7d99053a5e1d8b106dc6999621ecf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d403dfbc9bcd620c5b65ec63a66b2b1"><td class="memItemLeft" align="right" valign="top"><a id="a2d403dfbc9bcd620c5b65ec63a66b2b1"></a>
typedef bi::basic_string&lt; char, std::char_traits&lt; char &gt;, char_allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Server_Addr_String</b></td></tr>
<tr class="separator:a2d403dfbc9bcd620c5b65ec63a66b2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a02e82d88cf459ed767c7857b06b7b2"><td class="memItemLeft" align="right" valign="top"><a id="a0a02e82d88cf459ed767c7857b06b7b2"></a>
typedef bi::allocator&lt; <a class="el" href="structfz_1_1Topic__Keyword.html">Topic_Keyword</a>, segment_manager_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Topic_Keyword_allocator</b></td></tr>
<tr class="separator:a0a02e82d88cf459ed767c7857b06b7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5ddfe2d3ca087e3b41f64964ce2dd7"><td class="memItemLeft" align="right" valign="top"><a id="a0f5ddfe2d3ca087e3b41f64964ce2dd7"></a>
typedef bi::vector&lt; <a class="el" href="structfz_1_1Topic__Keyword.html">Topic_Keyword</a>, Topic_Keyword_allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Topic_KeyRel_Vector</b></td></tr>
<tr class="separator:a0f5ddfe2d3ca087e3b41f64964ce2dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac773bb4b41228be6b22a0220a9b5a07c"><td class="memItemLeft" align="right" valign="top"><a id="ac773bb4b41228be6b22a0220a9b5a07c"></a>
typedef bi::allocator&lt; Graph_Topic_ptr, segment_manager_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TopicPtr_allocator</b></td></tr>
<tr class="separator:ac773bb4b41228be6b22a0220a9b5a07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5e25f603a2622249dfae077c93916f"><td class="memItemLeft" align="right" valign="top"><a id="a8a5e25f603a2622249dfae077c93916f"></a>
typedef bi::vector&lt; Graph_Topic_ptr, TopicPtr_allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a8a5e25f603a2622249dfae077c93916f">Topic_Tags_Vector</a></td></tr>
<tr class="memdesc:a8a5e25f603a2622249dfae077c93916f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only pointers, not the objects themselves. (See Dangerous code card in Software Engineering Update Trello board.) <br /></td></tr>
<tr class="separator:a8a5e25f603a2622249dfae077c93916f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eaa62a5363c0a3b86b53476d7c47ced"><td class="memItemLeft" align="right" valign="top"><a id="a9eaa62a5363c0a3b86b53476d7c47ced"></a>
typedef bi::allocator&lt; Graph_Edge_ptr, segment_manager_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EdgePtr_allocator</b></td></tr>
<tr class="separator:a9eaa62a5363c0a3b86b53476d7c47ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6e58d32fd231a5ffb308229eeedbe4"><td class="memItemLeft" align="right" valign="top"><a id="a4c6e58d32fd231a5ffb308229eeedbe4"></a>
typedef bi::set&lt; Graph_Edge_ptr, std::less&lt; Graph_Edge_ptr &gt;, EdgePtr_allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Edges_Set</b></td></tr>
<tr class="separator:a4c6e58d32fd231a5ffb308229eeedbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43f2dedad35c1536389e9b8681b5b85"><td class="memItemLeft" align="right" valign="top"><a id="af43f2dedad35c1536389e9b8681b5b85"></a>
typedef std::pair&lt; const Topic_String, Graph_Topic_ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Topic_Map_value_type</b></td></tr>
<tr class="separator:af43f2dedad35c1536389e9b8681b5b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab518565b2ec4ab214280b6713c267719"><td class="memItemLeft" align="right" valign="top"><a id="ab518565b2ec4ab214280b6713c267719"></a>
typedef bi::allocator&lt; Topic_Map_value_type, segment_manager_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Topic_Map_value_type_allocator</b></td></tr>
<tr class="separator:ab518565b2ec4ab214280b6713c267719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cce928e882ee36ec7ae25a1ca188a5"><td class="memItemLeft" align="right" valign="top"><a id="a20cce928e882ee36ec7ae25a1ca188a5"></a>
typedef bi::map&lt; Topic_String, Graph_Topic_ptr, std::less&lt; Topic_String &gt;, Topic_Map_value_type_allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TopicbyTag_Map</b></td></tr>
<tr class="separator:a20cce928e882ee36ec7ae25a1ca188a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee76e666046d9ab7967e1708d244470"><td class="memItemLeft" align="right" valign="top"><a id="a9ee76e666046d9ab7967e1708d244470"></a>
typedef std::pair&lt; const <a class="el" href="namespacefz.html#afddacf07ad964643983aa625bd00aba8">Topic_ID</a>, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Topics_Set_value_type</b></td></tr>
<tr class="separator:a9ee76e666046d9ab7967e1708d244470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78fd66448892e201fc1bd626ce521c7"><td class="memItemLeft" align="right" valign="top"><a id="af78fd66448892e201fc1bd626ce521c7"></a>
typedef bi::allocator&lt; Topics_Set_value_type, segment_manager_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Topics_Set_value_type_allocator</b></td></tr>
<tr class="separator:af78fd66448892e201fc1bd626ce521c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ca9816d2895bd9e7e2e7eb2d29a0d8"><td class="memItemLeft" align="right" valign="top"><a id="aa0ca9816d2895bd9e7e2e7eb2d29a0d8"></a>
typedef bi::map&lt; <a class="el" href="namespacefz.html#afddacf07ad964643983aa625bd00aba8">Topic_ID</a>, float, std::less&lt; <a class="el" href="namespacefz.html#afddacf07ad964643983aa625bd00aba8">Topic_ID</a> &gt;, Topics_Set_value_type_allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Topics_Set</b></td></tr>
<tr class="separator:aa0ca9816d2895bd9e7e2e7eb2d29a0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bf699cf02bd31aa8ef17acc1023df5"><td class="memItemLeft" align="right" valign="top"><a id="a78bf699cf02bd31aa8ef17acc1023df5"></a>
typedef std::pair&lt; const <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a>, Graph_Node_ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Node_Map_value_type</b></td></tr>
<tr class="separator:a78bf699cf02bd31aa8ef17acc1023df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46951b34e6bfa9d4a0bc181a7967072"><td class="memItemLeft" align="right" valign="top"><a id="ad46951b34e6bfa9d4a0bc181a7967072"></a>
typedef bi::allocator&lt; Node_Map_value_type, segment_manager_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Node_Map_value_type_allocator</b></td></tr>
<tr class="separator:ad46951b34e6bfa9d4a0bc181a7967072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d422cb55ab978e86f9314fbde134e32"><td class="memItemLeft" align="right" valign="top"><a id="a8d422cb55ab978e86f9314fbde134e32"></a>
typedef bi::map&lt; <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a>, Graph_Node_ptr, std::less&lt; <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a> &gt;, Node_Map_value_type_allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Node_Map</b></td></tr>
<tr class="separator:a8d422cb55ab978e86f9314fbde134e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e22a495278d1cb438f88ec343a12c3"><td class="memItemLeft" align="right" valign="top"><a id="aa1e22a495278d1cb438f88ec343a12c3"></a>
typedef std::pair&lt; const <a class="el" href="structfz_1_1Edge__ID__key.html">Edge_ID_key</a>, Graph_Edge_ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Edge_Map_value_type</b></td></tr>
<tr class="separator:aa1e22a495278d1cb438f88ec343a12c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739702b10733cde7a21d29d417d94610"><td class="memItemLeft" align="right" valign="top"><a id="a739702b10733cde7a21d29d417d94610"></a>
typedef bi::allocator&lt; Edge_Map_value_type, segment_manager_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Edge_Map_value_type_allocator</b></td></tr>
<tr class="separator:a739702b10733cde7a21d29d417d94610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960291cf8d24043e4a80399d14a8ec85"><td class="memItemLeft" align="right" valign="top"><a id="a960291cf8d24043e4a80399d14a8ec85"></a>
typedef bi::map&lt; <a class="el" href="structfz_1_1Edge__ID__key.html">Edge_ID_key</a>, Graph_Edge_ptr, std::less&lt; <a class="el" href="structfz_1_1Edge__ID__key.html">Edge_ID_key</a> &gt;, Edge_Map_value_type_allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Edge_Map</b></td></tr>
<tr class="separator:a960291cf8d24043e4a80399d14a8ec85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aadce2397141e19a900a4a90b5c507b"><td class="memItemLeft" align="right" valign="top"><a id="a3aadce2397141e19a900a4a90b5c507b"></a>
typedef bi::allocator&lt; <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a>, segment_manager_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Node_ID_key_allocator</b></td></tr>
<tr class="separator:a3aadce2397141e19a900a4a90b5c507b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f2fb9dc6e9c0137dd3cc763316a097"><td class="memItemLeft" align="right" valign="top">typedef bi::deque&lt; <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a>, Node_ID_key_allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a35f2fb9dc6e9c0137dd3cc763316a097">Node_List</a></td></tr>
<tr class="memdesc:a35f2fb9dc6e9c0137dd3cc763316a097"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type used for named Lists (or ordered collections) of Nodes.  <a href="namespacefz.html#a35f2fb9dc6e9c0137dd3cc763316a097">More...</a><br /></td></tr>
<tr class="separator:a35f2fb9dc6e9c0137dd3cc763316a097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11ebf6afe9786e8c41b149ba8035875"><td class="memItemLeft" align="right" valign="top"><a id="af11ebf6afe9786e8c41b149ba8035875"></a>
typedef bi::set&lt; <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a>, std::less&lt; <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a> &gt;, Node_ID_key_allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Node_Set</b></td></tr>
<tr class="separator:af11ebf6afe9786e8c41b149ba8035875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619e9f686624f66e6323f7da1ae2a46c"><td class="memItemLeft" align="right" valign="top">typedef std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a619e9f686624f66e6323f7da1ae2a46c">Boolean_Tag_Flags_type</a></td></tr>
<tr class="memdesc:a619e9f686624f66e6323f7da1ae2a46c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bitmask of flags for the data components of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>.  <a href="namespacefz.html#a619e9f686624f66e6323f7da1ae2a46c">More...</a><br /></td></tr>
<tr class="separator:a619e9f686624f66e6323f7da1ae2a46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc449f5b060c9241c2e1c356d94696a6"><td class="memItemLeft" align="right" valign="top"><a id="acc449f5b060c9241c2e1c356d94696a6"></a>
typedef <a class="el" href="structfz_1_1Named__Node__List.html">Named_Node_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Named_Node_List_ptr</b></td></tr>
<tr class="separator:acc449f5b060c9241c2e1c356d94696a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec92026f97e0cf0ff947876c8c4973ee"><td class="memItemLeft" align="right" valign="top"><a id="aec92026f97e0cf0ff947876c8c4973ee"></a>
typedef std::pair&lt; const <a class="el" href="structfz_1_1Named__List__String.html">Named_List_String</a>, <a class="el" href="structfz_1_1Named__Node__List.html">Named_Node_List</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Named_Node_List_Map_value_type</b></td></tr>
<tr class="separator:aec92026f97e0cf0ff947876c8c4973ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c84138bc6eca23e0c9cea1e40484e2"><td class="memItemLeft" align="right" valign="top"><a id="a57c84138bc6eca23e0c9cea1e40484e2"></a>
typedef bi::allocator&lt; Named_Node_List_Map_value_type, segment_manager_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Named_Node_List_Map_value_type_allocator</b></td></tr>
<tr class="separator:a57c84138bc6eca23e0c9cea1e40484e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bbc2024f4c743ac19ef8c567ffbfc9"><td class="memItemLeft" align="right" valign="top"><a id="af2bbc2024f4c743ac19ef8c567ffbfc9"></a>
typedef bi::map&lt; <a class="el" href="structfz_1_1Named__List__String.html">Named_List_String</a>, <a class="el" href="structfz_1_1Named__Node__List.html">Named_Node_List</a>, std::less&lt; <a class="el" href="structfz_1_1Named__List__String.html">Named_List_String</a> &gt;, Named_Node_List_Map_value_type_allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Named_Node_List_Map</b></td></tr>
<tr class="separator:af2bbc2024f4c743ac19ef8c567ffbfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d12c1a9745e382af0e9bfc8dad759fb"><td class="memItemLeft" align="right" valign="top"><a id="a0d12c1a9745e382af0e9bfc8dad759fb"></a>
typedef bi::offset_ptr&lt; <a class="el" href="structfz_1_1Named__Node__List__Element.html">Named_Node_List_Element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Named_Node_List_Element_ptr</b></td></tr>
<tr class="separator:a0d12c1a9745e382af0e9bfc8dad759fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5151917f89479710b9dc98fde7cd2f"><td class="memItemLeft" align="right" valign="top"><a id="ada5151917f89479710b9dc98fde7cd2f"></a>
typedef std::pair&lt; <a class="el" href="classfz_1_1Node.html">Node</a> *, <a class="el" href="classfz_1_1Graph.html">Graph</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Node_Graph_ptr_pair</b></td></tr>
<tr class="separator:ada5151917f89479710b9dc98fde7cd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802569f5b5ba6ee365ce8707d3028bcc"><td class="memItemLeft" align="right" valign="top"><a id="a802569f5b5ba6ee365ce8707d3028bcc"></a>
typedef std::unique_ptr&lt; <a class="el" href="structfz_1_1Guide__snippet.html">Guide_snippet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Guide_snippet_ptr</b></td></tr>
<tr class="separator:a802569f5b5ba6ee365ce8707d3028bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614572bd97e4c868fa3433d462ce18eb"><td class="memItemLeft" align="right" valign="top"><a id="a614572bd97e4c868fa3433d462ce18eb"></a>
typedef std::string&#160;</td><td class="memItemRight" valign="bottom"><b>jsonlite_parlabel</b></td></tr>
<tr class="separator:a614572bd97e4c868fa3433d462ce18eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72cb67ee2554567cf749a08f97b1779"><td class="memItemLeft" align="right" valign="top"><a id="ae72cb67ee2554567cf749a08f97b1779"></a>
typedef std::string&#160;</td><td class="memItemRight" valign="bottom"><b>jsonlite_parvalue</b></td></tr>
<tr class="separator:ae72cb67ee2554567cf749a08f97b1779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a5c27bb0daaeb523ea4816cd9cbf53"><td class="memItemLeft" align="right" valign="top"><a id="a84a5c27bb0daaeb523ea4816cd9cbf53"></a>
typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>jsonlite_lines</b></td></tr>
<tr class="separator:a84a5c27bb0daaeb523ea4816cd9cbf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802586fd40a34d043ded9936808c76db"><td class="memItemLeft" align="right" valign="top"><a id="a802586fd40a34d043ded9936808c76db"></a>
typedef std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>jsonlite_label_value_pair</b></td></tr>
<tr class="separator:a802586fd40a34d043ded9936808c76db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ddc16fc4a42a3db4db6318bab04a98"><td class="memItemLeft" align="right" valign="top"><a id="a20ddc16fc4a42a3db4db6318bab04a98"></a>
typedef std::map&lt; jsonlite_parlabel, jsonlite_parvalue &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>jsonlite_label_value_pairs</b></td></tr>
<tr class="separator:a20ddc16fc4a42a3db4db6318bab04a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c87a53acb9b6b14e686b5d9e2eaa8ea"><td class="memItemLeft" align="right" valign="top"><a id="a9c87a53acb9b6b14e686b5d9e2eaa8ea"></a>
typedef std::vector&lt; <a class="el" href="structfz_1_1JSON__element__data.html">JSON_element_data</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>JSON_element_data_vec</b></td></tr>
<tr class="separator:a9c87a53acb9b6b14e686b5d9e2eaa8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5a91c70aa83673352e1542dd44f218"><td class="memItemLeft" align="right" valign="top"><a id="aae5a91c70aa83673352e1542dd44f218"></a>
typedef std::vector&lt; std::unique_ptr&lt; <a class="el" href="structfz_1_1JSON__element.html">JSON_element</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>JSON_elements_vec</b></td></tr>
<tr class="separator:aae5a91c70aa83673352e1542dd44f218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bd892bb50b2004fbf6189c332149e2"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; const <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a>, std::unique_ptr&lt; <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aa0bd892bb50b2004fbf6189c332149e2">Log_entries_Map</a></td></tr>
<tr class="separator:aa0bd892bb50b2004fbf6189c332149e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4726293a93d0a9304df57f132c7bd78c"><td class="memItemLeft" align="right" valign="top"><a id="a4726293a93d0a9304df57f132c7bd78c"></a>
typedef std::pair&lt; Log_entries_Map::iterator, Log_entries_Map::iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a4726293a93d0a9304df57f132c7bd78c">Log_entry_iterator_interval</a></td></tr>
<tr class="memdesc:a4726293a93d0a9304df57f132c7bd78c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structInterval.html">Interval</a> type for the Log_entries_Map. <br /></td></tr>
<tr class="separator:a4726293a93d0a9304df57f132c7bd78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da349947193bd5fdd31b6a483867275"><td class="memItemLeft" align="right" valign="top"><a id="a5da349947193bd5fdd31b6a483867275"></a>
typedef std::pair&lt; const <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a>, std::unique_ptr&lt; <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a5da349947193bd5fdd31b6a483867275">Log_chunk_ptr_map_element</a></td></tr>
<tr class="memdesc:a5da349947193bd5fdd31b6a483867275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hands for this container type. <br /></td></tr>
<tr class="separator:a5da349947193bd5fdd31b6a483867275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660b829370dfabc56be47b43bf512206"><td class="memItemLeft" align="right" valign="top"><a id="a660b829370dfabc56be47b43bf512206"></a>
typedef std::map&lt; const <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a>, std::unique_ptr&lt; <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_chunk_ptr_map</b></td></tr>
<tr class="separator:a660b829370dfabc56be47b43bf512206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e51cecf62d27bf997fda163c4ad80b1"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; Log_chunk_ptr_map::iterator, Log_chunk_ptr_map::iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a9e51cecf62d27bf997fda163c4ad80b1">Log_chunk_iterator_interval</a></td></tr>
<tr class="memdesc:a9e51cecf62d27bf997fda163c4ad80b1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structInterval.html">Interval</a> types for the Log_chunks_Deque.  <a href="namespacefz.html#a9e51cecf62d27bf997fda163c4ad80b1">More...</a><br /></td></tr>
<tr class="separator:a9e51cecf62d27bf997fda163c4ad80b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6f4aa1c838489e87313aabe28ba3e9"><td class="memItemLeft" align="right" valign="top"><a id="afa6f4aa1c838489e87313aabe28ba3e9"></a>
typedef std::pair&lt; Log_chunk_ptr_map::const_iterator, Log_chunk_ptr_map::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_chunk_const_iterator_interval</b></td></tr>
<tr class="separator:afa6f4aa1c838489e87313aabe28ba3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5175e16f78be263509aa5f4ce5141aa"><td class="memItemLeft" align="right" valign="top"><a id="ad5175e16f78be263509aa5f4ce5141aa"></a>
typedef std::pair&lt; const <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a>, const <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_chunk_ID_interval</b></td></tr>
<tr class="separator:ad5175e16f78be263509aa5f4ce5141aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab7c482e90efa5d2bfcba903ee13ab4"><td class="memItemLeft" align="right" valign="top"><a id="aaab7c482e90efa5d2bfcba903ee13ab4"></a>
typedef std::deque&lt; <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aaab7c482e90efa5d2bfcba903ee13ab4">Log_chunk_ID_key_deque</a></td></tr>
<tr class="memdesc:aaab7c482e90efa5d2bfcba903ee13ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for this container type. <br /></td></tr>
<tr class="separator:aaab7c482e90efa5d2bfcba903ee13ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6843e06d3de694d653269771fd5253b"><td class="memItemLeft" align="right" valign="top"><a id="ae6843e06d3de694d653269771fd5253b"></a>
typedef std::set&lt; <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a>, std::less&lt; <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_chunk_ID_key_set</b></td></tr>
<tr class="separator:ae6843e06d3de694d653269771fd5253b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec869518615dc0f9ce2f7096124e5552"><td class="memItemLeft" align="right" valign="top"><a id="aec869518615dc0f9ce2f7096124e5552"></a>
typedef std::set&lt; <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a>, std::less&lt; <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_entry_ID_key_set</b></td></tr>
<tr class="separator:aec869518615dc0f9ce2f7096124e5552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a30f894de59ff8235d947a7d104e3b"><td class="memItemLeft" align="right" valign="top"><a id="ab1a30f894de59ff8235d947a7d104e3b"></a>
typedef std::unique_ptr&lt; <a class="el" href="structfz_1_1Node__history.html">Node_history</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>history_ptr</b></td></tr>
<tr class="separator:ab1a30f894de59ff8235d947a7d104e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fa686034d8685dd4cd88b74e9e5132"><td class="memItemLeft" align="right" valign="top"><a id="a03fa686034d8685dd4cd88b74e9e5132"></a>
typedef <a class="el" href="structfz_1_1Log__target.html">Log_target</a>&lt; <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a>, <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_chunk_target</b></td></tr>
<tr class="separator:a03fa686034d8685dd4cd88b74e9e5132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b4d76cf439608a0de4a4d1282c742f"><td class="memItemLeft" align="right" valign="top"><a id="ae0b4d76cf439608a0de4a4d1282c742f"></a>
typedef <a class="el" href="structfz_1_1Log__target.html">Log_target</a>&lt; <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a>, <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_entry_target</b></td></tr>
<tr class="separator:ae0b4d76cf439608a0de4a4d1282c742f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7628e7ec4a0b6dd62dd1b38614ae2944"><td class="memItemLeft" align="right" valign="top"><a id="a7628e7ec4a0b6dd62dd1b38614ae2944"></a>
typedef std::pair&lt; bool, <a class="el" href="classfz_1_1Log__data.html">Log_data</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_ptr_pair</b></td></tr>
<tr class="separator:a7628e7ec4a0b6dd62dd1b38614ae2944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fad9a0772bcfce865af13b7a659a4c6"><td class="memItemLeft" align="right" valign="top"><a id="a4fad9a0772bcfce865af13b7a659a4c6"></a>
typedef std::tuple&lt; bool, <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a>, <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_key_tuple</b></td></tr>
<tr class="separator:a4fad9a0772bcfce865af13b7a659a4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa45880b9bbad1bcf026d98b71df765"><td class="memItemLeft" align="right" valign="top"><a id="affa45880b9bbad1bcf026d98b71df765"></a>
typedef std::tuple&lt; bool, <a class="el" href="structfz_1_1Log__target.html">Log_chunk_target</a>, <a class="el" href="structfz_1_1Log__target.html">Log_entry_target</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Log_target_tuple</b></td></tr>
<tr class="separator:affa45880b9bbad1bcf026d98b71df765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582824ff87244112d191cd7698d14f79"><td class="memItemLeft" align="right" valign="top"><a id="a582824ff87244112d191cd7698d14f79"></a>
typedef std::vector&lt; <a class="el" href="structfz_1_1GET__token__value.html">GET_token_value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GET_token_value_vec</b></td></tr>
<tr class="separator:a582824ff87244112d191cd7698d14f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac707a16b6f3ce32e16ceeb269cb05967"><td class="memItemLeft" align="right" valign="top"><a id="ac707a16b6f3ce32e16ceeb269cb05967"></a>
typedef std::vector&lt; <a class="el" href="structfz_1_1render__varpos.html">render_varpos</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>template_varpos</b></td></tr>
<tr class="separator:ac707a16b6f3ce32e16ceeb269cb05967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6816aa2a6ca096b5918902e6e261cc68"><td class="memItemLeft" align="right" valign="top"><a id="a6816aa2a6ca096b5918902e6e261cc68"></a>
typedef std::tuple&lt; unsigned int, unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ymd_tuple</b></td></tr>
<tr class="separator:a6816aa2a6ca096b5918902e6e261cc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca78c283fd0d2dd313804d0bfffdb0a0"><td class="memItemLeft" align="right" valign="top"><a id="aca78c283fd0d2dd313804d0bfffdb0a0"></a>
typedef std::set&lt; <a class="el" href="structfz_1_1NNLmod__update.html">NNLmod_update</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NNLmod_update_set</b></td></tr>
<tr class="separator:aca78c283fd0d2dd313804d0bfffdb0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609e8de3728db723e67ea620749e6cac"><td class="memItemLeft" align="right" valign="top"><a id="a609e8de3728db723e67ea620749e6cac"></a>
typedef std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a609e8de3728db723e67ea620749e6cac">GraphIDcache</a></td></tr>
<tr class="memdesc:a609e8de3728db723e67ea620749e6cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formalizer specific base types for ease of modification (container types) <br /></td></tr>
<tr class="separator:a609e8de3728db723e67ea620749e6cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a95a7b508456ccb1691f487ed136d52d4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a95a7b508456ccb1691f487ed136d52d4">exit_status_code</a> { <br />
&#160;&#160;<b>exit_ok</b> = 0
, <b>exit_general_error</b> = 1
, <b>exit_database_error</b> = 2
, <b>exit_unknown_option</b> = 3
, <br />
&#160;&#160;<b>exit_cancel</b> = 4
, <b>exit_conversion_error</b> = 5
, <b>exit_DIL_error</b> = 6
, <b>exit_unable_to_stack_clean_exit</b> = 7
, <br />
&#160;&#160;<b>exit_command_line_error</b> = 8
, <b>exit_file_error</b> = 9
, <b>exit_missing_parameter</b> = 10
, <b>exit_missing_data</b> = 11
, <br />
&#160;&#160;<b>exit_bad_config_value</b> = 12
, <b>exit_resident_graph_missing</b> = 13
, <b>exit_bad_request_data</b> = 14
, <b>exit_communication_error</b> = 15
, <br />
&#160;&#160;<a class="el" href="namespacefz.html#a95a7b508456ccb1691f487ed136d52d4a705b1561a859fa4dfba9b3e3045d9f24">exit_NUMENUMS</a>
<br />
 }</td></tr>
<tr class="memdesc:a95a7b508456ccb1691f487ed136d52d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standardized exit codes for the Formalizer environment.  <a href="namespacefz.html#a95a7b508456ccb1691f487ed136d52d4">More...</a><br /></td></tr>
<tr class="separator:a95a7b508456ccb1691f487ed136d52d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68bce1f115f5d6e9618e1ea1518e30a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ad68bce1f115f5d6e9618e1ea1518e30a">PQ_Command_Variant</a> { <a class="el" href="namespacefz.html#ad68bce1f115f5d6e9618e1ea1518e30aaa635b87c5a7bfc8edbc3de36ac5d63c2">pq_command_runsilent</a>
, <a class="el" href="namespacefz.html#ad68bce1f115f5d6e9618e1ea1518e30aac0b188614f2dcefaa28cee9e0c37ddde">pq_command_log</a>
, <a class="el" href="namespacefz.html#ad68bce1f115f5d6e9618e1ea1518e30aac66415affc9c53289c3b68d2b6d3a432">pq_command_simulate</a>
, <b>_pqcommand_NUM</b>
 }</td></tr>
<tr class="separator:ad68bce1f115f5d6e9618e1ea1518e30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c45e5e183774ed3322e5c3d445b3f70"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">td_property</a> { <br />
&#160;&#160;<b>unspecified</b>
, <b>inherit</b>
, <b>variable</b>
, <b>fixed</b>
, <br />
&#160;&#160;<b>exact</b>
, <b>_tdprop_num</b>
<br />
 }</td></tr>
<tr class="memdesc:a6c45e5e183774ed3322e5c3d445b3f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">For more information about td_property values, as well as future expansions, please see the Formalizer documentation section <a href="https://docs.google.com/document/d/1rYPFgzFgjkF1xGx3uABiXiaDR5sfmOzqYQRqSntcyyY/edit#heading=h.nu3mb52d1k6n">Target date parameters in Graph v2.0+</a>.  <a href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">More...</a><br /></td></tr>
<tr class="separator:a6c45e5e183774ed3322e5c3d445b3f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457fe66ad9a864a8062ed33117e53841"><td class="memItemLeft" align="right" valign="top"><a id="a457fe66ad9a864a8062ed33117e53841"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>td_pattern</b> { <br />
&#160;&#160;<b>patt_daily</b>
, <b>patt_workdays</b>
, <b>patt_weekly</b>
, <b>patt_biweekly</b>
, <br />
&#160;&#160;<b>patt_monthly</b>
, <b>patt_endofmonthoffset</b>
, <b>patt_yearly</b>
, <b>OLD_patt_span</b>
, <br />
&#160;&#160;<b>patt_nonperiodic</b>
, <b>_patt_num</b>
<br />
 }</td></tr>
<tr class="separator:a457fe66ad9a864a8062ed33117e53841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4e820f8f63e643b57168e3053e4cc0"><td class="memItemLeft" align="right" valign="top"><a id="a9f4e820f8f63e643b57168e3053e4cc0"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a9f4e820f8f63e643b57168e3053e4cc0">Prerequisite_States</a> { <b>unsolved</b> = 0
, <b>unfulfilled</b> = 1
, <b>fulfilled</b> = 2
, <b>numPrerequisite_States</b>
 }</td></tr>
<tr class="memdesc:a9f4e820f8f63e643b57168e3053e4cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions for working with @PREREQS:...@ and @PROVIDES:...@ data in Nodes. <br /></td></tr>
<tr class="separator:a9f4e820f8f63e643b57168e3053e4cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0394e24a5de7f64b2802f12007a2f3c1"><td class="memItemLeft" align="right" valign="top"><a id="a0394e24a5de7f64b2802f12007a2f3c1"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Graph_modification_request</b> { <br />
&#160;&#160;<b>graphmod_add_node</b>
, <b>graphmod_add_edge</b>
, <b>namedlist_add</b>
, <b>namedlist_remove</b>
, <br />
&#160;&#160;<b>namedlist_delete</b>
, <b>graphmod_edit_node</b>
, <b>graphmod_edit_edge</b>
, <b>batchmod_targetdates</b>
, <br />
&#160;&#160;<b>batchmod_tpassrepeating</b>
, <b>graphmod_remove_edge</b>
, <b>NUM_graphmod_requests</b>
, <b>graphmod_add_node</b>
, <br />
&#160;&#160;<b>graphmod_add_edge</b>
, <b>namedlist_add</b>
, <b>namedlist_remove</b>
, <b>namedlist_delete</b>
, <br />
&#160;&#160;<b>graphmod_edit_node</b>
, <b>graphmod_edit_edge</b>
, <b>batchmod_targetdates</b>
, <b>batchmod_tpassrepeating</b>
, <br />
&#160;&#160;<b>NUM_graphmod_requests</b>
<br />
 }</td></tr>
<tr class="separator:a0394e24a5de7f64b2802f12007a2f3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fa1d38b1f961757e7f352be3764d8f"><td class="memItemLeft" align="right" valign="top"><a id="ab6fa1d38b1f961757e7f352be3764d8f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>pq_Tfields</b> { <br />
&#160;&#160;<b>pqt_id</b>
, <b>pqt_supid</b>
, <b>pqt_tag</b>
, <b>pqt_title</b>
, <br />
&#160;&#160;<b>pqt_keyword</b>
, <b>pqt_relevance</b>
, <b>_pqt_NUM</b>
, <b>pqt_id</b>
, <br />
&#160;&#160;<b>pqt_supid</b>
, <b>pqt_tag</b>
, <b>pqt_title</b>
, <b>pqt_keyword</b>
, <br />
&#160;&#160;<b>pqt_relevance</b>
, <b>_pqt_NUM</b>
<br />
 }</td></tr>
<tr class="separator:ab6fa1d38b1f961757e7f352be3764d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7349c0b699f57fccff3f53513df94839"><td class="memItemLeft" align="right" valign="top"><a id="a7349c0b699f57fccff3f53513df94839"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>pq_Nfields</b> { <br />
&#160;&#160;<b>pqn_id</b>
, <b>pqn_topics</b>
, <b>pqn_topicrelevance</b>
, <b>pqn_valuation</b>
, <br />
&#160;&#160;<b>pqn_completion</b>
, <b>pqn_required</b>
, <b>pqn_text</b>
, <b>pqn_targetdate</b>
, <br />
&#160;&#160;<b>pqn_tdproperty</b>
, <b>pqn_isperiodic</b>
, <b>pqn_tdperiodic</b>
, <b>pqn_tdevery</b>
, <br />
&#160;&#160;<b>pqn_tdspan</b>
, <b>_pqn_NUM</b>
, <b>pqn_id</b>
, <b>pqn_topics</b>
, <br />
&#160;&#160;<b>pqn_topicrelevance</b>
, <b>pqn_valuation</b>
, <b>pqn_completion</b>
, <b>pqn_required</b>
, <br />
&#160;&#160;<b>pqn_text</b>
, <b>pqn_targetdate</b>
, <b>pqn_tdproperty</b>
, <b>pqn_isperiodic</b>
, <br />
&#160;&#160;<b>pqn_tdperiodic</b>
, <b>pqn_tdevery</b>
, <b>pqn_tdspan</b>
, <b>_pqn_NUM</b>
<br />
 }</td></tr>
<tr class="separator:a7349c0b699f57fccff3f53513df94839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbebf38d141f22704b7eedd52437b28"><td class="memItemLeft" align="right" valign="top"><a id="a2fbebf38d141f22704b7eedd52437b28"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>pq_Efields</b> { <br />
&#160;&#160;<b>pqe_id</b>
, <b>pqe_dependency</b>
, <b>pqe_significance</b>
, <b>pqe_importance</b>
, <br />
&#160;&#160;<b>pqe_urgency</b>
, <b>pqe_priority</b>
, <b>_pqe_NUM</b>
, <b>pqe_id</b>
, <br />
&#160;&#160;<b>pqe_dependency</b>
, <b>pqe_significance</b>
, <b>pqe_importance</b>
, <b>pqe_urgency</b>
, <br />
&#160;&#160;<b>pqe_priority</b>
, <b>_pqe_NUM</b>
<br />
 }</td></tr>
<tr class="separator:a2fbebf38d141f22704b7eedd52437b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735a3a71054f2c2c507b5faadcdadef8"><td class="memItemLeft" align="right" valign="top"><a id="a735a3a71054f2c2c507b5faadcdadef8"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>pq_NNLfields</b> { <br />
&#160;&#160;<b>pqNNL_name</b>
, <b>pqNNL_features</b>
, <b>pqNNL_maxsize</b>
, <b>pqNNL_nodeids</b>
, <br />
&#160;&#160;<b>_pqNNL_NUM</b>
, <b>pqNNL_name</b>
, <b>pqNNL_features</b>
, <b>pqNNL_maxsize</b>
, <br />
&#160;&#160;<b>pqNNL_nodeids</b>
, <b>_pqNNL_NUM</b>
<br />
 }</td></tr>
<tr class="separator:a735a3a71054f2c2c507b5faadcdadef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95dfb87788069ae1e375e9c406b048b"><td class="memItemLeft" align="right" valign="top"><a id="aa95dfb87788069ae1e375e9c406b048b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>text_interpretation</b> : unsigned long { <br />
&#160;&#160;<b>raw</b> = 0
, <b>detect_links</b> = 0b0000'0000'0000'0001
, <b>emptyline_is_par</b> = 0b0000'0000'0000'0010
, <b>full_markdown</b> = 0b0000'0000'0000'0100
, <br />
&#160;&#160;<b>NUM_interpretations</b>
<br />
 }</td></tr>
<tr class="separator:aa95dfb87788069ae1e375e9c406b048b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e74abc9e97d07b67a3476acdf41b9a"><td class="memItemLeft" align="right" valign="top"><a id="a99e74abc9e97d07b67a3476acdf41b9a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>JSON_element_type</b> { <br />
&#160;&#160;<b>json_string</b> = 0
, <b>json_number</b> = 1
, <b>json_flag</b> = 2
, <b>json_block</b> = 3
, <br />
&#160;&#160;<b>NUM_json_element_types</b>
<br />
 }</td></tr>
<tr class="separator:a99e74abc9e97d07b67a3476acdf41b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd9cd34cd3b99c03b59b7054f5709df"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a6fd9cd34cd3b99c03b59b7054f5709df">pq_LBfields</a> { <b>pqlb_id</b>
, <b>_pqlb_NUM</b>
 }</td></tr>
<tr class="memdesc:a6fd9cd34cd3b99c03b59b7054f5709df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log Breakpoint fields:  <a href="namespacefz.html#a6fd9cd34cd3b99c03b59b7054f5709df">More...</a><br /></td></tr>
<tr class="separator:a6fd9cd34cd3b99c03b59b7054f5709df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229dcedb04cce4ee361097ae545fec1a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a229dcedb04cce4ee361097ae545fec1a">pq_LCfields</a> { <b>pqlc_id</b>
, <b>pqlc_nid</b>
, <b>pqlc_tclose</b>
, <b>_pqlc_NUM</b>
 }</td></tr>
<tr class="memdesc:a229dcedb04cce4ee361097ae545fec1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log chunk fields:  <a href="namespacefz.html#a229dcedb04cce4ee361097ae545fec1a">More...</a><br /></td></tr>
<tr class="separator:a229dcedb04cce4ee361097ae545fec1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adf8c508a2a57973cb07be9a12d345f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a1adf8c508a2a57973cb07be9a12d345f">pq_LEfields</a> { <b>pqle_id</b>
, <b>pqle_nid</b>
, <b>pqle_text</b>
, <b>_pqle_NUM</b>
 }</td></tr>
<tr class="memdesc:a1adf8c508a2a57973cb07be9a12d345f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log entry fields:  <a href="namespacefz.html#a1adf8c508a2a57973cb07be9a12d345f">More...</a><br /></td></tr>
<tr class="separator:a1adf8c508a2a57973cb07be9a12d345f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef05dd6bfa4d4a09d3eace4949b6fab0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aef05dd6bfa4d4a09d3eace4949b6fab0">ReferenceTime_t</a> : std::time_t { <br />
&#160;&#160;<a class="el" href="namespacefz.html#aef05dd6bfa4d4a09d3eace4949b6fab0a627f41ff4b5237b95dea7d92863e3b15">RTt_invalid_time_stamp</a> = -34403
, <a class="el" href="namespacefz.html#aef05dd6bfa4d4a09d3eace4949b6fab0a328419ab650b1af199fdb58a44105aaa">RTt_unspecified</a> = -1
, <a class="el" href="namespacefz.html#aef05dd6bfa4d4a09d3eace4949b6fab0a9803c17416a694a786f71407e6276512">RTt_unconnected</a> = -2
, <b>RTt_unix_epoch_start</b> = 0
, <br />
&#160;&#160;<b>RTt_oneday</b> = (24*60*60)
, <a class="el" href="namespacefz.html#aef05dd6bfa4d4a09d3eace4949b6fab0ad567131680cdfe5720218682688975a4">RTt_maxtime</a> = std::numeric_limits&lt;time_t&gt;::max()
<br />
 }</td></tr>
<tr class="separator:aef05dd6bfa4d4a09d3eace4949b6fab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0394e24a5de7f64b2802f12007a2f3c1"><td class="memItemLeft" align="right" valign="top"><a id="a0394e24a5de7f64b2802f12007a2f3c1"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Graph_modification_request</b> { <br />
&#160;&#160;<b>graphmod_add_node</b>
, <b>graphmod_add_edge</b>
, <b>namedlist_add</b>
, <b>namedlist_remove</b>
, <br />
&#160;&#160;<b>namedlist_delete</b>
, <b>graphmod_edit_node</b>
, <b>graphmod_edit_edge</b>
, <b>batchmod_targetdates</b>
, <br />
&#160;&#160;<b>batchmod_tpassrepeating</b>
, <b>graphmod_remove_edge</b>
, <b>NUM_graphmod_requests</b>
, <b>graphmod_add_node</b>
, <br />
&#160;&#160;<b>graphmod_add_edge</b>
, <b>namedlist_add</b>
, <b>namedlist_remove</b>
, <b>namedlist_delete</b>
, <br />
&#160;&#160;<b>graphmod_edit_node</b>
, <b>graphmod_edit_edge</b>
, <b>batchmod_targetdates</b>
, <b>batchmod_tpassrepeating</b>
, <br />
&#160;&#160;<b>NUM_graphmod_requests</b>
<br />
 }</td></tr>
<tr class="separator:a0394e24a5de7f64b2802f12007a2f3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fa1d38b1f961757e7f352be3764d8f"><td class="memItemLeft" align="right" valign="top"><a id="ab6fa1d38b1f961757e7f352be3764d8f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>pq_Tfields</b> { <br />
&#160;&#160;<b>pqt_id</b>
, <b>pqt_supid</b>
, <b>pqt_tag</b>
, <b>pqt_title</b>
, <br />
&#160;&#160;<b>pqt_keyword</b>
, <b>pqt_relevance</b>
, <b>_pqt_NUM</b>
, <b>pqt_id</b>
, <br />
&#160;&#160;<b>pqt_supid</b>
, <b>pqt_tag</b>
, <b>pqt_title</b>
, <b>pqt_keyword</b>
, <br />
&#160;&#160;<b>pqt_relevance</b>
, <b>_pqt_NUM</b>
<br />
 }</td></tr>
<tr class="separator:ab6fa1d38b1f961757e7f352be3764d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7349c0b699f57fccff3f53513df94839"><td class="memItemLeft" align="right" valign="top"><a id="a7349c0b699f57fccff3f53513df94839"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>pq_Nfields</b> { <br />
&#160;&#160;<b>pqn_id</b>
, <b>pqn_topics</b>
, <b>pqn_topicrelevance</b>
, <b>pqn_valuation</b>
, <br />
&#160;&#160;<b>pqn_completion</b>
, <b>pqn_required</b>
, <b>pqn_text</b>
, <b>pqn_targetdate</b>
, <br />
&#160;&#160;<b>pqn_tdproperty</b>
, <b>pqn_isperiodic</b>
, <b>pqn_tdperiodic</b>
, <b>pqn_tdevery</b>
, <br />
&#160;&#160;<b>pqn_tdspan</b>
, <b>_pqn_NUM</b>
, <b>pqn_id</b>
, <b>pqn_topics</b>
, <br />
&#160;&#160;<b>pqn_topicrelevance</b>
, <b>pqn_valuation</b>
, <b>pqn_completion</b>
, <b>pqn_required</b>
, <br />
&#160;&#160;<b>pqn_text</b>
, <b>pqn_targetdate</b>
, <b>pqn_tdproperty</b>
, <b>pqn_isperiodic</b>
, <br />
&#160;&#160;<b>pqn_tdperiodic</b>
, <b>pqn_tdevery</b>
, <b>pqn_tdspan</b>
, <b>_pqn_NUM</b>
<br />
 }</td></tr>
<tr class="separator:a7349c0b699f57fccff3f53513df94839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbebf38d141f22704b7eedd52437b28"><td class="memItemLeft" align="right" valign="top"><a id="a2fbebf38d141f22704b7eedd52437b28"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>pq_Efields</b> { <br />
&#160;&#160;<b>pqe_id</b>
, <b>pqe_dependency</b>
, <b>pqe_significance</b>
, <b>pqe_importance</b>
, <br />
&#160;&#160;<b>pqe_urgency</b>
, <b>pqe_priority</b>
, <b>_pqe_NUM</b>
, <b>pqe_id</b>
, <br />
&#160;&#160;<b>pqe_dependency</b>
, <b>pqe_significance</b>
, <b>pqe_importance</b>
, <b>pqe_urgency</b>
, <br />
&#160;&#160;<b>pqe_priority</b>
, <b>_pqe_NUM</b>
<br />
 }</td></tr>
<tr class="separator:a2fbebf38d141f22704b7eedd52437b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735a3a71054f2c2c507b5faadcdadef8"><td class="memItemLeft" align="right" valign="top"><a id="a735a3a71054f2c2c507b5faadcdadef8"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>pq_NNLfields</b> { <br />
&#160;&#160;<b>pqNNL_name</b>
, <b>pqNNL_features</b>
, <b>pqNNL_maxsize</b>
, <b>pqNNL_nodeids</b>
, <br />
&#160;&#160;<b>_pqNNL_NUM</b>
, <b>pqNNL_name</b>
, <b>pqNNL_features</b>
, <b>pqNNL_maxsize</b>
, <br />
&#160;&#160;<b>pqNNL_nodeids</b>
, <b>_pqNNL_NUM</b>
<br />
 }</td></tr>
<tr class="separator:a735a3a71054f2c2c507b5faadcdadef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7d16bab09bae4a92f744431bc98591"><td class="memItemLeft" align="right" valign="top"><a id="a3e7d16bab09bae4a92f744431bc98591"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>http_response_code</b> { <b>http_ok</b> = 200
, <b>http_bad_request</b> = 400
, <b>http_not_found</b> = 404
 }</td></tr>
<tr class="separator:a3e7d16bab09bae4a92f744431bc98591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbc7396c54a5297ce62bfad68c98cb2"><td class="memItemLeft" align="right" valign="top"><a id="a2cbc7396c54a5297ce62bfad68c98cb2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>render_error_t</b> { <br />
&#160;&#160;<b>rerr_ok</b> = 0
, <b>rerr_missing_value</b> = 1
, <b>rerr_empty_template</b> = 2
, <b>rerr_no_variable_values</b> = 3
, <br />
&#160;&#160;<b>rerr_empty_variable_label</b> = 4
, <b>rerr_unused_variable_value</b> = 5
<br />
 }</td></tr>
<tr class="separator:a2cbc7396c54a5297ce62bfad68c98cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e88d506e1048c8674fe9750a6bc2198"><td class="memItemLeft" align="right" valign="top"><a id="a4e88d506e1048c8674fe9750a6bc2198"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>day_of_week</b> : unsigned int { <br />
&#160;&#160;<b>dow_Sunday</b> = 0
, <b>dow_Monday</b> = 1
, <b>dow_Tuesday</b> = 2
, <b>dow_Wednesday</b> = 3
, <br />
&#160;&#160;<b>dow_Thursday</b> = 4
, <b>dow_Friday</b> = 5
, <b>dow_Saturday</b> = 6
, <b>_num_dow</b>
<br />
 }</td></tr>
<tr class="separator:a4e88d506e1048c8674fe9750a6bc2198"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4ca73d5dc180afb17801020610bc26a1"><td class="memItemLeft" align="right" valign="top"><a id="a4ca73d5dc180afb17801020610bc26a1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ping_server</b> (const std::string server_IPaddr_str, uint16_t port_number)</td></tr>
<tr class="separator:a4ca73d5dc180afb17801020610bc26a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608d1e2c14bc80d5b535512433cad880"><td class="memItemLeft" align="right" valign="top"><a id="a608d1e2c14bc80d5b535512433cad880"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>http_GET</b> (const std::string server_IPaddr_str, uint16_t port_number, const std::string url, std::string &amp;response_str)</td></tr>
<tr class="separator:a608d1e2c14bc80d5b535512433cad880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1818f992983509d9d38a5d7a629545f"><td class="memItemLeft" align="right" valign="top"><a id="ac1818f992983509d9d38a5d7a629545f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>NNLreq_update_shortlist</b> (const std::string server_IPaddr_str, uint16_t port_number)</td></tr>
<tr class="separator:ac1818f992983509d9d38a5d7a629545f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd34bad3bec22615ba4ffda20aa2d2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a8bd34bad3bec22615ba4ffda20aa2d2d">file_to_buffer</a> (std::string path, std::vector&lt; char &gt; &amp;buf, std::ifstream::iostate *readstate=nullptr)</td></tr>
<tr class="memdesc:a8bd34bad3bec22615ba4ffda20aa2d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the full contents of a binary file into a buffer.  <a href="namespacefz.html#a8bd34bad3bec22615ba4ffda20aa2d2d">More...</a><br /></td></tr>
<tr class="separator:a8bd34bad3bec22615ba4ffda20aa2d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa839f53d8d85079811f85257501ed5b1"><td class="memItemLeft" align="right" valign="top"><a id="aa839f53d8d85079811f85257501ed5b1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aa839f53d8d85079811f85257501ed5b1">URL_Decode</a> (const std::string str)</td></tr>
<tr class="memdesc:aa839f53d8d85079811f85257501ed5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert URL nn -codes into characters and '+' signs into spaces. <br /></td></tr>
<tr class="separator:aa839f53d8d85079811f85257501ed5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fc3f13405d901ac7ecbf65ae2ae712"><td class="memItemLeft" align="right" valign="top"><a id="a20fc3f13405d901ac7ecbf65ae2ae712"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>coreversion</b> ()</td></tr>
<tr class="separator:a20fc3f13405d901ac7ecbf65ae2ae712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7838e7b982bd5a885f69f42a8fa929c"><td class="memItemLeft" align="right" valign="top">Detailed_Items_List *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aa7838e7b982bd5a885f69f42a8fa929c">get_DIL_Graph</a> ()</td></tr>
<tr class="memdesc:aa7838e7b982bd5a885f69f42a8fa929c"><td class="mdescLeft">&#160;</td><td class="mdescRight">To USE and COMPILE :  <a href="namespacefz.html#aa7838e7b982bd5a885f69f42a8fa929c">More...</a><br /></td></tr>
<tr class="separator:aa7838e7b982bd5a885f69f42a8fa929c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004bd737f1c412b124eaf7ca6df90603"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a004bd737f1c412b124eaf7ca6df90603">get_DIL_Topics_File_List</a> ()</td></tr>
<tr class="memdesc:a004bd737f1c412b124eaf7ca6df90603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the actual set of Topical DIL Files that exist in the dil2al base directory.  <a href="namespacefz.html#a004bd737f1c412b124eaf7ca6df90603">More...</a><br /></td></tr>
<tr class="separator:a004bd737f1c412b124eaf7ca6df90603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e9d57226726175af8c8e276edd0c58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ac5e9d57226726175af8c8e276edd0c58">get_DIL_entry_num_superiors</a> (DIL_entry *e)</td></tr>
<tr class="memdesc:ac5e9d57226726175af8c8e276edd0c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of connections from a DIL entry to Superiors.  <a href="namespacefz.html#ac5e9d57226726175af8c8e276edd0c58">More...</a><br /></td></tr>
<tr class="separator:ac5e9d57226726175af8c8e276edd0c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02517c2cf1052f55bb388a0808fdaa1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a02517c2cf1052f55bb388a0808fdaa1b">get_DIL_hierarchy_num_connections</a> (Detailed_Items_List *dil)</td></tr>
<tr class="memdesc:a02517c2cf1052f55bb388a0808fdaa1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of connections in a DIL hierarchy.  <a href="namespacefz.html#a02517c2cf1052f55bb388a0808fdaa1b">More...</a><br /></td></tr>
<tr class="separator:a02517c2cf1052f55bb388a0808fdaa1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd066a32696261830f98ca59ce4a7f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a3cd066a32696261830f98ca59ce4a7f0">Clean_Exit</a> (int ecode)</td></tr>
<tr class="memdesc:a3cd066a32696261830f98ca59ce4a7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after yourself before you exit.  <a href="namespacefz.html#a3cd066a32696261830f98ca59ce4a7f0">More...</a><br /></td></tr>
<tr class="separator:a3cd066a32696261830f98ca59ce4a7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf5deaae1932ca5ec6dbcbd6a352f0f"><td class="memItemLeft" align="right" valign="top"><a id="a6bf5deaae1932ca5ec6dbcbd6a352f0f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a6bf5deaae1932ca5ec6dbcbd6a352f0f">standard_error</a> (std::string error_message, const char *problem__func__)</td></tr>
<tr class="memdesc:a6bf5deaae1932ca5ec6dbcbd6a352f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that combines ADDERROR and VERBOSEERR without exit. Always returns false. <br /></td></tr>
<tr class="separator:a6bf5deaae1932ca5ec6dbcbd6a352f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d14200e626d26d8b0ed7a8bbe6c2ce9"><td class="memItemLeft" align="right" valign="top"><a id="a0d14200e626d26d8b0ed7a8bbe6c2ce9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a0d14200e626d26d8b0ed7a8bbe6c2ce9">standard_warning</a> (std::string warn_message, const char *warning__func__)</td></tr>
<tr class="memdesc:a0d14200e626d26d8b0ed7a8bbe6c2ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that combines ADDWARNING and VERYVERBOSEOUT without exit, and without return value. <br /></td></tr>
<tr class="separator:a0d14200e626d26d8b0ed7a8bbe6c2ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bde9da1de78d7bc0492b22eba9630e8"><td class="memItemLeft" align="right" valign="top">PGconn *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a9bde9da1de78d7bc0492b22eba9630e8">connection_setup_pq</a> (std::string dbname)</td></tr>
<tr class="memdesc:a9bde9da1de78d7bc0492b22eba9630e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up a connection with an existing Postgres database.  <a href="namespacefz.html#a9bde9da1de78d7bc0492b22eba9630e8">More...</a><br /></td></tr>
<tr class="separator:a9bde9da1de78d7bc0492b22eba9630e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a653de26479eb7d85b850ec2918c2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aa1a653de26479eb7d85b850ec2918c2a">simple_call_pq</a> (PGconn *conn, std::string astr)</td></tr>
<tr class="memdesc:aa1a653de26479eb7d85b850ec2918c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a simple action call to a Postgres database.  <a href="namespacefz.html#aa1a653de26479eb7d85b850ec2918c2a">More...</a><br /></td></tr>
<tr class="separator:aa1a653de26479eb7d85b850ec2918c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d24b6e4b1323e5d5687d184aa48fb4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a7d24b6e4b1323e5d5687d184aa48fb4a">query_call_pq</a> (PGconn *conn, std::string qstr, bool request_single_row_mode)</td></tr>
<tr class="memdesc:a7d24b6e4b1323e5d5687d184aa48fb4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch a Postgres query for asynchronous processing in batch or single row mode.  <a href="namespacefz.html#a7d24b6e4b1323e5d5687d184aa48fb4a">More...</a><br /></td></tr>
<tr class="separator:a7d24b6e4b1323e5d5687d184aa48fb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b42530ac38402a5656af5bdcac5be6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a59b42530ac38402a5656af5bdcac5be6">sample_query_data</a> (PGconn *conn, unsigned int rstart, unsigned int rend, unsigned int cstart, unsigned int cend, std::string &amp;databufstr)</td></tr>
<tr class="memdesc:a59b42530ac38402a5656af5bdcac5be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that dumps several rows of data to a string buffer for easy inspection.  <a href="namespacefz.html#a59b42530ac38402a5656af5bdcac5be6">More...</a><br /></td></tr>
<tr class="separator:a59b42530ac38402a5656af5bdcac5be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44280392e614e1145d3c5a27aa640b59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a44280392e614e1145d3c5a27aa640b59">create_Formalizer_schema_pq</a> (PGconn *conn, std::string schemaname)</td></tr>
<tr class="memdesc:a44280392e614e1145d3c5a27aa640b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new database schema for Formalizer data.  <a href="namespacefz.html#a44280392e614e1145d3c5a27aa640b59">More...</a><br /></td></tr>
<tr class="separator:a44280392e614e1145d3c5a27aa640b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26caa1b821a4715dbec90c174a95e97"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab26caa1b821a4715dbec90c174a95e97">array_from_pq</a> (std::string pq_array_str)</td></tr>
<tr class="memdesc:ab26caa1b821a4715dbec90c174a95e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a single string containing Postgres query output that represents an array into a vector of strings.  <a href="namespacefz.html#ab26caa1b821a4715dbec90c174a95e97">More...</a><br /></td></tr>
<tr class="separator:ab26caa1b821a4715dbec90c174a95e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852bc7a9cba819521f01ce09cc041461"><td class="memItemLeft" align="right" valign="top"><a id="a852bc7a9cba819521f01ce09cc041461"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a852bc7a9cba819521f01ce09cc041461">TimeStamp_pq</a> (time_t t)</td></tr>
<tr class="memdesc:a852bc7a9cba819521f01ce09cc041461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the UTC / Local Time convention built into TimeStamp(). <br /></td></tr>
<tr class="separator:a852bc7a9cba819521f01ce09cc041461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15aaf01d7bc6c1c2a92065d3b03312b"><td class="memItemLeft" align="right" valign="top"><a id="ac15aaf01d7bc6c1c2a92065d3b03312b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>TimeStamp_to_TimeStamp_pq</b> (const std::string &amp;tstamp)</td></tr>
<tr class="separator:ac15aaf01d7bc6c1c2a92065d3b03312b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a40b1a728ffe05a3aca94bc24daff0e"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a8a40b1a728ffe05a3aca94bc24daff0e">epochtime_from_timestamp_pq</a> (std::string pqtimestamp)</td></tr>
<tr class="memdesc:a8a40b1a728ffe05a3aca94bc24daff0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Postgres query result time stamp strings to Unix time, for example, for <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> target date parameter.  <a href="namespacefz.html#a8a40b1a728ffe05a3aca94bc24daff0e">More...</a><br /></td></tr>
<tr class="separator:a8a40b1a728ffe05a3aca94bc24daff0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e121747c47e1ca49747225bf5496af"><td class="memItemLeft" align="right" valign="top"><a id="ae3e121747c47e1ca49747225bf5496af"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae3e121747c47e1ca49747225bf5496af">is_not_digit</a> (int c)</td></tr>
<tr class="memdesc:ae3e121747c47e1ca49747225bf5496af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invere of &lt;cctype&gt;:isdigit(). <br /></td></tr>
<tr class="separator:ae3e121747c47e1ca49747225bf5496af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23b82243a12ae2b0d35ccb70d785857"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aa23b82243a12ae2b0d35ccb70d785857">shellcmd2str</a> (std::string cmd)</td></tr>
<tr class="memdesc:aa23b82243a12ae2b0d35ccb70d785857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a shell command and retrieve the standard output as a string.  <a href="namespacefz.html#aa23b82243a12ae2b0d35ccb70d785857">More...</a><br /></td></tr>
<tr class="separator:aa23b82243a12ae2b0d35ccb70d785857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303e1d94ae3679f5fcc99dced6137cb2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a303e1d94ae3679f5fcc99dced6137cb2">to_precision_string</a> (double d, unsigned int p, char fillchar, unsigned int w)</td></tr>
<tr class="memdesc:a303e1d94ae3679f5fcc99dced6137cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print double to string with specific precision.  <a href="namespacefz.html#a303e1d94ae3679f5fcc99dced6137cb2">More...</a><br /></td></tr>
<tr class="separator:a303e1d94ae3679f5fcc99dced6137cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a30fb04b5721cd05047bd4088fb8b0"><td class="memTemplParams" colspan="2">template&lt;typename Out &gt; </td></tr>
<tr class="memitem:a45a30fb04b5721cd05047bd4088fb8b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefz.html#a45a30fb04b5721cd05047bd4088fb8b0">split</a> (const std::string &amp;s, char delim, Out result)</td></tr>
<tr class="memdesc:a45a30fb04b5721cd05047bd4088fb8b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put pieces of a string into a pre-constructed vector.  <a href="namespacefz.html#a45a30fb04b5721cd05047bd4088fb8b0">More...</a><br /></td></tr>
<tr class="separator:a45a30fb04b5721cd05047bd4088fb8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7dc083b5c0e84d7d715161e462a321f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab7dc083b5c0e84d7d715161e462a321f">split</a> (const std::string &amp;s, char delim)</td></tr>
<tr class="memdesc:ab7dc083b5c0e84d7d715161e462a321f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing pieces of a string.  <a href="namespacefz.html#ab7dc083b5c0e84d7d715161e462a321f">More...</a><br /></td></tr>
<tr class="separator:ab7dc083b5c0e84d7d715161e462a321f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58aac8e7a504103a1f9fd7f005f4a35"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab58aac8e7a504103a1f9fd7f005f4a35">join</a> (const std::vector&lt; std::string &gt; &amp;svec, const std::string delim)</td></tr>
<tr class="memdesc:ab58aac8e7a504103a1f9fd7f005f4a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient concatenation of strings from vector of strings with optional delimiter.  <a href="namespacefz.html#ab58aac8e7a504103a1f9fd7f005f4a35">More...</a><br /></td></tr>
<tr class="separator:ab58aac8e7a504103a1f9fd7f005f4a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5ff5bae87c93c494f719806115accc"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#afd5ff5bae87c93c494f719806115accc">ltrim</a> (std::string &amp;s, const char *t=&quot; \t\n\r\f\v&quot;)</td></tr>
<tr class="memdesc:afd5ff5bae87c93c494f719806115accc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim whitespace from the front of a string.  <a href="namespacefz.html#afd5ff5bae87c93c494f719806115accc">More...</a><br /></td></tr>
<tr class="separator:afd5ff5bae87c93c494f719806115accc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead256000e898b28976faa8072b5775e"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aead256000e898b28976faa8072b5775e">rtrim</a> (std::string &amp;s, const char *t=&quot; \t\n\r\f\v&quot;)</td></tr>
<tr class="memdesc:aead256000e898b28976faa8072b5775e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim whitespace from the end of a string.  <a href="namespacefz.html#aead256000e898b28976faa8072b5775e">More...</a><br /></td></tr>
<tr class="separator:aead256000e898b28976faa8072b5775e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56881d63a827a663822facaab67b15ef"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a56881d63a827a663822facaab67b15ef">trim</a> (std::string &amp;s, const char *t=&quot; \t\n\r\f\v&quot;)</td></tr>
<tr class="memdesc:a56881d63a827a663822facaab67b15ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim whitespace on both ends of a string.  <a href="namespacefz.html#a56881d63a827a663822facaab67b15ef">More...</a><br /></td></tr>
<tr class="separator:a56881d63a827a663822facaab67b15ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a232087a843af01f1e80879b0fee21"><td class="memItemLeft" align="right" valign="top"><a id="a62a232087a843af01f1e80879b0fee21"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>find_in_vec_of_strings</b> (const std::vector&lt; std::string &gt; &amp;svec, const std::string &amp;s)</td></tr>
<tr class="separator:a62a232087a843af01f1e80879b0fee21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655dfeed12628eb700f5f6e07a1d7874"><td class="memItemLeft" align="right" valign="top"><a id="a655dfeed12628eb700f5f6e07a1d7874"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>replace_char</b> (const std::string &amp;s, char c, char replacement='_')</td></tr>
<tr class="separator:a655dfeed12628eb700f5f6e07a1d7874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43dbf64dc00781a4cd1308f0842ebad4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a43dbf64dc00781a4cd1308f0842ebad4">get_enclosed_substring</a> (const std::string &amp;s, char open_enclosure, char close_enclosure, const std::string &amp;alt_return)</td></tr>
<tr class="memdesc:a43dbf64dc00781a4cd1308f0842ebad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and return a substring enclosed by opening and closing characters.  <a href="namespacefz.html#a43dbf64dc00781a4cd1308f0842ebad4">More...</a><br /></td></tr>
<tr class="separator:a43dbf64dc00781a4cd1308f0842ebad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a73be79a425edc61347438db441c2c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a3a73be79a425edc61347438db441c2c6">safecpy</a> (std::string &amp;str, char *buf, size_t bufsize)</td></tr>
<tr class="memdesc:a3a73be79a425edc61347438db441c2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely copy from a string (not null-terminated) to a char buffer of limited size.  <a href="namespacefz.html#a3a73be79a425edc61347438db441c2c6">More...</a><br /></td></tr>
<tr class="separator:a3a73be79a425edc61347438db441c2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8824c8c3167d53cc6ac73ff691b1b680"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a8824c8c3167d53cc6ac73ff691b1b680">tdsorted_Nodes_to_csv</a> (const <a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a> &amp;sorted_nodes, std::string &amp;csv_str)</td></tr>
<tr class="memdesc:a8824c8c3167d53cc6ac73ff691b1b680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a target date sorted multimap of <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> pointers into a string of <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> ID strings as comma separated values.  <a href="namespacefz.html#a8824c8c3167d53cc6ac73ff691b1b680">More...</a><br /></td></tr>
<tr class="separator:a8824c8c3167d53cc6ac73ff691b1b680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0e4f3360d11eff1bf1b4553a451180"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aba0e4f3360d11eff1bf1b4553a451180">valid_Node_ID</a> (std::string id_str, std::string &amp;formerror, <a class="el" href="structfz_1_1ID__TimeStamp.html">ID_TimeStamp</a> *id_timestamp)</td></tr>
<tr class="memdesc:aba0e4f3360d11eff1bf1b4553a451180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a string can be used to form a valid <a class="el" href="classfz_1_1Node__ID.html" title="Node ID that caches its ID stamp for frequent use.">Node_ID</a>.  <a href="namespacefz.html#aba0e4f3360d11eff1bf1b4553a451180">More...</a><br /></td></tr>
<tr class="separator:aba0e4f3360d11eff1bf1b4553a451180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4260c6b3087bdf22ce089216638d79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a0c4260c6b3087bdf22ce089216638d79">valid_Node_ID</a> (const <a class="el" href="structfz_1_1ID__TimeStamp.html">ID_TimeStamp</a> &amp;idT, std::string &amp;formerror)</td></tr>
<tr class="memdesc:a0c4260c6b3087bdf22ce089216638d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a <a class="el" href="structfz_1_1ID__TimeStamp.html" title="Timestamp IDs in the format required for Node IDs.">ID_TimeStamp</a> can be used as a valid <a class="el" href="classfz_1_1Node__ID.html" title="Node ID that caches its ID stamp for frequent use.">Node_ID</a>.  <a href="namespacefz.html#a0c4260c6b3087bdf22ce089216638d79">More...</a><br /></td></tr>
<tr class="separator:a0c4260c6b3087bdf22ce089216638d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572283837fdf4fbab8814064feb3b1b1"><td class="memItemLeft" align="right" valign="top"><a id="a572283837fdf4fbab8814064feb3b1b1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Node_ID_TimeStamp_to_string</b> (const <a class="el" href="structfz_1_1ID__TimeStamp.html">ID_TimeStamp</a> idT)</td></tr>
<tr class="separator:a572283837fdf4fbab8814064feb3b1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a96de898f3c588d8be7a65e37f5a579"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a1a96de898f3c588d8be7a65e37f5a579">Node_ID_TimeStamp_from_epochtime</a> (time_t t, uint8_t minor_id=0, bool throw_if_invalid=false)</td></tr>
<tr class="memdesc:a1a96de898f3c588d8be7a65e37f5a579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a usable <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> ID TimeStamp from an epoch time and a minor-ID.  <a href="namespacefz.html#a1a96de898f3c588d8be7a65e37f5a579">More...</a><br /></td></tr>
<tr class="separator:a1a96de898f3c588d8be7a65e37f5a579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e85506f22420b24d2373469e0344a7"><td class="memItemLeft" align="right" valign="top"><a id="a12e85506f22420b24d2373469e0344a7"></a>
time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a12e85506f22420b24d2373469e0344a7">Add_to_Date</a> (time_t t, td_pattern pattern, int every)</td></tr>
<tr class="memdesc:a12e85506f22420b24d2373469e0344a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to a date-time in accordance with a repeating pattern. <br /></td></tr>
<tr class="separator:a12e85506f22420b24d2373469e0344a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d50a9d0a462adb72a4607bff877fb70"><td class="memItemLeft" align="right" valign="top"><a id="a3d50a9d0a462adb72a4607bff877fb70"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Graph_Info</b> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, Graph_info_label_value_pairs &amp;graphinfo)</td></tr>
<tr class="separator:a3d50a9d0a462adb72a4607bff877fb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da9dc30dc25a44f1643f2ea01d09c42"><td class="memItemLeft" align="right" valign="top"><a id="a0da9dc30dc25a44f1643f2ea01d09c42"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Graph_Info_str</b> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="separator:a0da9dc30dc25a44f1643f2ea01d09c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb56744944c6982d19b47d67acfb8b3a"><td class="memItemLeft" align="right" valign="top"><a id="abb56744944c6982d19b47d67acfb8b3a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#abb56744944c6982d19b47d67acfb8b3a">List_Topics</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, std::string delim)</td></tr>
<tr class="memdesc:abb56744944c6982d19b47d67acfb8b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This collector of <a class="el" href="classfz_1_1Topic.html">Topic</a> tags purposely obtains them from the <a class="el" href="classfz_1_1Topic.html">Topic</a> objects instead of from the <code>topicbytag</code> map, so that it can be used to confirm that the structure is correctly formed. <br /></td></tr>
<tr class="separator:abb56744944c6982d19b47d67acfb8b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e0674fd7ba8de56c297a83534e8732"><td class="memItemLeft" align="right" valign="top"><a id="a91e0674fd7ba8de56c297a83534e8732"></a>
<a class="el" href="structfz_1_1Nodes__Stats.html">Nodes_Stats</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Nodes_statistics</b> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="separator:a91e0674fd7ba8de56c297a83534e8732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a108dc29595fd02792283686198d37"><td class="memItemLeft" align="right" valign="top"><a id="a74a108dc29595fd02792283686198d37"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Nodes_statistics_pairs</b> (const <a class="el" href="structfz_1_1Nodes__Stats.html">Nodes_Stats</a> &amp;nstats, Graph_info_label_value_pairs &amp;nodesinfo)</td></tr>
<tr class="separator:a74a108dc29595fd02792283686198d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088c8c3332b0396d852fc036b2597e7d"><td class="memItemLeft" align="right" valign="top"><a id="a088c8c3332b0396d852fc036b2597e7d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Nodes_statistics_string</b> (const <a class="el" href="structfz_1_1Nodes__Stats.html">Nodes_Stats</a> &amp;nstats)</td></tr>
<tr class="separator:a088c8c3332b0396d852fc036b2597e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab8d2f16f15ffd706d957c9cc1b1d8c"><td class="memItemLeft" align="right" valign="top"><a id="a9ab8d2f16f15ffd706d957c9cc1b1d8c"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>Edges_with_data</b> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="separator:a9ab8d2f16f15ffd706d957c9cc1b1d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f94c797bfe00822cb2905b11a9657b4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a4f94c797bfe00822cb2905b11a9657b4">Topic_IDs_to_Tags</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, std::vector&lt; <a class="el" href="namespacefz.html#afddacf07ad964643983aa625bd00aba8">Topic_ID</a> &gt; IDs_vec)</td></tr>
<tr class="memdesc:a4f94c797bfe00822cb2905b11a9657b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of <a class="el" href="classfz_1_1Topic.html">Topic</a> tag label strings for a specified vector of known <a class="el" href="classfz_1_1Topic.html">Topic</a> IDs from a specified <a class="el" href="classfz_1_1Graph.html">Graph</a>.  <a href="namespacefz.html#a4f94c797bfe00822cb2905b11a9657b4">More...</a><br /></td></tr>
<tr class="separator:a4f94c797bfe00822cb2905b11a9657b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0203e69125707c24e32c03ae3c3658d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae0203e69125707c24e32c03ae3c3658d">Node_Dependencies_fulldepth</a> (const <a class="el" href="classfz_1_1Node.html">Node</a> *node_ptr, Subtree_Branch_Map &amp;fulldepth_dependencies, const std::set&lt; <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a> &gt; &amp;do_not_follow, Node_Branch::branch_strength cmp_method=Node_Branch::none, float strength=-999.9)</td></tr>
<tr class="memdesc:ae0203e69125707c24e32c03ae3c3658d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all unique Nodes in the dependencies tree of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>.  <a href="namespacefz.html#ae0203e69125707c24e32c03ae3c3658d">More...</a><br /></td></tr>
<tr class="separator:ae0203e69125707c24e32c03ae3c3658d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c571fbebb6453dab7977124d200c85"><td class="memItemLeft" align="right" valign="top">map_of_subtrees_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ad3c571fbebb6453dab7977124d200c85">Threads_Subtrees</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, const std::string &amp;nnl_str, bool sort_by_targetdate=false, bool norepeated=false)</td></tr>
<tr class="memdesc:ad3c571fbebb6453dab7977124d200c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the subtrees that are the full dependencies of all Nodes in a Named Nodes List.  <a href="namespacefz.html#ad3c571fbebb6453dab7977124d200c85">More...</a><br /></td></tr>
<tr class="separator:ad3c571fbebb6453dab7977124d200c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182f20a5b6307ee3611d589e48520d3d"><td class="memItemLeft" align="right" valign="top"><a id="a182f20a5b6307ee3611d589e48520d3d"></a>
std::vector&lt; <a class="el" href="structfz_1_1Prerequisite.html">Prerequisite</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_prerequisites</b> (const <a class="el" href="classfz_1_1Node.html">Node</a> &amp;node, bool check_prerequisites=false)</td></tr>
<tr class="separator:a182f20a5b6307ee3611d589e48520d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a32e664badb729e9f3e97cc522a418e"><td class="memItemLeft" align="right" valign="top"><a id="a2a32e664badb729e9f3e97cc522a418e"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_provides_capabilities</b> (const <a class="el" href="classfz_1_1Node.html">Node</a> &amp;node)</td></tr>
<tr class="separator:a2a32e664badb729e9f3e97cc522a418e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97d9900d443111e431935202a7e8f8b"><td class="memItemLeft" align="right" valign="top"><a id="aa97d9900d443111e431935202a7e8f8b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>check_prerequisites_provided_by_dependencies</b> (const <a class="el" href="classfz_1_1Node.html">Node</a> &amp;node, std::vector&lt; <a class="el" href="structfz_1_1Prerequisite.html">Prerequisite</a> &gt; &amp;prereqs, int go_deeper=10)</td></tr>
<tr class="separator:aa97d9900d443111e431935202a7e8f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843459a8cad97af396b31c848c4740a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a843459a8cad97af396b31c848c4740a0">Nodes_subset</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, const <a class="el" href="structfz_1_1Node__Filter.html">Node_Filter</a> &amp;nodefilter)</td></tr>
<tr class="memdesc:a843459a8cad97af396b31c848c4740a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all Nodes that match a specified <a class="el" href="structfz_1_1Node__Filter.html" title="Filter class that helps construct filter specifications.">Node_Filter</a>.  <a href="namespacefz.html#a843459a8cad97af396b31c848c4740a0">More...</a><br /></td></tr>
<tr class="separator:a843459a8cad97af396b31c848c4740a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cd92dea2dd119cb33aac6e73a24762"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a02cd92dea2dd119cb33aac6e73a24762">Nodes_incomplete_by_targetdate</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a02cd92dea2dd119cb33aac6e73a24762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects all Nodes that are incomplete and lists them by (inherited) target date.  <a href="namespacefz.html#a02cd92dea2dd119cb33aac6e73a24762">More...</a><br /></td></tr>
<tr class="separator:a02cd92dea2dd119cb33aac6e73a24762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4004ea2f3e9d20cc1f44fb57252a6cd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a4004ea2f3e9d20cc1f44fb57252a6cd5">Nodes_with_repeats_by_targetdate</a> (const <a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a> &amp;sortednodes, time_t t_max, size_t N_max, bool limit_repeats_only=false)</td></tr>
<tr class="memdesc:a4004ea2f3e9d20cc1f44fb57252a6cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add virtual Nodes to produce a list where repeating Nodes appear at their pattern-specified repeat target dates.  <a href="namespacefz.html#a4004ea2f3e9d20cc1f44fb57252a6cd5">More...</a><br /></td></tr>
<tr class="separator:a4004ea2f3e9d20cc1f44fb57252a6cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeef89c75a7c538ca2e5512ec7bf92f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#afeef89c75a7c538ca2e5512ec7bf92f7">Nodes_incomplete_with_repeating_by_targetdate</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, time_t t_max, size_t N_max, bool limit_repeats_only=false)</td></tr>
<tr class="memdesc:afeef89c75a7c538ca2e5512ec7bf92f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns targetdate sorted Nodes that are incomplete, augmented with repeated instances.  <a href="namespacefz.html#afeef89c75a7c538ca2e5512ec7bf92f7">More...</a><br /></td></tr>
<tr class="separator:afeef89c75a7c538ca2e5512ec7bf92f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab002cb5dc36910bcd7e0541fa0a416e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab002cb5dc36910bcd7e0541fa0a416e2">Nodes_incomplete_and_repeating_by_targetdate</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:ab002cb5dc36910bcd7e0541fa0a416e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects all Nodes that are incomplete and repeating and lists them by (inherited) target date.  <a href="namespacefz.html#ab002cb5dc36910bcd7e0541fa0a416e2">More...</a><br /></td></tr>
<tr class="separator:ab002cb5dc36910bcd7e0541fa0a416e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9629548827f74d642a38b6a5f20fbef2"><td class="memItemLeft" align="right" valign="top">key_sorted_Nodes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a9629548827f74d642a38b6a5f20fbef2">Nodes_created_in_time_interval</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, time_t earliest, time_t before)</td></tr>
<tr class="memdesc:a9629548827f74d642a38b6a5f20fbef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects all Nodes that have <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> IDs (i.e.  <a href="namespacefz.html#a9629548827f74d642a38b6a5f20fbef2">More...</a><br /></td></tr>
<tr class="separator:a9629548827f74d642a38b6a5f20fbef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8be39e0425eacd0b6da8a8721861333"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ac8be39e0425eacd0b6da8a8721861333">Nodes_with_topic_by_targetdate</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, <a class="el" href="namespacefz.html#afddacf07ad964643983aa625bd00aba8">Topic_ID</a> id)</td></tr>
<tr class="memdesc:ac8be39e0425eacd0b6da8a8721861333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects all Nodes that include a specific <a class="el" href="classfz_1_1Topic.html">Topic</a> ID and lists them by (inherited) target date.  <a href="namespacefz.html#ac8be39e0425eacd0b6da8a8721861333">More...</a><br /></td></tr>
<tr class="separator:ac8be39e0425eacd0b6da8a8721861333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62ff7921be30fed8109b0b3a9ceab0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae62ff7921be30fed8109b0b3a9ceab0d">Nodes_in_list_by_targetdate</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, <a class="el" href="structfz_1_1Named__Node__List.html">Named_Node_List_ptr</a> namedlist_ptr)</td></tr>
<tr class="memdesc:ae62ff7921be30fed8109b0b3a9ceab0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects all Nodes that appear in a specific Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> Lilst and lists them by effective target date.  <a href="namespacefz.html#ae62ff7921be30fed8109b0b3a9ceab0d">More...</a><br /></td></tr>
<tr class="separator:ae62ff7921be30fed8109b0b3a9ceab0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d448863f42dc4a4fe439a5b35a1747f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a1d448863f42dc4a4fe439a5b35a1747f">total_minutes_incomplete_repeating</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, time_t from_t, time_t before_t, bool mapexact=true)</td></tr>
<tr class="memdesc:a1d448863f42dc4a4fe439a5b35a1747f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total required time for all incomplete repeating Nodes and their instances within a time interval.  <a href="namespacefz.html#a1d448863f42dc4a4fe439a5b35a1747f">More...</a><br /></td></tr>
<tr class="separator:a1d448863f42dc4a4fe439a5b35a1747f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503e1da7cf55e0087a7a09f7b6befc01"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a503e1da7cf55e0087a7a09f7b6befc01">total_minutes_incomplete_nonrepeating</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, time_t from_t, time_t before_t=<a class="el" href="namespacefz.html#aef05dd6bfa4d4a09d3eace4949b6fab0ad567131680cdfe5720218682688975a4">RTt_maxtime</a>)</td></tr>
<tr class="memdesc:a503e1da7cf55e0087a7a09f7b6befc01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total required time for all incomplete non-repeating Nodes within a time interval.  <a href="namespacefz.html#a503e1da7cf55e0087a7a09f7b6befc01">More...</a><br /></td></tr>
<tr class="separator:a503e1da7cf55e0087a7a09f7b6befc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a717325b4590dc3385f550c66bff75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfz_1_1Graph__modifications.html">Graph_modifications</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a05a717325b4590dc3385f550c66bff75">allocate_Graph_modifications_in_shared_memory</a> (std::string segname, unsigned long segsize)</td></tr>
<tr class="memdesc:a05a717325b4590dc3385f550c66bff75"><td class="mdescLeft">&#160;</td><td class="mdescRight">A client program uses this function to allocate new shared memory and to construct an empty <code><a class="el" href="classfz_1_1Graph__modifications.html" title="This data structure is the most efficient method to request a stack of Graph modifications.">Graph_modifications</a></code> object there.  <a href="namespacefz.html#a05a717325b4590dc3385f550c66bff75">More...</a><br /></td></tr>
<tr class="separator:a05a717325b4590dc3385f550c66bff75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39456418d635eb17a761d96fbf62ceb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfz_1_1Graph__modifications.html">Graph_modifications</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a39456418d635eb17a761d96fbf62ceb1">find_Graph_modifications_in_shared_memory</a> (std::string segment_name)</td></tr>
<tr class="memdesc:a39456418d635eb17a761d96fbf62ceb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classfz_1_1Graph.html">Graph</a> server program uses this function to find shared memory that contains a <code>Graph_modification</code> object.  <a href="namespacefz.html#a39456418d635eb17a761d96fbf62ceb1">More...</a><br /></td></tr>
<tr class="separator:a39456418d635eb17a761d96fbf62ceb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c227ce971d6a86dd072a4d594c3654"><td class="memItemLeft" align="right" valign="top"><a id="a17c227ce971d6a86dd072a4d594c3654"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a17c227ce971d6a86dd072a4d594c3654">unique_name_Graphmod</a> ()</td></tr>
<tr class="memdesc:a17c227ce971d6a86dd072a4d594c3654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a unique name for the shared memory segment for <a class="el" href="classfz_1_1Graph.html">Graph</a> modification requests. <br /></td></tr>
<tr class="separator:a17c227ce971d6a86dd072a4d594c3654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0354223c69d269c5ade2b5c6f8abd3"><td class="memItemLeft" align="right" valign="top"><a id="a9d0354223c69d269c5ade2b5c6f8abd3"></a>
<a class="el" href="structfz_1_1Graphmod__error.html">Graphmod_error</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a9d0354223c69d269c5ade2b5c6f8abd3">prepare_error_response</a> (std::string segname, <a class="el" href="namespacefz.html#a95a7b508456ccb1691f487ed136d52d4">exit_status_code</a> ecode, std::string errmsg)</td></tr>
<tr class="memdesc:a9d0354223c69d269c5ade2b5c6f8abd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">See for example how this is used in fzserverpq. <br /></td></tr>
<tr class="separator:a9d0354223c69d269c5ade2b5c6f8abd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584209f170b687a53d015e4fe2edabe8"><td class="memItemLeft" align="right" valign="top"><a id="a584209f170b687a53d015e4fe2edabe8"></a>
<a class="el" href="structfz_1_1Graphmod__error.html">Graphmod_error</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a584209f170b687a53d015e4fe2edabe8">find_error_response_in_shared_memory</a> (std::string segment_name)</td></tr>
<tr class="memdesc:a584209f170b687a53d015e4fe2edabe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">See for example how this is used in fzgraph. <br /></td></tr>
<tr class="separator:a584209f170b687a53d015e4fe2edabe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9068c6a67fbc516d0acf56c0e1fc60"><td class="memItemLeft" align="right" valign="top"><a id="afc9068c6a67fbc516d0acf56c0e1fc60"></a>
<a class="el" href="structfz_1_1Graphmod__results.html">Graphmod_results</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#afc9068c6a67fbc516d0acf56c0e1fc60">initialized_results_response</a> (std::string segname)</td></tr>
<tr class="memdesc:afc9068c6a67fbc516d0acf56c0e1fc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">See for example how this is used in fzserverpq. <br /></td></tr>
<tr class="separator:afc9068c6a67fbc516d0acf56c0e1fc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5438aab22dc4cf526c5ddd6be584d54"><td class="memItemLeft" align="right" valign="top"><a id="af5438aab22dc4cf526c5ddd6be584d54"></a>
<a class="el" href="structfz_1_1Graphmod__results.html">Graphmod_results</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#af5438aab22dc4cf526c5ddd6be584d54">find_results_response_in_shared_memory</a> (std::string segment_name)</td></tr>
<tr class="memdesc:af5438aab22dc4cf526c5ddd6be584d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">See for example how this is used in fzgraph. <br /></td></tr>
<tr class="separator:af5438aab22dc4cf526c5ddd6be584d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e02adb2dc643534902a369f700343ec"><td class="memItemLeft" align="right" valign="top"><a id="a7e02adb2dc643534902a369f700343ec"></a>
<a class="el" href="classfz_1_1Node.html">Node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a7e02adb2dc643534902a369f700343ec">Graph_modify_add_node</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, const std::string &amp;graph_segname, const <a class="el" href="structfz_1_1Graphmod__data.html">Graphmod_data</a> &amp;gmoddata)</td></tr>
<tr class="memdesc:a7e02adb2dc643534902a369f700343ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> in the <a class="el" href="classfz_1_1Graph.html">Graph</a>'s shared segment and add it to the <a class="el" href="classfz_1_1Graph.html">Graph</a>. <br /></td></tr>
<tr class="separator:a7e02adb2dc643534902a369f700343ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827b8c92cd9a30aeb67974458b5cc0b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfz_1_1Edge.html">Edge_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a827b8c92cd9a30aeb67974458b5cc0b6">Graph_modify_add_edge</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, const std::string &amp;graph_segname, const <a class="el" href="structfz_1_1Graphmod__data.html">Graphmod_data</a> &amp;gmoddata)</td></tr>
<tr class="memdesc:a827b8c92cd9a30aeb67974458b5cc0b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classfz_1_1Edge.html">Edge</a> in the <a class="el" href="classfz_1_1Graph.html">Graph</a>'s shared segment and add it to the <a class="el" href="classfz_1_1Graph.html">Graph</a>.  <a href="namespacefz.html#a827b8c92cd9a30aeb67974458b5cc0b6">More...</a><br /></td></tr>
<tr class="separator:a827b8c92cd9a30aeb67974458b5cc0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb97c31cf206e8ce1769904661f433f7"><td class="memItemLeft" align="right" valign="top"><a id="adb97c31cf206e8ce1769904661f433f7"></a>
<a class="el" href="classfz_1_1Node.html">Node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#adb97c31cf206e8ce1769904661f433f7">Graph_modify_edit_node</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, const std::string &amp;graph_segname, const <a class="el" href="structfz_1_1Graphmod__data.html">Graphmod_data</a> &amp;gmoddata)</td></tr>
<tr class="memdesc:adb97c31cf206e8ce1769904661f433f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> in the <a class="el" href="classfz_1_1Graph.html">Graph</a>. <br /></td></tr>
<tr class="separator:adb97c31cf206e8ce1769904661f433f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa991d01fb30358dcb80d0fd4407786e"><td class="memItemLeft" align="right" valign="top"><a id="afa991d01fb30358dcb80d0fd4407786e"></a>
<a class="el" href="classfz_1_1Edge.html">Edge_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#afa991d01fb30358dcb80d0fd4407786e">Graph_modify_edit_edge</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, const std::string &amp;graph_segname, const <a class="el" href="structfz_1_1Graphmod__data.html">Graphmod_data</a> &amp;gmoddata)</td></tr>
<tr class="memdesc:afa991d01fb30358dcb80d0fd4407786e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit and <a class="el" href="classfz_1_1Edge.html">Edge</a> in the <a class="el" href="classfz_1_1Graph.html">Graph</a>. <br /></td></tr>
<tr class="separator:afa991d01fb30358dcb80d0fd4407786e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369a33ebf770a5ad54a404a07ccae4db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a369a33ebf770a5ad54a404a07ccae4db">Update_repeating_Nodes</a> (const <a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a> &amp;sortednodes, time_t t_pass)</td></tr>
<tr class="memdesc:a369a33ebf770a5ad54a404a07ccae4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update repeating Nodes past a specific time.  <a href="namespacefz.html#a369a33ebf770a5ad54a404a07ccae4db">More...</a><br /></td></tr>
<tr class="separator:a369a33ebf770a5ad54a404a07ccae4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7515b6fd09c1d4b76ecadeb249dafc43"><td class="memItemLeft" align="right" valign="top"><a id="a7515b6fd09c1d4b76ecadeb249dafc43"></a>
<a class="el" href="structfz_1_1Named__Node__List.html">Named_Node_List_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a7515b6fd09c1d4b76ecadeb249dafc43">Graph_modify_list_add</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, const std::string &amp;graph_segname, const <a class="el" href="structfz_1_1Graphmod__data.html">Graphmod_data</a> &amp;gmoddata)</td></tr>
<tr class="memdesc:a7515b6fd09c1d4b76ecadeb249dafc43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> to a Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List. <br /></td></tr>
<tr class="separator:a7515b6fd09c1d4b76ecadeb249dafc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a1e1ccd267eb3202e40f3606755047"><td class="memItemLeft" align="right" valign="top"><a id="a79a1e1ccd267eb3202e40f3606755047"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a79a1e1ccd267eb3202e40f3606755047">Graph_modify_list_remove</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, const std::string &amp;graph_segname, const <a class="el" href="structfz_1_1Graphmod__data.html">Graphmod_data</a> &amp;gmoddata)</td></tr>
<tr class="memdesc:a79a1e1ccd267eb3202e40f3606755047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> from a Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List. <br /></td></tr>
<tr class="separator:a79a1e1ccd267eb3202e40f3606755047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71737aa04c479e0932f7e98e43657660"><td class="memItemLeft" align="right" valign="top"><a id="a71737aa04c479e0932f7e98e43657660"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a71737aa04c479e0932f7e98e43657660">Graph_modify_list_delete</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, const std::string &amp;graph_segname, const <a class="el" href="structfz_1_1Graphmod__data.html">Graphmod_data</a> &amp;gmoddata)</td></tr>
<tr class="memdesc:a71737aa04c479e0932f7e98e43657660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleta a Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List. <br /></td></tr>
<tr class="separator:a71737aa04c479e0932f7e98e43657660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6152ad04e72b88326337886115eedae"><td class="memItemLeft" align="right" valign="top"><a id="ae6152ad04e72b88326337886115eedae"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae6152ad04e72b88326337886115eedae">Graph_modify_batch_node_targetdates</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, const std::string &amp;graph_segname, const <a class="el" href="structfz_1_1Graphmod__data.html">Graphmod_data</a> &amp;gmoddata)</td></tr>
<tr class="memdesc:ae6152ad04e72b88326337886115eedae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the targetdates of a batch of Nodes. <br /></td></tr>
<tr class="separator:ae6152ad04e72b88326337886115eedae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5539a3a36958457da6b2a29693e8dd6a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a5539a3a36958457da6b2a29693e8dd6a">Graph_modify_batch_node_tpassrepeating</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, const std::string &amp;graph_segname, const <a class="el" href="structfz_1_1Graphmod__data.html">Graphmod_data</a> &amp;gmoddata)</td></tr>
<tr class="memdesc:a5539a3a36958457da6b2a29693e8dd6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the targetdates of a batch of repeating Nodes past t_pass time.  <a href="namespacefz.html#a5539a3a36958457da6b2a29693e8dd6a">More...</a><br /></td></tr>
<tr class="separator:a5539a3a36958457da6b2a29693e8dd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adda9ab95cfd243eed46edac8f84a96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a3adda9ab95cfd243eed46edac8f84a96">Node_advance_repeating</a> (<a class="el" href="classfz_1_1Node.html">Node</a> &amp;node, int N_advance, <a class="el" href="classfz_1_1Edit__flags.html">Edit_flags</a> &amp;editflags, time_t t_ref=<a class="el" href="namespacefz.html#aef05dd6bfa4d4a09d3eace4949b6fab0a328419ab650b1af199fdb58a44105aaa">RTt_unspecified</a>)</td></tr>
<tr class="memdesc:a3adda9ab95cfd243eed46edac8f84a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the targetdate of a repeating <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> by carrying out one or more iterations of advances in accordance with its <code>tdpattern</code> periodicity.  <a href="namespacefz.html#a3adda9ab95cfd243eed46edac8f84a96">More...</a><br /></td></tr>
<tr class="separator:a3adda9ab95cfd243eed46edac8f84a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288da0b8294bcae4c1259c43e1c55156"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfz_1_1Edit__flags.html">Edit_flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a288da0b8294bcae4c1259c43e1c55156">Node_apply_minutes</a> (<a class="el" href="classfz_1_1Node.html">Node</a> &amp;node, unsigned int add_minutes, time_t T_ref=<a class="el" href="namespacefz.html#aef05dd6bfa4d4a09d3eace4949b6fab0a328419ab650b1af199fdb58a44105aaa">RTt_unspecified</a>)</td></tr>
<tr class="memdesc:a288da0b8294bcae4c1259c43e1c55156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>'s completion ratio (and potentially updates required if completion exceeds 1.0) in response to having logged a number of minutes dedicated to the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>.  <a href="namespacefz.html#a288da0b8294bcae4c1259c43e1c55156">More...</a><br /></td></tr>
<tr class="separator:a288da0b8294bcae4c1259c43e1c55156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc98b08458fd96c977eb59ee75aa1171"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#abc98b08458fd96c977eb59ee75aa1171">Node_skip_num</a> (<a class="el" href="classfz_1_1Node.html">Node</a> &amp;node, unsigned int num_skip, <a class="el" href="classfz_1_1Edit__flags.html">Edit_flags</a> &amp;editflags)</td></tr>
<tr class="memdesc:abc98b08458fd96c977eb59ee75aa1171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip N instances of a repeating <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>.  <a href="namespacefz.html#abc98b08458fd96c977eb59ee75aa1171">More...</a><br /></td></tr>
<tr class="separator:abc98b08458fd96c977eb59ee75aa1171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2278aa9e3c21818c6f7d9aff6d9a10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a6f2278aa9e3c21818c6f7d9aff6d9a10">Node_skip_tpass</a> (<a class="el" href="classfz_1_1Node.html">Node</a> &amp;node, time_t t_pass, <a class="el" href="classfz_1_1Edit__flags.html">Edit_flags</a> &amp;editflags)</td></tr>
<tr class="memdesc:a6f2278aa9e3c21818c6f7d9aff6d9a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip instances of a repeating <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> past a specified time.  <a href="namespacefz.html#a6f2278aa9e3c21818c6f7d9aff6d9a10">More...</a><br /></td></tr>
<tr class="separator:a6f2278aa9e3c21818c6f7d9aff6d9a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefbed699792377f1fb0c4ffc77f1d46"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#acefbed699792377f1fb0c4ffc77f1d46">copy_Incomplete_to_List</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, const std::string to_name, size_t from_max=0, size_t to_max=0, int16_t _features=0, int32_t _maxsize=0)</td></tr>
<tr class="memdesc:acefbed699792377f1fb0c4ffc77f1d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a number of <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> IDs from a list of incomplete Nodes sorted by effective target date to a Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List.  <a href="namespacefz.html#acefbed699792377f1fb0c4ffc77f1d46">More...</a><br /></td></tr>
<tr class="separator:acefbed699792377f1fb0c4ffc77f1d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf722de88e20cea469b8d0d79be4acc5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#abf722de88e20cea469b8d0d79be4acc5">update_shortlist_List</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:abf722de88e20cea469b8d0d79be4acc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the 'shortlist" Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List.  <a href="namespacefz.html#abf722de88e20cea469b8d0d79be4acc5">More...</a><br /></td></tr>
<tr class="separator:abf722de88e20cea469b8d0d79be4acc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46dcb3b9640365e0a78e28feed3d09a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab46dcb3b9640365e0a78e28feed3d09a">batch_to_NNL</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, const <a class="el" href="structfz_1_1Batchmod__targetdates.html">Batchmod_targetdates</a> &amp;batchnodes, std::string list_name)</td></tr>
<tr class="memdesc:ab46dcb3b9640365e0a78e28feed3d09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Nodes from a batch to a Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List.  <a href="namespacefz.html#ab46dcb3b9640365e0a78e28feed3d09a">More...</a><br /></td></tr>
<tr class="separator:ab46dcb3b9640365e0a78e28feed3d09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585ab197c3d6be71ac67d84d3fcc78f4"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a585ab197c3d6be71ac67d84d3fcc78f4">sorted_to_NNL</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, const <a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a> &amp;sortednodes, std::string list_name)</td></tr>
<tr class="memdesc:a585ab197c3d6be71ac67d84d3fcc78f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Nodes from a sorted list to a Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List.  <a href="namespacefz.html#a585ab197c3d6be71ac67d84d3fcc78f4">More...</a><br /></td></tr>
<tr class="separator:a585ab197c3d6be71ac67d84d3fcc78f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe69e72e6cc57d40e3738f2bb2d7b1bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#abe69e72e6cc57d40e3738f2bb2d7b1bc">create_Enum_Types_pq</a> (PGconn *conn, std::string schemaname)</td></tr>
<tr class="memdesc:abe69e72e6cc57d40e3738f2bb2d7b1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create enumerated types in database for <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> and <a class="el" href="classfz_1_1Edge.html">Edge</a> data.  <a href="namespacefz.html#abe69e72e6cc57d40e3738f2bb2d7b1bc">More...</a><br /></td></tr>
<tr class="separator:abe69e72e6cc57d40e3738f2bb2d7b1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2359bd1e82e68f38bd9d900588887fde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a2359bd1e82e68f38bd9d900588887fde">create_Topics_table_pq</a> (PGconn *conn, std::string schemaname)</td></tr>
<tr class="memdesc:a2359bd1e82e68f38bd9d900588887fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new database table for Topics.  <a href="namespacefz.html#a2359bd1e82e68f38bd9d900588887fde">More...</a><br /></td></tr>
<tr class="separator:a2359bd1e82e68f38bd9d900588887fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75375e8fb94d22f2facb4085afe93de9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a75375e8fb94d22f2facb4085afe93de9">create_Nodes_table_pq</a> (PGconn *conn, std::string schemaname)</td></tr>
<tr class="memdesc:a75375e8fb94d22f2facb4085afe93de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new database table for Nodes.  <a href="namespacefz.html#a75375e8fb94d22f2facb4085afe93de9">More...</a><br /></td></tr>
<tr class="separator:a75375e8fb94d22f2facb4085afe93de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2da8c677f43a85e7f86d9074e468962"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ad2da8c677f43a85e7f86d9074e468962">create_Edges_table_pq</a> (PGconn *conn, std::string schemaname)</td></tr>
<tr class="memdesc:ad2da8c677f43a85e7f86d9074e468962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new database table for Edges.  <a href="namespacefz.html#ad2da8c677f43a85e7f86d9074e468962">More...</a><br /></td></tr>
<tr class="separator:ad2da8c677f43a85e7f86d9074e468962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d3d52c28b498e4b986abd91d3797ee"><td class="memItemLeft" align="right" valign="top"><a id="a59d3d52c28b498e4b986abd91d3797ee"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>add_Topic_pq</b> (PGconn *conn, std::string schemaname, const <a class="el" href="classfz_1_1Topic.html">Topic</a> *topic)</td></tr>
<tr class="separator:a59d3d52c28b498e4b986abd91d3797ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5d35ee88b8f0e2ab786e64ded407c5"><td class="memItemLeft" align="right" valign="top"><a id="a0d5d35ee88b8f0e2ab786e64ded407c5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>add_Node_pq</b> (PGconn *conn, std::string schemaname, const <a class="el" href="classfz_1_1Node.html">Node</a> *node)</td></tr>
<tr class="separator:a0d5d35ee88b8f0e2ab786e64ded407c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad481d21955c0be457141a73c619a3fbf"><td class="memItemLeft" align="right" valign="top"><a id="ad481d21955c0be457141a73c619a3fbf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>add_Edge_pq</b> (PGconn *conn, std::string schemaname, const <a class="el" href="classfz_1_1Edge.html">Edge</a> *edge)</td></tr>
<tr class="separator:ad481d21955c0be457141a73c619a3fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef06a1d65a953bbff2a991a3c7b4b098"><td class="memItemLeft" align="right" valign="top"><a id="aef06a1d65a953bbff2a991a3c7b4b098"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>remove_Edge_pq</b> (PGconn *conn, std::string schemaname, const <a class="el" href="structfz_1_1Edge__ID__key.html">Edge_ID_key</a> &amp;id)</td></tr>
<tr class="separator:aef06a1d65a953bbff2a991a3c7b4b098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb865200e35c530ff09a2a5c142c55a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a1cb865200e35c530ff09a2a5c142c55a">store_Graph_pq</a> (const <a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, std::string dbname, std::string schemaname, void(*progress_func)(unsigned long, unsigned long))</td></tr>
<tr class="memdesc:a1cb865200e35c530ff09a2a5c142c55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store all the Nodes and Edges of the <a class="el" href="classfz_1_1Graph.html">Graph</a> in the PostgreSQL database.  <a href="namespacefz.html#a1cb865200e35c530ff09a2a5c142c55a">More...</a><br /></td></tr>
<tr class="separator:a1cb865200e35c530ff09a2a5c142c55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615c9833189de86268653cf1fc95f092"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a615c9833189de86268653cf1fc95f092">load_Graph_pq</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, std::string dbname, std::string schemaname)</td></tr>
<tr class="memdesc:a615c9833189de86268653cf1fc95f092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all the Nodes, Edges and Topics of the <a class="el" href="classfz_1_1Graph.html">Graph</a> from the PostgreSQL database.  <a href="namespacefz.html#a615c9833189de86268653cf1fc95f092">More...</a><br /></td></tr>
<tr class="separator:a615c9833189de86268653cf1fc95f092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d4a8b4bdf710ab001ba476a237fa6f"><td class="memItemLeft" align="right" valign="top"><a id="af8d4a8b4bdf710ab001ba476a237fa6f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>update_Node_pq</b> (PGconn *conn, const std::string &amp;schemaname, const <a class="el" href="classfz_1_1Node.html">Node</a> &amp;node, const <a class="el" href="classfz_1_1Edit__flags.html">Edit_flags</a> &amp;_editflags)</td></tr>
<tr class="separator:af8d4a8b4bdf710ab001ba476a237fa6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c73d83a9556d9e2ff47d6aa53b24fd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a4c73d83a9556d9e2ff47d6aa53b24fd7">Update_Node_pq</a> (std::string dbname, std::string schemaname, const <a class="el" href="classfz_1_1Node.html">Node</a> &amp;node, const <a class="el" href="classfz_1_1Edit__flags.html">Edit_flags</a> &amp;_editflags)</td></tr>
<tr class="memdesc:a4c73d83a9556d9e2ff47d6aa53b24fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct interface to the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> update function that sets up the database connection first.  <a href="namespacefz.html#a4c73d83a9556d9e2ff47d6aa53b24fd7">More...</a><br /></td></tr>
<tr class="separator:a4c73d83a9556d9e2ff47d6aa53b24fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396de0aaa644d42a9cbcaf85cf20fc17"><td class="memItemLeft" align="right" valign="top"><a id="a396de0aaa644d42a9cbcaf85cf20fc17"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>update_Edge_pq</b> (PGconn *conn, const std::string &amp;schemaname, const <a class="el" href="classfz_1_1Edge.html">Edge</a> &amp;edge, const <a class="el" href="classfz_1_1Edit__flags.html">Edit_flags</a> &amp;_editflags)</td></tr>
<tr class="separator:a396de0aaa644d42a9cbcaf85cf20fc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3c94ac9998586f13c62fd0796c502e"><td class="memItemLeft" align="right" valign="top"><a id="a8a3c94ac9998586f13c62fd0796c502e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a8a3c94ac9998586f13c62fd0796c502e">update_batch_node_targetdates_pq</a> (PGconn *conn, std::string schemaname, <a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, const std::string NNL_name)</td></tr>
<tr class="memdesc:a8a3c94ac9998586f13c62fd0796c502e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update targetdates of multiple Nodes. <br /></td></tr>
<tr class="separator:a8a3c94ac9998586f13c62fd0796c502e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66e4f4c16e1791e809906aa6cfdc940"><td class="memItemLeft" align="right" valign="top"><a id="ab66e4f4c16e1791e809906aa6cfdc940"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab66e4f4c16e1791e809906aa6cfdc940">update_batch_nodes_pq</a> (PGconn *conn, std::string schemaname, <a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, const std::string NNL_name)</td></tr>
<tr class="memdesc:ab66e4f4c16e1791e809906aa6cfdc940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a batch of Nodes in accordance with their individual <a class="el" href="classfz_1_1Edit__flags.html" title="A bitmask of flags for the data components of a Node.">Edit_flags</a>. <br /></td></tr>
<tr class="separator:ab66e4f4c16e1791e809906aa6cfdc940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865dea605004015c99e389e806f42dba"><td class="memItemLeft" align="right" valign="top"><a id="a865dea605004015c99e389e806f42dba"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a865dea605004015c99e389e806f42dba">Update_batch_nodes_pq</a> (std::string dbname, std::string schemaname, <a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, const std::string NNL_name)</td></tr>
<tr class="memdesc:a865dea605004015c99e389e806f42dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct interface to the batch of Nodes update function that sets up the database connection first. <br /></td></tr>
<tr class="separator:a865dea605004015c99e389e806f42dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24f78e052197d9844de69ba284cfade"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ad24f78e052197d9844de69ba284cfade">load_Node_parameter_interval</a> (std::string dbname, std::string schemaname, pq_Nfields param, unsigned long from_row, unsigned long num_rows)</td></tr>
<tr class="memdesc:ad24f78e052197d9844de69ba284cfade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load specific <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> parameter column interval from PostgreSQL database.  <a href="namespacefz.html#ad24f78e052197d9844de69ba284cfade">More...</a><br /></td></tr>
<tr class="separator:ad24f78e052197d9844de69ba284cfade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef824584d56abd3b06028a3925a9541c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aef824584d56abd3b06028a3925a9541c">load_Edge_parameter_interval</a> (std::string dbname, std::string schemaname, pq_Efields param, unsigned long from_row, unsigned long num_rows)</td></tr>
<tr class="memdesc:aef824584d56abd3b06028a3925a9541c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load specific <a class="el" href="classfz_1_1Edge.html">Edge</a> parameter column interval from PostgreSQL database.  <a href="namespacefz.html#aef824584d56abd3b06028a3925a9541c">More...</a><br /></td></tr>
<tr class="separator:aef824584d56abd3b06028a3925a9541c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85e6fa77b067a4325f52513f547047c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ac85e6fa77b067a4325f52513f547047c">handle_Graph_modifications_pq</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, std::string dbname, std::string schemaname, <a class="el" href="structfz_1_1Graphmod__results.html">Graphmod_results</a> &amp;modifications)</td></tr>
<tr class="memdesc:ac85e6fa77b067a4325f52513f547047c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the defined set of possible modifications of <a class="el" href="classfz_1_1Graph.html">Graph</a> data and carry out those modifications in the database.  <a href="namespacefz.html#ac85e6fa77b067a4325f52513f547047c">More...</a><br /></td></tr>
<tr class="separator:ac85e6fa77b067a4325f52513f547047c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b2010b68d787bc1f202bb9c0402822"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a28b2010b68d787bc1f202bb9c0402822">handle_Graph_modifications_unshared_pq</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, std::string dbname, std::string schemaname, <a class="el" href="structfz_1_1Graphmod__unshared__results.html">Graphmod_unshared_results</a> &amp;modifications)</td></tr>
<tr class="memdesc:a28b2010b68d787bc1f202bb9c0402822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the defined set of possible modifications of <a class="el" href="classfz_1_1Graph.html">Graph</a> data and carry out those modifications in the database.  <a href="namespacefz.html#a28b2010b68d787bc1f202bb9c0402822">More...</a><br /></td></tr>
<tr class="separator:a28b2010b68d787bc1f202bb9c0402822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae4b124721a2a2a59d23b208ddc5e61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a5ae4b124721a2a2a59d23b208ddc5e61">Init_Named_Node_Lists_pq</a> (std::string dbname, std::string schemaname)</td></tr>
<tr class="memdesc:a5ae4b124721a2a2a59d23b208ddc5e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postgres storage of Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> Lists:  <a href="namespacefz.html#a5ae4b124721a2a2a59d23b208ddc5e61">More...</a><br /></td></tr>
<tr class="separator:a5ae4b124721a2a2a59d23b208ddc5e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1083f529f49b38c70a3a77eec5cf08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a9d1083f529f49b38c70a3a77eec5cf08">Delete_Named_Node_List_pq</a> (std::string dbname, std::string schemaname, std::string listname)</td></tr>
<tr class="memdesc:a9d1083f529f49b38c70a3a77eec5cf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List from the NamedNodeLists table.  <a href="namespacefz.html#a9d1083f529f49b38c70a3a77eec5cf08">More...</a><br /></td></tr>
<tr class="separator:a9d1083f529f49b38c70a3a77eec5cf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e32f92d40e442ab21d111c026dc173"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a74e32f92d40e442ab21d111c026dc173">Update_Named_Node_List_pq</a> (std::string dbname, std::string schemaname, std::string listname, <a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a74e32f92d40e442ab21d111c026dc173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List in the NamedNodeLists table.  <a href="namespacefz.html#a74e32f92d40e442ab21d111c026dc173">More...</a><br /></td></tr>
<tr class="separator:a74e32f92d40e442ab21d111c026dc173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1472e23f0f82663c96212be38c02ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a3b1472e23f0f82663c96212be38c02ba">load_Named_Node_Lists_pq</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, std::string dbname, std::string schemaname)</td></tr>
<tr class="memdesc:a3b1472e23f0f82663c96212be38c02ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> Lists into memory-resident cache.  <a href="namespacefz.html#a3b1472e23f0f82663c96212be38c02ba">More...</a><br /></td></tr>
<tr class="separator:a3b1472e23f0f82663c96212be38c02ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d17a3d2ee349bdd7c839420cfb8228a"><td class="memItemLeft" align="right" valign="top"><a id="a7d17a3d2ee349bdd7c839420cfb8228a"></a>
time_t&#160;</td><td class="memItemRight" valign="bottom"><b>interpret_config_targetdate</b> (const std::string &amp;parvalue)</td></tr>
<tr class="separator:a7d17a3d2ee349bdd7c839420cfb8228a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b194cee6c61a5ad517ae1c76e2f8d09"><td class="memItemLeft" align="right" valign="top"><a id="a8b194cee6c61a5ad517ae1c76e2f8d09"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parse_config_topics</b> (const std::string &amp;parvalue)</td></tr>
<tr class="separator:a8b194cee6c61a5ad517ae1c76e2f8d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2cfa70d3980ed113b0882c1154c651"><td class="memItemLeft" align="right" valign="top"><a id="a6d2cfa70d3980ed113b0882c1154c651"></a>
<a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">td_property</a>&#160;</td><td class="memItemRight" valign="bottom"><b>interpret_config_tdproperty</b> (const std::string &amp;parvalue)</td></tr>
<tr class="separator:a6d2cfa70d3980ed113b0882c1154c651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a69e6618e83d8098a0bf154010b4470"><td class="memItemLeft" align="right" valign="top"><a id="a6a69e6618e83d8098a0bf154010b4470"></a>
td_pattern&#160;</td><td class="memItemRight" valign="bottom"><b>interpret_config_tdpattern</b> (const std::string &amp;parvalue)</td></tr>
<tr class="separator:a6a69e6618e83d8098a0bf154010b4470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05501ad2719a3430eca700c5dd72b8e1"><td class="memItemLeft" align="right" valign="top">Tag_Label_Real_Value_Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a05501ad2719a3430eca700c5dd72b8e1">Topic_tags_of_Node</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, <a class="el" href="classfz_1_1Node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:a05501ad2719a3430eca700c5dd72b8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of label string and relevance value pairs for a specified <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> within a specified <a class="el" href="classfz_1_1Graph.html">Graph</a>.  <a href="namespacefz.html#a05501ad2719a3430eca700c5dd72b8e1">More...</a><br /></td></tr>
<tr class="separator:a05501ad2719a3430eca700c5dd72b8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fd22f72beee5ca8516df2fdef88123"><td class="memItemLeft" align="right" valign="top">Node_Graph_ptr_pair&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a56fd22f72beee5ca8516df2fdef88123">find_Node_by_idstr</a> (const std::string &amp;node_idstr, <a class="el" href="classfz_1_1Graph.html">Graph</a> *graph_ptr)</td></tr>
<tr class="memdesc:a56fd22f72beee5ca8516df2fdef88123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> in a <a class="el" href="classfz_1_1Graph.html">Graph</a> by its ID key from a string.  <a href="namespacefz.html#a56fd22f72beee5ca8516df2fdef88123">More...</a><br /></td></tr>
<tr class="separator:a56fd22f72beee5ca8516df2fdef88123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd926038748af1ffa7f75a0f6643c38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aebd926038748af1ffa7f75a0f6643c38">create_Guide_table</a> (const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq, const std::string guidetable, const std::string guidetablelayout)</td></tr>
<tr class="memdesc:aebd926038748af1ffa7f75a0f6643c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the table for Guide snippets if it does not already exist.  <a href="namespacefz.html#aebd926038748af1ffa7f75a0f6643c38">More...</a><br /></td></tr>
<tr class="separator:aebd926038748af1ffa7f75a0f6643c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8eebdb96e1f6ab62ce592c84ea3e669"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#af8eebdb96e1f6ab62ce592c84ea3e669">store_Guide_snippet_pq</a> (const <a class="el" href="structfz_1_1Guide__snippet.html">Guide_snippet</a> &amp;snippet, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa)</td></tr>
<tr class="memdesc:af8eebdb96e1f6ab62ce592c84ea3e669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a new Guide snippet in the PostgreSQL database.  <a href="namespacefz.html#af8eebdb96e1f6ab62ce592c84ea3e669">More...</a><br /></td></tr>
<tr class="separator:af8eebdb96e1f6ab62ce592c84ea3e669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b38593fec552b574f1ca8e56d3b254"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a84b38593fec552b574f1ca8e56d3b254">store_Guide_multi_snippet_pq</a> (const std::vector&lt; Guide_snippet_ptr &gt; &amp;snippets, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa)</td></tr>
<tr class="memdesc:a84b38593fec552b574f1ca8e56d3b254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store multiple Guide snippets in the PostgreSQL database.  <a href="namespacefz.html#a84b38593fec552b574f1ca8e56d3b254">More...</a><br /></td></tr>
<tr class="separator:a84b38593fec552b574f1ca8e56d3b254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f30f53fd171c9a6c7f03cf96c983ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae2f30f53fd171c9a6c7f03cf96c983ba">read_Guide_snippet_pq</a> (<a class="el" href="structfz_1_1Guide__snippet.html">Guide_snippet</a> &amp;snippet, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa)</td></tr>
<tr class="memdesc:ae2f30f53fd171c9a6c7f03cf96c983ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single snippet from a Guide table in the database.  <a href="namespacefz.html#ae2f30f53fd171c9a6c7f03cf96c983ba">More...</a><br /></td></tr>
<tr class="separator:ae2f30f53fd171c9a6c7f03cf96c983ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0faf48a147699ffdf8906e6f230f1aae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a0faf48a147699ffdf8906e6f230f1aae">read_Guide_IDs_pq</a> (<a class="el" href="structfz_1_1Guide__snippet.html">Guide_snippet</a> &amp;snippet, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa, std::vector&lt; std::string &gt; &amp;ids)</td></tr>
<tr class="memdesc:a0faf48a147699ffdf8906e6f230f1aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read all IDs from Guide table in the database.  <a href="namespacefz.html#a0faf48a147699ffdf8906e6f230f1aae">More...</a><br /></td></tr>
<tr class="separator:a0faf48a147699ffdf8906e6f230f1aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8d75e81f8c4ebd34f0e25be2e4144d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a0a8d75e81f8c4ebd34f0e25be2e4144d">read_Guide_multi_snippets_pq</a> (<a class="el" href="structfz_1_1Guide__snippet.html">Guide_snippet</a> &amp;snippet, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa, std::vector&lt; std::string &gt; &amp;ids, std::vector&lt; std::string &gt; &amp;snippets)</td></tr>
<tr class="memdesc:a0a8d75e81f8c4ebd34f0e25be2e4144d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read multiple snippets from Guide table in the database.  <a href="namespacefz.html#a0a8d75e81f8c4ebd34f0e25be2e4144d">More...</a><br /></td></tr>
<tr class="separator:a0a8d75e81f8c4ebd34f0e25be2e4144d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad724f1008a1a3be0113e7c8d29239988"><td class="memItemLeft" align="right" valign="top">text_interpretation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ad724f1008a1a3be0113e7c8d29239988">config_parse_text_interpretation</a> (std::string csflags)</td></tr>
<tr class="memdesc:ad724f1008a1a3be0113e7c8d29239988"><td class="mdescLeft">&#160;</td><td class="mdescRight">A useful function to convert a set of comma separated flag identifiers into a <code>text_interpretation</code> flags bitmap.  <a href="namespacefz.html#ad724f1008a1a3be0113e7c8d29239988">More...</a><br /></td></tr>
<tr class="separator:ad724f1008a1a3be0113e7c8d29239988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5b51cf9b3ad61ff50bdc19ff635d33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a6f5b51cf9b3ad61ff50bdc19ff635d33">lowercase_equal</a> (const std::string &amp;lowermatch, const std::string &amp;content, size_t start_at=0)</td></tr>
<tr class="memdesc:a6f5b51cf9b3ad61ff50bdc19ff635d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a lower case match string with part of a content string in any combination of lower and upper case characters.  <a href="namespacefz.html#a6f5b51cf9b3ad61ff50bdc19ff635d33">More...</a><br /></td></tr>
<tr class="separator:a6f5b51cf9b3ad61ff50bdc19ff635d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aae98945caac45aa7d78a74a5e90d8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a6aae98945caac45aa7d78a74a5e90d8d">lowercase_match_skipping_spaces</a> (const std::vector&lt; std::string &gt; &amp;match_vec, const std::string &amp;content, size_t start_at=0, size_t *url_start_ptr=nullptr)</td></tr>
<tr class="memdesc:a6aae98945caac45aa7d78a74a5e90d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a multi-part lower case match string with possible space or tab separated components with part of a content string in any combination of lower and upper case characters.  <a href="namespacefz.html#a6aae98945caac45aa7d78a74a5e90d8d">More...</a><br /></td></tr>
<tr class="separator:a6aae98945caac45aa7d78a74a5e90d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6bca104bb411113c4860d3cf396b5a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a6b6bca104bb411113c4860d3cf396b5a">remove_html</a> (const std::string &amp;htmlstr)</td></tr>
<tr class="memdesc:a6b6bca104bb411113c4860d3cf396b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all HTML tags to create raw text.  <a href="namespacefz.html#a6b6bca104bb411113c4860d3cf396b5a">More...</a><br /></td></tr>
<tr class="separator:a6b6bca104bb411113c4860d3cf396b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86cb09143d3253224bc32ee4ec1fec97"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a86cb09143d3253224bc32ee4ec1fec97">remove_html_tags</a> (const std::string &amp;htmlstr)</td></tr>
<tr class="memdesc:a86cb09143d3253224bc32ee4ec1fec97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all HTML tags (but not special characters) to produce text that can be safely excerpted into HTML tables, etc, but that can still show ampersands and such properly within an HTML context.  <a href="namespacefz.html#a86cb09143d3253224bc32ee4ec1fec97">More...</a><br /></td></tr>
<tr class="separator:a86cb09143d3253224bc32ee4ec1fec97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e85b9d67d3d04d7c5bc2ae623e416c4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a6e85b9d67d3d04d7c5bc2ae623e416c4">make_embeddable_html</a> (const std::string &amp;htmlstr, text_interpretation interpretation=text_interpretation::raw, const std::vector&lt; std::string &gt; *special_urls=nullptr, const std::vector&lt; std::string &gt; *replacements=nullptr)</td></tr>
<tr class="memdesc:a6e85b9d67d3d04d7c5bc2ae623e416c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently and reliably filter snippets of HTML text such that they become optimally embeddable within other HTML.  <a href="namespacefz.html#a6e85b9d67d3d04d7c5bc2ae623e416c4">More...</a><br /></td></tr>
<tr class="separator:a6e85b9d67d3d04d7c5bc2ae623e416c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccd23a3b259b377888ca0d649ec972a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a0ccd23a3b259b377888ca0d649ec972a">uri_encode</a> (std::string s)</td></tr>
<tr class="memdesc:a0ccd23a3b259b377888ca0d649ec972a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string into a URI-safe string.  <a href="namespacefz.html#a0ccd23a3b259b377888ca0d649ec972a">More...</a><br /></td></tr>
<tr class="separator:a0ccd23a3b259b377888ca0d649ec972a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487b4b2d73b7195c20bac646e588483e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a487b4b2d73b7195c20bac646e588483e">make_button</a> (const std::string &amp;link, const std::string &amp;label, bool samepage)</td></tr>
<tr class="memdesc:a487b4b2d73b7195c20bac646e588483e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make HTML code for a link button.  <a href="namespacefz.html#a487b4b2d73b7195c20bac646e588483e">More...</a><br /></td></tr>
<tr class="separator:a487b4b2d73b7195c20bac646e588483e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ceb82b53b009d791ad638a4d8cb2ce1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a5ceb82b53b009d791ad638a4d8cb2ce1">copy_from_id_button</a> (const std::string &amp;id, const std::string &amp;label, const std::string &amp;button_class=&quot;&quot;)</td></tr>
<tr class="memdesc:a5ceb82b53b009d791ad638a4d8cb2ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates HTML for a button that will copy contents from the innerHTML of a DOM object with a specific id to the clipboard.  <a href="namespacefz.html#a5ceb82b53b009d791ad638a4d8cb2ce1">More...</a><br /></td></tr>
<tr class="separator:a5ceb82b53b009d791ad638a4d8cb2ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b83645cda140b818a9980c7e516d4a0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a1b83645cda140b818a9980c7e516d4a0">copy_from_input_button</a> (const std::string &amp;id, const std::string &amp;label, const std::string &amp;button_class=&quot;&quot;)</td></tr>
<tr class="memdesc:a1b83645cda140b818a9980c7e516d4a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="namespacefz.html#a5ceb82b53b009d791ad638a4d8cb2ce1" title="Generates HTML for a button that will copy contents from the innerHTML of a DOM object with a specifi...">copy_from_id_button()</a>, but copies the value of an input element.  <a href="namespacefz.html#a1b83645cda140b818a9980c7e516d4a0">More...</a><br /></td></tr>
<tr class="separator:a1b83645cda140b818a9980c7e516d4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af426ac4cce3a1975a5211a589ff3fa12"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#af426ac4cce3a1975a5211a589ff3fa12">copy_html_from_id_js</a> (const std::string &amp;id)</td></tr>
<tr class="memdesc:af426ac4cce3a1975a5211a589ff3fa12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates Javascript for a function top copy contents from the innerHTML of a DOM object with a specific id to the clipboard.  <a href="namespacefz.html#af426ac4cce3a1975a5211a589ff3fa12">More...</a><br /></td></tr>
<tr class="separator:af426ac4cce3a1975a5211a589ff3fa12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9a11b9dee3b2ceea3433706046c6a6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#abe9a11b9dee3b2ceea3433706046c6a6">copy_value_from_id_js</a> (const std::string &amp;id)</td></tr>
<tr class="memdesc:abe9a11b9dee3b2ceea3433706046c6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="namespacefz.html#af426ac4cce3a1975a5211a589ff3fa12" title="Generates Javascript for a function top copy contents from the innerHTML of a DOM object with a speci...">copy_html_from_id_js()</a>, but copies the value of an input element.  <a href="namespacefz.html#abe9a11b9dee3b2ceea3433706046c6a6">More...</a><br /></td></tr>
<tr class="separator:abe9a11b9dee3b2ceea3433706046c6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5007b00e853ca6197ecbda5704c1642e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a5007b00e853ca6197ecbda5704c1642e">is_json_comment</a> (const std::string &amp;keylabel)</td></tr>
<tr class="memdesc:a5007b00e853ca6197ecbda5704c1642e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify json key labels that are actually comments.  <a href="namespacefz.html#a5007b00e853ca6197ecbda5704c1642e">More...</a><br /></td></tr>
<tr class="separator:a5007b00e853ca6197ecbda5704c1642e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6128b734ed961d522923052e768e200b"><td class="memItemLeft" align="right" valign="top">jsonlite_label_value_pair&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a6128b734ed961d522923052e768e200b">json_param_value</a> (const std::string &amp;par_value_pair)</td></tr>
<tr class="memdesc:a6128b734ed961d522923052e768e200b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract parameter label and parameter value from a content line.  <a href="namespacefz.html#a6128b734ed961d522923052e768e200b">More...</a><br /></td></tr>
<tr class="separator:a6128b734ed961d522923052e768e200b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615f67507873ff02f050b57a562b028d"><td class="memItemLeft" align="right" valign="top">jsonlite_lines&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a615f67507873ff02f050b57a562b028d">json_get_param_value_lines</a> (std::string &amp;configcontentstr)</td></tr>
<tr class="memdesc:a615f67507873ff02f050b57a562b028d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the content of a JSON subset string into a vector of '"parameter" : "value"' statement strings.  <a href="namespacefz.html#a615f67507873ff02f050b57a562b028d">More...</a><br /></td></tr>
<tr class="separator:a615f67507873ff02f050b57a562b028d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436d3fb0b87afd17f5c45ff0e50145fe"><td class="memItemLeft" align="right" valign="top">jsonlite_label_value_pairs&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a436d3fb0b87afd17f5c45ff0e50145fe">json_get_label_value_pairs_from_string</a> (std::string &amp;jsoncontentstr)</td></tr>
<tr class="memdesc:a436d3fb0b87afd17f5c45ff0e50145fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string containing JSON subset content into a map of parameter label-value pairs.  <a href="namespacefz.html#a436d3fb0b87afd17f5c45ff0e50145fe">More...</a><br /></td></tr>
<tr class="separator:a436d3fb0b87afd17f5c45ff0e50145fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec59f006cec171ddbb6e0fc0c91b6312"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aec59f006cec171ddbb6e0fc0c91b6312">json_label_value_pairs_to_string</a> (const jsonlite_label_value_pairs &amp;labelvaluepairs)</td></tr>
<tr class="memdesc:aec59f006cec171ddbb6e0fc0c91b6312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert JSON subset label-value pairs into a JSON content string.  <a href="namespacefz.html#aec59f006cec171ddbb6e0fc0c91b6312">More...</a><br /></td></tr>
<tr class="separator:aec59f006cec171ddbb6e0fc0c91b6312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc55c5fb2440225ccc00380b9a91fcd"><td class="memItemLeft" align="right" valign="top"><a id="afcc55c5fb2440225ccc00380b9a91fcd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_populated_JSON_block</b> (<a class="el" href="structfz_1_1JSON__element.html">JSON_element</a> *element_ptr)</td></tr>
<tr class="separator:afcc55c5fb2440225ccc00380b9a91fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3fa62a73b340350dec9f23936460f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a9f3fa62a73b340350dec9f23936460f8">get_Log_data</a> (<a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa, std::string chunk_id_str, <a class="el" href="structfz_1_1entry__data.html">entry_data</a> &amp;edata)</td></tr>
<tr class="memdesc:a9f3fa62a73b340350dec9f23936460f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the <a class="el" href="classfz_1_1Log.html">Log</a> to find specific entry point.  <a href="namespacefz.html#a9f3fa62a73b340350dec9f23936460f8">More...</a><br /></td></tr>
<tr class="separator:a9f3fa62a73b340350dec9f23936460f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542231619261106a93cda6c951047a04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a542231619261106a93cda6c951047a04">get_newest_Log_data</a> (<a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa, <a class="el" href="structfz_1_1entry__data.html">entry_data</a> &amp;edata)</td></tr>
<tr class="memdesc:a542231619261106a93cda6c951047a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the <a class="el" href="classfz_1_1Log.html">Log</a> to find most recent entry points.  <a href="namespacefz.html#a542231619261106a93cda6c951047a04">More...</a><br /></td></tr>
<tr class="separator:a542231619261106a93cda6c951047a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125c22828646b624c8e4f4775f84dc5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a125c22828646b624c8e4f4775f84dc5d">create_Breakpoints_table_pq</a> (const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq)</td></tr>
<tr class="memdesc:a125c22828646b624c8e4f4775f84dc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new database table for Breakpoints.  <a href="namespacefz.html#a125c22828646b624c8e4f4775f84dc5d">More...</a><br /></td></tr>
<tr class="separator:a125c22828646b624c8e4f4775f84dc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a2d42be5384357b19e513b20b1c77b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a44a2d42be5384357b19e513b20b1c77b">create_Logchunks_table_pq</a> (const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq)</td></tr>
<tr class="memdesc:a44a2d42be5384357b19e513b20b1c77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new database table for <a class="el" href="classfz_1_1Log.html">Log</a> chunks.  <a href="namespacefz.html#a44a2d42be5384357b19e513b20b1c77b">More...</a><br /></td></tr>
<tr class="separator:a44a2d42be5384357b19e513b20b1c77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ef5ef0384e0d621bbff628679d3981"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aa8ef5ef0384e0d621bbff628679d3981">create_Logentries_table_pq</a> (const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq)</td></tr>
<tr class="memdesc:aa8ef5ef0384e0d621bbff628679d3981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new database table for <a class="el" href="classfz_1_1Log.html">Log</a> entries.  <a href="namespacefz.html#aa8ef5ef0384e0d621bbff628679d3981">More...</a><br /></td></tr>
<tr class="separator:aa8ef5ef0384e0d621bbff628679d3981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539303a2c7987ed777fbc57d9abda813"><td class="memItemLeft" align="right" valign="top"><a id="a539303a2c7987ed777fbc57d9abda813"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>add_Breakpoint_pq</b> (const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq, const <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> &amp;bptopid)</td></tr>
<tr class="separator:a539303a2c7987ed777fbc57d9abda813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e7a0e71b09cf5afc4e574c7a671e46"><td class="memItemLeft" align="right" valign="top"><a id="a10e7a0e71b09cf5afc4e574c7a671e46"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>add_Logchunk_pq</b> (const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq, const <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &amp;chunk)</td></tr>
<tr class="separator:a10e7a0e71b09cf5afc4e574c7a671e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df6964ef0bf050076248edb5be67f44"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a4df6964ef0bf050076248edb5be67f44">entry_minor_id_pq</a> (unsigned int minor_id)</td></tr>
<tr class="memdesc:a4df6964ef0bf050076248edb5be67f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts the <a class="el" href="classfz_1_1Log.html">Log</a> entry minor ID to a three digit zero-padded integer for storage in Postgres.  <a href="namespacefz.html#a4df6964ef0bf050076248edb5be67f44">More...</a><br /></td></tr>
<tr class="separator:a4df6964ef0bf050076248edb5be67f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af4eade92e254bd44d8b19adf94101c"><td class="memItemLeft" align="right" valign="top"><a id="a4af4eade92e254bd44d8b19adf94101c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>add_Logentry_pq</b> (const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq, const <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> &amp;entry)</td></tr>
<tr class="separator:a4af4eade92e254bd44d8b19adf94101c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab993ddfe5c49084cb991598e722b01d5"><td class="memItemLeft" align="right" valign="top"><a id="ab993ddfe5c49084cb991598e722b01d5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>modify_Logentry_pq</b> (const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq, const <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> &amp;entry)</td></tr>
<tr class="separator:ab993ddfe5c49084cb991598e722b01d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231ca1b7588a237bb86e6d0f2f033347"><td class="memItemLeft" align="right" valign="top"><a id="a231ca1b7588a237bb86e6d0f2f033347"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>delete_Logentry_pq</b> (const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq, const <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> &amp;entry)</td></tr>
<tr class="separator:a231ca1b7588a237bb86e6d0f2f033347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac534af76c643c9568951e81e51066108"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ac534af76c643c9568951e81e51066108">store_Log_pq</a> (const <a class="el" href="classfz_1_1Log.html">Log</a> &amp;log, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa, void(*progressfunc)(unsigned long, unsigned long))</td></tr>
<tr class="memdesc:ac534af76c643c9568951e81e51066108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store all the Chunks and Entries of the <a class="el" href="classfz_1_1Log.html">Log</a> in the PostgreSQL database.  <a href="namespacefz.html#ac534af76c643c9568951e81e51066108">More...</a><br /></td></tr>
<tr class="separator:ac534af76c643c9568951e81e51066108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe44bca9b25db84f4d7fca4326ce26b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#abe44bca9b25db84f4d7fca4326ce26b8">append_Log_entry_pq</a> (const <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> &amp;entry, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa)</td></tr>
<tr class="memdesc:abe44bca9b25db84f4d7fca4326ce26b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append Entry to existing table in schema of PostgreSQL database.  <a href="namespacefz.html#abe44bca9b25db84f4d7fca4326ce26b8">More...</a><br /></td></tr>
<tr class="separator:abe44bca9b25db84f4d7fca4326ce26b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72b8468ab398e00c454d3f0770f3e36"><td class="memItemLeft" align="right" valign="top"><a id="ad72b8468ab398e00c454d3f0770f3e36"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>insert_Log_entry_pq</b> (const <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> &amp;entry, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa)</td></tr>
<tr class="separator:ad72b8468ab398e00c454d3f0770f3e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce2b73ba6dd26afc3099321482a02ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a4ce2b73ba6dd26afc3099321482a02ac">update_Log_entry_pq</a> (const <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> &amp;entry, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa)</td></tr>
<tr class="memdesc:a4ce2b73ba6dd26afc3099321482a02ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update Entry in existing table in schema of PostgreSQL database.  <a href="namespacefz.html#a4ce2b73ba6dd26afc3099321482a02ac">More...</a><br /></td></tr>
<tr class="separator:a4ce2b73ba6dd26afc3099321482a02ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43f90f38e3046a0b7593d9d306217b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab43f90f38e3046a0b7593d9d306217b6">delete_Log_entry_pq</a> (const <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> &amp;entry, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa)</td></tr>
<tr class="memdesc:ab43f90f38e3046a0b7593d9d306217b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete Entry from existing table in schema of PostgreSQL database.  <a href="namespacefz.html#ab43f90f38e3046a0b7593d9d306217b6">More...</a><br /></td></tr>
<tr class="separator:ab43f90f38e3046a0b7593d9d306217b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23878d23a56d64f8838ea960784ff451"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a23878d23a56d64f8838ea960784ff451">close_Log_chunk_pq</a> (const <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &amp;chunk, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa)</td></tr>
<tr class="memdesc:a23878d23a56d64f8838ea960784ff451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the Chunk specified, which must already exist within a table in schema of PostgreSQL database.  <a href="namespacefz.html#a23878d23a56d64f8838ea960784ff451">More...</a><br /></td></tr>
<tr class="separator:a23878d23a56d64f8838ea960784ff451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39614b069f7453689a159d7df30189fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a39614b069f7453689a159d7df30189fc">append_Log_chunk_pq</a> (const <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &amp;chunk, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa)</td></tr>
<tr class="memdesc:a39614b069f7453689a159d7df30189fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append Chunk to existing table in schema of PostgreSQL database.  <a href="namespacefz.html#a39614b069f7453689a159d7df30189fc">More...</a><br /></td></tr>
<tr class="separator:a39614b069f7453689a159d7df30189fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd469f5027b57ee54bb01e1fe65285e"><td class="memItemLeft" align="right" valign="top"><a id="affd469f5027b57ee54bb01e1fe65285e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>insert_Log_chunk_pq</b> (const <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &amp;chunk, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa)</td></tr>
<tr class="separator:affd469f5027b57ee54bb01e1fe65285e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9606435e254ac48f610d6005aa10b2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab9606435e254ac48f610d6005aa10b2e">modify_Log_chunk_nid_pq</a> (const <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &amp;chunk, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa)</td></tr>
<tr class="memdesc:ab9606435e254ac48f610d6005aa10b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> to which the Chunk specified belongs.  <a href="namespacefz.html#ab9606435e254ac48f610d6005aa10b2e">More...</a><br /></td></tr>
<tr class="separator:ab9606435e254ac48f610d6005aa10b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f0023444dc67285cc9a602d1d5c10c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a78f0023444dc67285cc9a602d1d5c10c">modify_Log_chunk_id_pq</a> (const <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &amp;chunk, time_t new_id, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa)</td></tr>
<tr class="memdesc:a78f0023444dc67285cc9a602d1d5c10c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change Chunk Open time, i.e.  <a href="namespacefz.html#a78f0023444dc67285cc9a602d1d5c10c">More...</a><br /></td></tr>
<tr class="separator:a78f0023444dc67285cc9a602d1d5c10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5688f3a5a5bb5066690ccff97430eaaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a5688f3a5a5bb5066690ccff97430eaaa">load_Log_pq</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa)</td></tr>
<tr class="memdesc:a5688f3a5a5bb5066690ccff97430eaaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the full <a class="el" href="classfz_1_1Log.html">Log</a> with all <a class="el" href="classfz_1_1Log.html">Log</a> chunks, <a class="el" href="classfz_1_1Log.html">Log</a> entries and Breakpoints from the PostgresSQL database.  <a href="namespacefz.html#a5688f3a5a5bb5066690ccff97430eaaa">More...</a><br /></td></tr>
<tr class="separator:a5688f3a5a5bb5066690ccff97430eaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cb582cc69257b4d2a364f7da5f47c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a87cb582cc69257b4d2a364f7da5f47c0">load_partial_Log_pq</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa, const <a class="el" href="structfz_1_1Log__filter.html">Log_filter</a> &amp;filter)</td></tr>
<tr class="memdesc:a87cb582cc69257b4d2a364f7da5f47c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the <a class="el" href="classfz_1_1Log.html">Log</a> chunks and <a class="el" href="classfz_1_1Log.html">Log</a> entries that satisfy a specific filter.  <a href="namespacefz.html#a87cb582cc69257b4d2a364f7da5f47c0">More...</a><br /></td></tr>
<tr class="separator:a87cb582cc69257b4d2a364f7da5f47c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc58c8f8b64e771f86e4e90d1b63da1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a0fc58c8f8b64e771f86e4e90d1b63da1">load_last_chunk_and_entry_pq</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa)</td></tr>
<tr class="memdesc:a0fc58c8f8b64e771f86e4e90d1b63da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the last <a class="el" href="classfz_1_1Log.html">Log</a> chunk and last <a class="el" href="classfz_1_1Log.html">Log</a> entry in the table.  <a href="namespacefz.html#a0fc58c8f8b64e771f86e4e90d1b63da1">More...</a><br /></td></tr>
<tr class="separator:a0fc58c8f8b64e771f86e4e90d1b63da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb6b12160bc081fe25f613a84eaacdb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a5fb6b12160bc081fe25f613a84eaacdb">store_Node_history_pq</a> (const <a class="el" href="classfz_1_1Node__histories.html">Node_histories</a> &amp;nodehist, <a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa)</td></tr>
<tr class="memdesc:a5fb6b12160bc081fe25f613a84eaacdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a <a class="el" href="structfz_1_1Node__history.html" title="Log history by Node expressed as a list of Log chunks and a list of Log entries for each Node for whi...">Node_history</a> object to a cache table in the database to speed up generation of a Node-specific <a class="el" href="classfz_1_1Log.html">Log</a> history.  <a href="namespacefz.html#a5fb6b12160bc081fe25f613a84eaacdb">More...</a><br /></td></tr>
<tr class="separator:a5fb6b12160bc081fe25f613a84eaacdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669984ccbebfe6dbd9a4d962aded0012"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a669984ccbebfe6dbd9a4d962aded0012">refresh_Node_history_cache_pq</a> (<a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa)</td></tr>
<tr class="memdesc:a669984ccbebfe6dbd9a4d962aded0012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refresh the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> history cache table.  <a href="namespacefz.html#a669984ccbebfe6dbd9a4d962aded0012">More...</a><br /></td></tr>
<tr class="separator:a669984ccbebfe6dbd9a4d962aded0012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd0122917acf4a863edde0051f01600"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a9cd0122917acf4a863edde0051f01600">load_Node_history_cache_entry_pq</a> (<a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq, const <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a> &amp;nkey, <a class="el" href="structfz_1_1Node__history.html">Node_history</a> &amp;nodehist)</td></tr>
<tr class="memdesc:a9cd0122917acf4a863edde0051f01600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the cached <a class="el" href="classfz_1_1Log.html">Log</a> history of a specific <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>.  <a href="namespacefz.html#a9cd0122917acf4a863edde0051f01600">More...</a><br /></td></tr>
<tr class="separator:a9cd0122917acf4a863edde0051f01600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54c18b69cccab6a8254eab47bdcc1f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#af54c18b69cccab6a8254eab47bdcc1f9">load_Node_history_cache_table_pq</a> (<a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;pa, <a class="el" href="classfz_1_1Node__histories.html">Node_histories</a> &amp;nodehistories)</td></tr>
<tr class="memdesc:af54c18b69cccab6a8254eab47bdcc1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a <a class="el" href="classfz_1_1Node__histories.html" title="These Node histories are generated (and cached) in a manner where the set of chunks lists only those ...">Node_histories</a> object from a complete cache table in the database.  <a href="namespacefz.html#af54c18b69cccab6a8254eab47bdcc1f9">More...</a><br /></td></tr>
<tr class="separator:af54c18b69cccab6a8254eab47bdcc1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f47cae19dab82915dc813045ee3cfe"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab2f47cae19dab82915dc813045ee3cfe">Entries_total_text</a> (<a class="el" href="namespacefz.html#aa0bd892bb50b2004fbf6189c332149e2">Log_entries_Map</a> &amp;entries)</td></tr>
<tr class="memdesc:ab2f47cae19dab82915dc813045ee3cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the total number of characters in <a class="el" href="classfz_1_1Log.html">Log</a> entry description text in the specified map.  <a href="namespacefz.html#ab2f47cae19dab82915dc813045ee3cfe">More...</a><br /></td></tr>
<tr class="separator:ab2f47cae19dab82915dc813045ee3cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad749cc98362cd5b1af14cb171ead68fb"><td class="memItemLeft" align="right" valign="top"><a id="ad749cc98362cd5b1af14cb171ead68fb"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Log_entry_ID_TimeStamp_to_string</b> (const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> idT)</td></tr>
<tr class="separator:ad749cc98362cd5b1af14cb171ead68fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbff141b73f7b28f4d4b128ead8ba5d"><td class="memItemLeft" align="right" valign="top"><a id="acbbff141b73f7b28f4d4b128ead8ba5d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Log_chunk_ID_TimeStamp_to_string</b> (const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> idT)</td></tr>
<tr class="separator:acbbff141b73f7b28f4d4b128ead8ba5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a11e58e46a7c11d34572de05a7ebd8"><td class="memItemLeft" align="right" valign="top"><a id="a87a11e58e46a7c11d34572de05a7ebd8"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Log_TimeStamp_to_Ymd_string</b> (const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> idT)</td></tr>
<tr class="separator:a87a11e58e46a7c11d34572de05a7ebd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ced31e8ffbaf54c00a9f586eaf1dd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a61ced31e8ffbaf54c00a9f586eaf1dd4">valid_Log_entry_ID</a> (const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> &amp;idT, std::string &amp;formerror)</td></tr>
<tr class="memdesc:a61ced31e8ffbaf54c00a9f586eaf1dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a <a class="el" href="structfz_1_1Log__TimeStamp.html" title="Timestamp IDs in the format required for Log IDs.">Log_TimeStamp</a> can be used as a valid <a class="el" href="classfz_1_1Log__entry__ID.html">Log_entry_ID</a>.  <a href="namespacefz.html#a61ced31e8ffbaf54c00a9f586eaf1dd4">More...</a><br /></td></tr>
<tr class="separator:a61ced31e8ffbaf54c00a9f586eaf1dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045ec1abb4dc382e0b56e345c146de95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a045ec1abb4dc382e0b56e345c146de95">valid_Log_chunk_ID</a> (const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> &amp;idT, std::string &amp;formerror)</td></tr>
<tr class="memdesc:a045ec1abb4dc382e0b56e345c146de95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a <a class="el" href="structfz_1_1Log__TimeStamp.html" title="Timestamp IDs in the format required for Log IDs.">Log_TimeStamp</a> can be used as a valid <a class="el" href="classfz_1_1Log__chunk__ID.html">Log_chunk_ID</a>.  <a href="namespacefz.html#a045ec1abb4dc382e0b56e345c146de95">More...</a><br /></td></tr>
<tr class="separator:a045ec1abb4dc382e0b56e345c146de95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0d31396e23ba90447163d6b714f1d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a8c0d31396e23ba90447163d6b714f1d5">valid_Log_entry_ID</a> (std::string id_str, std::string &amp;formerror, <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> *id_timestamp)</td></tr>
<tr class="memdesc:a8c0d31396e23ba90447163d6b714f1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a string can be used to form a valid <a class="el" href="classfz_1_1Log__entry__ID.html">Log_entry_ID</a>.  <a href="namespacefz.html#a8c0d31396e23ba90447163d6b714f1d5">More...</a><br /></td></tr>
<tr class="separator:a8c0d31396e23ba90447163d6b714f1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957bdd835342852a8ef5ad94723e34cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a957bdd835342852a8ef5ad94723e34cf">valid_Log_chunk_ID</a> (std::string id_str, std::string &amp;formerror, <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> *id_timestamp)</td></tr>
<tr class="memdesc:a957bdd835342852a8ef5ad94723e34cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a string can be used to form a valid <a class="el" href="classfz_1_1Log__chunk__ID.html">Log_chunk_ID</a>.  <a href="namespacefz.html#a957bdd835342852a8ef5ad94723e34cf">More...</a><br /></td></tr>
<tr class="separator:a957bdd835342852a8ef5ad94723e34cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d41a65ead33aea665b4ac04835c90a"><td class="memItemLeft" align="right" valign="top">pid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ac5d41a65ead33aea665b4ac04835c90a">this_program_process_ID</a> ()</td></tr>
<tr class="memdesc:ac5d41a65ead33aea665b4ac04835c90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the PID of this program.  <a href="namespacefz.html#ac5d41a65ead33aea665b4ac04835c90a">More...</a><br /></td></tr>
<tr class="separator:ac5d41a65ead33aea665b4ac04835c90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6879de9cbd1cbf4936df50b67786e959"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a6879de9cbd1cbf4936df50b67786e959">get_process_status</a> (pid_t pid)</td></tr>
<tr class="memdesc:a6879de9cbd1cbf4936df50b67786e959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get process status from /proc.  <a href="namespacefz.html#a6879de9cbd1cbf4936df50b67786e959">More...</a><br /></td></tr>
<tr class="separator:a6879de9cbd1cbf4936df50b67786e959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6951620bac95418982701ccae1b150c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a6951620bac95418982701ccae1b150c6">test_process_running</a> (pid_t pid)</td></tr>
<tr class="memdesc:a6951620bac95418982701ccae1b150c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a process with a specific PID is running.  <a href="namespacefz.html#a6951620bac95418982701ccae1b150c6">More...</a><br /></td></tr>
<tr class="separator:a6951620bac95418982701ccae1b150c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca86ba1c3f53596224cbff46786d7af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#abca86ba1c3f53596224cbff46786d7af">check_and_make_lockfile</a> (const std::string lockfilepath, std::string extrainfo)</td></tr>
<tr class="memdesc:abca86ba1c3f53596224cbff46786d7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a lockfile that contains a PID and time stamp, plus optional extra info.  <a href="namespacefz.html#abca86ba1c3f53596224cbff46786d7af">More...</a><br /></td></tr>
<tr class="separator:abca86ba1c3f53596224cbff46786d7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ade55b0bb312702da34cfefc4cbace4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a2ade55b0bb312702da34cfefc4cbace4">remove_lockfile</a> (const std::string lockfilepath)</td></tr>
<tr class="memdesc:a2ade55b0bb312702da34cfefc4cbace4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove lockfile and report if the lockfile existed.  <a href="namespacefz.html#a2ade55b0bb312702da34cfefc4cbace4">More...</a><br /></td></tr>
<tr class="separator:a2ade55b0bb312702da34cfefc4cbace4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5030189781f4e027de8b67b55c13ed9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ac5030189781f4e027de8b67b55c13ed9">check_and_read_lockfile</a> (const std::string lockfilepath, std::string &amp;lockfilecontent)</td></tr>
<tr class="memdesc:ac5030189781f4e027de8b67b55c13ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to see if a lockfile exists and read it.  <a href="namespacefz.html#ac5030189781f4e027de8b67b55c13ed9">More...</a><br /></td></tr>
<tr class="separator:ac5030189781f4e027de8b67b55c13ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae767b87541ed3adf95ef80fb4cab307e"><td class="memItemLeft" align="right" valign="top">std::time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae767b87541ed3adf95ef80fb4cab307e">ActualTime</a> ()</td></tr>
<tr class="memdesc:ae767b87541ed3adf95ef80fb4cab307e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly provide the actual system time.  <a href="namespacefz.html#ae767b87541ed3adf95ef80fb4cab307e">More...</a><br /></td></tr>
<tr class="separator:ae767b87541ed3adf95ef80fb4cab307e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdf2285bd874038959c3aca55feac8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a5cdf2285bd874038959c3aca55feac8d">error_summary_wrapper</a> ()</td></tr>
<tr class="memdesc:a5cdf2285bd874038959c3aca55feac8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapped version of ERRWARN_SUMMARY that can be stacked.  <a href="namespacefz.html#a5cdf2285bd874038959c3aca55feac8d">More...</a><br /></td></tr>
<tr class="separator:a5cdf2285bd874038959c3aca55feac8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dba8841daadafb13e8b74c2ea661b9"><td class="memItemLeft" align="right" valign="top"><a id="ae7dba8841daadafb13e8b74c2ea661b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae7dba8841daadafb13e8b74c2ea661b9">clean_exit_wrapper</a> ()</td></tr>
<tr class="memdesc:ae7dba8841daadafb13e8b74c2ea661b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This does everyting that <code><a class="el" href="namespacefz.html#a3cd066a32696261830f98ca59ce4a7f0" title="Clean up after yourself before you exit.">fz::Clean_Exit()</a></code> does, and it is stacked. <br /></td></tr>
<tr class="separator:ae7dba8841daadafb13e8b74c2ea661b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a72c04fc5a7860678e9156bd32b5aa1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a4a72c04fc5a7860678e9156bd32b5aa1">safe_cmdline_options</a> (int argc, char *argv[], std::string options, int &amp;optindcopy)</td></tr>
<tr class="memdesc:a4a72c04fc5a7860678e9156bd32b5aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safer parsing of command line parameters.  <a href="namespacefz.html#a4a72c04fc5a7860678e9156bd32b5aa1">More...</a><br /></td></tr>
<tr class="separator:a4a72c04fc5a7860678e9156bd32b5aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac327c945f41c63fef32c002d058fb7c"><td class="memItemLeft" align="right" valign="top"><a id="aac327c945f41c63fef32c002d058fb7c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aac327c945f41c63fef32c002d058fb7c">key_pause</a> ()</td></tr>
<tr class="memdesc:aac327c945f41c63fef32c002d058fb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A very simple function to wait for ENTER to be pressed. <br /></td></tr>
<tr class="separator:aac327c945f41c63fef32c002d058fb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c63ce005bec27f3389012c7f14d236"><td class="memItemLeft" align="right" valign="top"><a id="ad5c63ce005bec27f3389012c7f14d236"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ad5c63ce005bec27f3389012c7f14d236">default_choice</a> (const std::string question, char not_default)</td></tr>
<tr class="memdesc:ad5c63ce005bec27f3389012c7f14d236"><td class="mdescLeft">&#160;</td><td class="mdescRight">A very simple function to interactively make a binary choice. <br /></td></tr>
<tr class="separator:ad5c63ce005bec27f3389012c7f14d236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e2bf7ac373f00fc7a336d2b3e58168"><td class="memItemLeft" align="right" valign="top"><a id="ae0e2bf7ac373f00fc7a336d2b3e58168"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>standard_mute</b> ()</td></tr>
<tr class="separator:ae0e2bf7ac373f00fc7a336d2b3e58168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ca43edf98ee309ad34b7cc1d047f81"><td class="memItemLeft" align="right" valign="top"><a id="aa5ca43edf98ee309ad34b7cc1d047f81"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>standard_unmute</b> ()</td></tr>
<tr class="separator:aa5ca43edf98ee309ad34b7cc1d047f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f23fc68a8703892fd06a8207cae3e4a"><td class="memItemLeft" align="right" valign="top"><a id="a0f23fc68a8703892fd06a8207cae3e4a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a0f23fc68a8703892fd06a8207cae3e4a">standard_exit_success</a> (std::string veryverbose_message)</td></tr>
<tr class="memdesc:a0f23fc68a8703892fd06a8207cae3e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Another set of exit options, these with potential messages. <br /></td></tr>
<tr class="separator:a0f23fc68a8703892fd06a8207cae3e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae49efd9c0a80ebf4a3110ac5942b86"><td class="memItemLeft" align="right" valign="top"><a id="a6ae49efd9c0a80ebf4a3110ac5942b86"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>standard_exit_error</b> (int exit_code, std::string error_message, const char *problem__func__)</td></tr>
<tr class="separator:a6ae49efd9c0a80ebf4a3110ac5942b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03aabff766acae3161e28e551d06d71"><td class="memItemLeft" align="right" valign="top"><a id="ad03aabff766acae3161e28e551d06d71"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>standard_exit</b> (bool success, std::string veryverbose_message, int exit_code, std::string error_message, const char *problem__func__)</td></tr>
<tr class="separator:ad03aabff766acae3161e28e551d06d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea20a984e3df8f30caadc6c4eb46381"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#abea20a984e3df8f30caadc6c4eb46381">string_to_file</a> (const std::string path, const std::string &amp;s, std::ofstream::iostate *writestate)</td></tr>
<tr class="memdesc:abea20a984e3df8f30caadc6c4eb46381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the full contents of a string to a file.  <a href="namespacefz.html#abea20a984e3df8f30caadc6c4eb46381">More...</a><br /></td></tr>
<tr class="separator:abea20a984e3df8f30caadc6c4eb46381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad93411e21c8c804d2b47e1e0beb4b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a7ad93411e21c8c804d2b47e1e0beb4b9">append_string_to_file</a> (const std::string path, const std::string &amp;s, std::ofstream::iostate *writestate)</td></tr>
<tr class="memdesc:a7ad93411e21c8c804d2b47e1e0beb4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the full contents of a string to a file.  <a href="namespacefz.html#a7ad93411e21c8c804d2b47e1e0beb4b9">More...</a><br /></td></tr>
<tr class="separator:a7ad93411e21c8c804d2b47e1e0beb4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82121e1189c46fe028b6b6e9a073c8d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a82121e1189c46fe028b6b6e9a073c8d5">string_to_file_with_backup</a> (std::string path, std::string &amp;s, std::string backupext, bool &amp;backedup, std::ofstream::iostate *writestate)</td></tr>
<tr class="memdesc:a82121e1189c46fe028b6b6e9a073c8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the full contents of a string to a file, but move an existing file at the given path to a backup name first.  <a href="namespacefz.html#a82121e1189c46fe028b6b6e9a073c8d5">More...</a><br /></td></tr>
<tr class="separator:a82121e1189c46fe028b6b6e9a073c8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a2a6715fce1e3b724ddd482214fb0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a60a2a6715fce1e3b724ddd482214fb0a">file_to_string</a> (const std::string &amp;path, std::string &amp;s, std::ifstream::iostate *readstate)</td></tr>
<tr class="memdesc:a60a2a6715fce1e3b724ddd482214fb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the full contents of a (text) file into a string.  <a href="namespacefz.html#a60a2a6715fce1e3b724ddd482214fb0a">More...</a><br /></td></tr>
<tr class="separator:a60a2a6715fce1e3b724ddd482214fb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4ae42399db02b1b71a5d5771f16139"><td class="memItemLeft" align="right" valign="top"><a id="a7e4ae42399db02b1b71a5d5771f16139"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>string_from_file</b> (std::string path, std::ifstream::iostate *readstate=nullptr)</td></tr>
<tr class="separator:a7e4ae42399db02b1b71a5d5771f16139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae354d176f2f483264ec225411f7eb122"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae354d176f2f483264ec225411f7eb122">stream_to_string</a> (std::istream &amp;in, std::string &amp;s)</td></tr>
<tr class="memdesc:ae354d176f2f483264ec225411f7eb122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the full contents of a (text) stream into a string.  <a href="namespacefz.html#ae354d176f2f483264ec225411f7eb122">More...</a><br /></td></tr>
<tr class="separator:ae354d176f2f483264ec225411f7eb122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0935a21886cd77a134efd55059d2ef13"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacefz.html#a95a7b508456ccb1691f487ed136d52d4">exit_status_code</a>, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a0935a21886cd77a134efd55059d2ef13">get_content</a> (std::string &amp;utf8_text, const std::string content_path, const std::string errmsg_target)</td></tr>
<tr class="memdesc:a0935a21886cd77a134efd55059d2ef13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to fill a string with text content if it was empty.  <a href="namespacefz.html#a0935a21886cd77a134efd55059d2ef13">More...</a><br /></td></tr>
<tr class="separator:a0935a21886cd77a134efd55059d2ef13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefadca0ccb3cfd802ca2f7648e9cac25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aefadca0ccb3cfd802ca2f7648e9cac25">client_socket_shmem_request</a> (std::string request_str, std::string server_ip_address, uint16_t port_number, std::string &amp;response_str)</td></tr>
<tr class="memdesc:aefadca0ccb3cfd802ca2f7648e9cac25"><td class="mdescLeft">&#160;</td><td class="mdescRight">A minimal TCP client communication function used to make the server aware of a request specified by data in shared memory.  <a href="namespacefz.html#aefadca0ccb3cfd802ca2f7648e9cac25">More...</a><br /></td></tr>
<tr class="separator:aefadca0ccb3cfd802ca2f7648e9cac25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f8fda024c1d778ea48ace049e6406d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefz.html#a95a7b508456ccb1691f487ed136d52d4">exit_status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae1f8fda024c1d778ea48ace049e6406d">server_request_with_shared_data</a> (std::string segname, uint16_t port_number)</td></tr>
<tr class="memdesc:ae1f8fda024c1d778ea48ace049e6406d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contact the server with the unique label of shared memory containing data for a <a class="el" href="classfz_1_1Graph.html">Graph</a> modification request.  <a href="namespacefz.html#ae1f8fda024c1d778ea48ace049e6406d">More...</a><br /></td></tr>
<tr class="separator:ae1f8fda024c1d778ea48ace049e6406d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb11c293fe75898f1b9643466b018e9f"><td class="memItemLeft" align="right" valign="top">GET_token_value_vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#acb11c293fe75898f1b9643466b018e9f">GET_token_values</a> (const std::string httpgetstr, const char argseparator='&amp;')</td></tr>
<tr class="memdesc:acb11c293fe75898f1b9643466b018e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert portion of a HTTP GET string into a vector of token-value pairs.  <a href="namespacefz.html#acb11c293fe75898f1b9643466b018e9f">More...</a><br /></td></tr>
<tr class="separator:acb11c293fe75898f1b9643466b018e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd43dd007911040fd9782a1130ed653"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#abdd43dd007911040fd9782a1130ed653">mimetype_by_extension</a> (const std::string &amp;file_path)</td></tr>
<tr class="memdesc:abdd43dd007911040fd9782a1130ed653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a MIME type string reference that corresponds with the extension of a file path.  <a href="namespacefz.html#abdd43dd007911040fd9782a1130ed653">More...</a><br /></td></tr>
<tr class="separator:abdd43dd007911040fd9782a1130ed653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4f9a2b8943c1b429238e348efd47dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a0f4f9a2b8943c1b429238e348efd47dc">find_server_address</a> (std::string &amp;ipaddr_str)</td></tr>
<tr class="memdesc:a0f4f9a2b8943c1b429238e348efd47dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover this server's IP address from the perspective of a connecting TCP client.  <a href="namespacefz.html#a0f4f9a2b8943c1b429238e348efd47dc">More...</a><br /></td></tr>
<tr class="separator:a0f4f9a2b8943c1b429238e348efd47dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326d23fce4986b21fbe0d8cbcbcc776a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefz.html#a95a7b508456ccb1691f487ed136d52d4">exit_status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a326d23fce4986b21fbe0d8cbcbcc776a">server_socket_listen</a> (uint16_t port_number, <a class="el" href="structfz_1_1shared__memory__server.html">shared_memory_server</a> &amp;server)</td></tr>
<tr class="memdesc:a326d23fce4986b21fbe0d8cbcbcc776a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up an IPv4 TCP socket on specified port and listen for client connections from any address.  <a href="namespacefz.html#a326d23fce4986b21fbe0d8cbcbcc776a">More...</a><br /></td></tr>
<tr class="separator:a326d23fce4986b21fbe0d8cbcbcc776a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f1ea1c06a6640cec379b93dd751971"><td class="memItemLeft" align="right" valign="top">const std::tm *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aa9f1ea1c06a6640cec379b93dd751971">safe_localtime</a> (const std::time_t *t_ptr, int *errorcode_ptr=nullptr)</td></tr>
<tr class="memdesc:aa9f1ea1c06a6640cec379b93dd751971"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Formalizer standardized version of the localtime() function that always returns a usable value, but which may log errors or warnings as needed.  <a href="namespacefz.html#aa9f1ea1c06a6640cec379b93dd751971">More...</a><br /></td></tr>
<tr class="separator:aa9f1ea1c06a6640cec379b93dd751971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b50bdd16d9e99e3ff4bf398f3fe68f"><td class="memItemLeft" align="right" valign="top">std::time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a50b50bdd16d9e99e3ff4bf398f3fe68f">time_stamp_time</a> (std::string timestr, bool noerror=false)</td></tr>
<tr class="memdesc:a50b50bdd16d9e99e3ff4bf398f3fe68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Formalizer time stamp string into local Unix time.  <a href="namespacefz.html#a50b50bdd16d9e99e3ff4bf398f3fe68f">More...</a><br /></td></tr>
<tr class="separator:a50b50bdd16d9e99e3ff4bf398f3fe68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0003e81e0cb15861b2dfa5fa1469e2"><td class="memItemLeft" align="right" valign="top">std::time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#acd0003e81e0cb15861b2dfa5fa1469e2">ymd_stamp_time</a> (std::string timestr, bool noerror=false, bool ignoreHM=false)</td></tr>
<tr class="memdesc:acd0003e81e0cb15861b2dfa5fa1469e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">UNIX epoch time equivalent of a Year-Month-Day date-stamp such as 20200914 or 202009140100.  <a href="namespacefz.html#acd0003e81e0cb15861b2dfa5fa1469e2">More...</a><br /></td></tr>
<tr class="separator:acd0003e81e0cb15861b2dfa5fa1469e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b13840120d2acc08fa2fb25a6c3d6a4"><td class="memItemLeft" align="right" valign="top"><a id="a7b13840120d2acc08fa2fb25a6c3d6a4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>TimeStamp</b> (const char *dateformat, std::time_t t)</td></tr>
<tr class="separator:a7b13840120d2acc08fa2fb25a6c3d6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58effa18dd1037431893b3ad00de2005"><td class="memItemLeft" align="right" valign="top"><a id="a58effa18dd1037431893b3ad00de2005"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a58effa18dd1037431893b3ad00de2005">TimeStampYmdHM</a> (std::time_t t)</td></tr>
<tr class="memdesc:a58effa18dd1037431893b3ad00de2005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Formalizer standardized date and time stamp (YYYYmmddHHMM). <br /></td></tr>
<tr class="separator:a58effa18dd1037431893b3ad00de2005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f965a9972440886cdbba23dee898e6e"><td class="memItemLeft" align="right" valign="top"><a id="a8f965a9972440886cdbba23dee898e6e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a8f965a9972440886cdbba23dee898e6e">DateStampYmd</a> (std::time_t t)</td></tr>
<tr class="memdesc:a8f965a9972440886cdbba23dee898e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Formalizer standardized date stamp (YYYYmmdd). <br /></td></tr>
<tr class="separator:a8f965a9972440886cdbba23dee898e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7686eba8206f15402dbd218f75760fe5"><td class="memItemLeft" align="right" valign="top"><a id="a7686eba8206f15402dbd218f75760fe5"></a>
std::time_t&#160;</td><td class="memItemRight" valign="bottom"><b>day_start_time</b> (std::time_t t)</td></tr>
<tr class="separator:a7686eba8206f15402dbd218f75760fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840b3d3595bbb714ca79d8181416be8a"><td class="memItemLeft" align="right" valign="top"><a id="a840b3d3595bbb714ca79d8181416be8a"></a>
std::time_t&#160;</td><td class="memItemRight" valign="bottom"><b>day_end_time</b> (std::time_t t)</td></tr>
<tr class="separator:a840b3d3595bbb714ca79d8181416be8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f6759d27054bb578e51d5aa15472ee"><td class="memItemLeft" align="right" valign="top"><a id="ab3f6759d27054bb578e51d5aa15472ee"></a>
std::time_t&#160;</td><td class="memItemRight" valign="bottom"><b>today_start_time</b> ()</td></tr>
<tr class="separator:ab3f6759d27054bb578e51d5aa15472ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728692185c1123588945f25859160039"><td class="memItemLeft" align="right" valign="top"><a id="a728692185c1123588945f25859160039"></a>
std::time_t&#160;</td><td class="memItemRight" valign="bottom"><b>today_end_time</b> ()</td></tr>
<tr class="separator:a728692185c1123588945f25859160039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4308075d0f8dc4c0129d8ee71740e5"><td class="memItemLeft" align="right" valign="top"><a id="abe4308075d0f8dc4c0129d8ee71740e5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#abe4308075d0f8dc4c0129d8ee71740e5">BackupStampYmd</a> ()</td></tr>
<tr class="memdesc:abe4308075d0f8dc4c0129d8ee71740e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Formalizer standardized file backup extension (YYYYmmdd.bak). <br /></td></tr>
<tr class="separator:abe4308075d0f8dc4c0129d8ee71740e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4932c9514aab01039104a5b0033934d4"><td class="memItemLeft" align="right" valign="top"><a id="a4932c9514aab01039104a5b0033934d4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a4932c9514aab01039104a5b0033934d4">BackupStampYmdHM</a> ()</td></tr>
<tr class="memdesc:a4932c9514aab01039104a5b0033934d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Formalizer standardized file backup precise extension (YYYYmmddHHMM.bak). <br /></td></tr>
<tr class="separator:a4932c9514aab01039104a5b0033934d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cc54d3010e21ccc9d0f63b2be1d342"><td class="memItemLeft" align="right" valign="top"><a id="a06cc54d3010e21ccc9d0f63b2be1d342"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>WeekDay</b> (time_t t)</td></tr>
<tr class="separator:a06cc54d3010e21ccc9d0f63b2be1d342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4e4e831d550552623ac9930b046679"><td class="memItemLeft" align="right" valign="top"><a id="afe4e4e831d550552623ac9930b046679"></a>
time_t&#160;</td><td class="memItemRight" valign="bottom"><b>time_add_day</b> (time_t t, int days=1)</td></tr>
<tr class="separator:afe4e4e831d550552623ac9930b046679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099b0e075c1b2ea1acbf0406b489222d"><td class="memItemLeft" align="right" valign="top"><a id="a099b0e075c1b2ea1acbf0406b489222d"></a>
time_t&#160;</td><td class="memItemRight" valign="bottom"><b>time_add_month</b> (time_t t, int months=1)</td></tr>
<tr class="separator:a099b0e075c1b2ea1acbf0406b489222d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd035f86e75d63b89767bd9e57407ef"><td class="memItemLeft" align="right" valign="top"><a id="a1bd035f86e75d63b89767bd9e57407ef"></a>
day_of_week&#160;</td><td class="memItemRight" valign="bottom"><b>time_day_of_week</b> (time_t t)</td></tr>
<tr class="separator:a1bd035f86e75d63b89767bd9e57407ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece9a0dc7424e87381551c7804b9eabd"><td class="memItemLeft" align="right" valign="top"><a id="aece9a0dc7424e87381551c7804b9eabd"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>time_hour</b> (time_t t)</td></tr>
<tr class="separator:aece9a0dc7424e87381551c7804b9eabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0895b9b6ea56b1d62e58791d381280"><td class="memItemLeft" align="right" valign="top"><a id="a2d0895b9b6ea56b1d62e58791d381280"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>time_minute</b> (time_t t)</td></tr>
<tr class="separator:a2d0895b9b6ea56b1d62e58791d381280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab071e1a9b08b9df7f1ad7fe0931f577"><td class="memItemLeft" align="right" valign="top"><a id="aab071e1a9b08b9df7f1ad7fe0931f577"></a>
<a class="el" href="structfz_1_1time__of__day__t.html">time_of_day_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>time_of_day</b> (time_t t)</td></tr>
<tr class="separator:aab071e1a9b08b9df7f1ad7fe0931f577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ada33761df37bd2083becbf9223caf"><td class="memItemLeft" align="right" valign="top"><a id="a10ada33761df37bd2083becbf9223caf"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>date_as_ulong</b> (time_t t)</td></tr>
<tr class="separator:a10ada33761df37bd2083becbf9223caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8fb8a3bff79545ea7cc8786e8eb127"><td class="memItemLeft" align="right" valign="top"><a id="aaf8fb8a3bff79545ea7cc8786e8eb127"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>time_month_length</b> (time_t t)</td></tr>
<tr class="separator:aaf8fb8a3bff79545ea7cc8786e8eb127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6a2bdcc7bdd0c2a578ca1e32bdbade"><td class="memItemLeft" align="right" valign="top"><a id="aef6a2bdcc7bdd0c2a578ca1e32bdbade"></a>
time_t&#160;</td><td class="memItemRight" valign="bottom"><b>time_add_month_EOMoffset</b> (time_t t)</td></tr>
<tr class="separator:aef6a2bdcc7bdd0c2a578ca1e32bdbade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30be49d20ac6c8ba1b313fc295a235a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a30be49d20ac6c8ba1b313fc295a235a2">is_leapyear</a> (unsigned int year)</td></tr>
<tr class="memdesc:a30be49d20ac6c8ba1b313fc295a235a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple leap year test.  <a href="namespacefz.html#a30be49d20ac6c8ba1b313fc295a235a2">More...</a><br /></td></tr>
<tr class="separator:a30be49d20ac6c8ba1b313fc295a235a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af320a36d5d2f05de32419ea52f625e1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#af320a36d5d2f05de32419ea52f625e1e">valid_year_month_day</a> (<a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a> ymd)</td></tr>
<tr class="memdesc:af320a36d5d2f05de32419ea52f625e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a year, month and day form a valid date.  <a href="namespacefz.html#af320a36d5d2f05de32419ea52f625e1e">More...</a><br /></td></tr>
<tr class="separator:af320a36d5d2f05de32419ea52f625e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053fc7625765a11b31ee3604a1f225b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a053fc7625765a11b31ee3604a1f225b0">years_months_days</a> (<a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a> ymd1, <a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a> ymd2)</td></tr>
<tr class="memdesc:a053fc7625765a11b31ee3604a1f225b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Express the difference between two dates in terms of the number of Years, Months and Days between them.  <a href="namespacefz.html#a053fc7625765a11b31ee3604a1f225b0">More...</a><br /></td></tr>
<tr class="separator:a053fc7625765a11b31ee3604a1f225b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bfa54595aa468eba2c7e5fda819ecf"><td class="memItemLeft" align="right" valign="top"><a id="a84bfa54595aa468eba2c7e5fda819ecf"></a>
<a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>years_months_days</b> (std::time_t t1, std::time_t t2)</td></tr>
<tr class="separator:a84bfa54595aa468eba2c7e5fda819ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5a614340e67aa9ff729f387ca8e987"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a6b5a614340e67aa9ff729f387ca8e987">utf8_safe</a> (const std::string &amp;utf8str, bool warn=true)</td></tr>
<tr class="memdesc:a6b5a614340e67aa9ff729f387ca8e987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter a text string to ensure that it contains valid UTF8 encoded content.  <a href="namespacefz.html#a6b5a614340e67aa9ff729f387ca8e987">More...</a><br /></td></tr>
<tr class="separator:a6b5a614340e67aa9ff729f387ca8e987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616d2f790d66f5979baa65f9e480fe04"><td class="memItemLeft" align="right" valign="top"><a id="a616d2f790d66f5979baa65f9e480fe04"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>read_file_into_buf</b> (std::string file_path, size_t &amp;lSize)</td></tr>
<tr class="separator:a616d2f790d66f5979baa65f9e480fe04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7dc82ea6c4ab29ef2cbb51d09e7b8a"><td class="memItemLeft" align="right" valign="top"><a id="a8a7dc82ea6c4ab29ef2cbb51d09e7b8a"></a>
<a class="el" href="classfz_1_1Errors.html">Errors</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ErrQ</b> (DEFAULT_ERRLOGPATH)</td></tr>
<tr class="separator:a8a7dc82ea6c4ab29ef2cbb51d09e7b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf44b9878517c39c7fc3b53d7c7f56a6"><td class="memItemLeft" align="right" valign="top"><a id="acf44b9878517c39c7fc3b53d7c7f56a6"></a>
<a class="el" href="classfz_1_1Errors.html">Errors</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WarnQ</b> (DEFAULT_WARNLOGPATH)</td></tr>
<tr class="separator:acf44b9878517c39c7fc3b53d7c7f56a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92c33335884636dc87618708050f5dc"><td class="memItemLeft" align="right" valign="top"><a id="ac92c33335884636dc87618708050f5dc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ac92c33335884636dc87618708050f5dc">simPQ_report_wrapper</a> ()</td></tr>
<tr class="memdesc:ac92c33335884636dc87618708050f5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exit hook function that ensures any simulated Postgres calls are written to a file. <br /></td></tr>
<tr class="separator:ac92c33335884636dc87618708050f5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b84c36d3ebbf295bcbd154874858b3"><td class="memItemLeft" align="right" valign="top"><a id="a34b84c36d3ebbf295bcbd154874858b3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>identical_Topics</b> (const <a class="el" href="classfz_1_1Topic.html">Topic</a> &amp;topic1, const <a class="el" href="classfz_1_1Topic.html">Topic</a> &amp;topic2, std::string &amp;trace)</td></tr>
<tr class="separator:a34b84c36d3ebbf295bcbd154874858b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e57f175450656687c5ca428725d97bd"><td class="memItemLeft" align="right" valign="top"><a id="a9e57f175450656687c5ca428725d97bd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>identical_Topic_Tags</b> (<a class="el" href="classfz_1_1Topic__Tags.html">Topic_Tags</a> &amp;ttags1, <a class="el" href="classfz_1_1Topic__Tags.html">Topic_Tags</a> &amp;ttags2, std::string &amp;trace)</td></tr>
<tr class="separator:a9e57f175450656687c5ca428725d97bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa017a0d639d3d67ac4b304efa514eae9"><td class="memItemLeft" align="right" valign="top"><a id="aa017a0d639d3d67ac4b304efa514eae9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>identical_Node_ID_key</b> (const <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a> &amp;key1, const <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a> &amp;key2, std::string &amp;trace)</td></tr>
<tr class="separator:aa017a0d639d3d67ac4b304efa514eae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f4dc710aff55f6fd9c2e111d7df259"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a96f4dc710aff55f6fd9c2e111d7df259">identical_Nodes</a> (<a class="el" href="classfz_1_1Node.html">Node</a> &amp;node1, <a class="el" href="classfz_1_1Node.html">Node</a> &amp;node2, std::string &amp;trace)</td></tr>
<tr class="memdesc:a96f4dc710aff55f6fd9c2e111d7df259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> objects contain the same data.  <a href="namespacefz.html#a96f4dc710aff55f6fd9c2e111d7df259">More...</a><br /></td></tr>
<tr class="separator:a96f4dc710aff55f6fd9c2e111d7df259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3bb9d1734c1f79ca4d1f2c0e269d93"><td class="memItemLeft" align="right" valign="top"><a id="afe3bb9d1734c1f79ca4d1f2c0e269d93"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>identical_Edge_ID_key</b> (const <a class="el" href="structfz_1_1Edge__ID__key.html">Edge_ID_key</a> &amp;key1, const <a class="el" href="structfz_1_1Edge__ID__key.html">Edge_ID_key</a> &amp;key2, std::string &amp;trace)</td></tr>
<tr class="separator:afe3bb9d1734c1f79ca4d1f2c0e269d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c6c4def4995096eab72c38358ffdeb"><td class="memItemLeft" align="right" valign="top"><a id="ae7c6c4def4995096eab72c38358ffdeb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>identical_Edges</b> (<a class="el" href="classfz_1_1Edge.html">Edge</a> &amp;edge1, <a class="el" href="classfz_1_1Edge.html">Edge</a> &amp;edge2, std::string &amp;trace)</td></tr>
<tr class="separator:ae7c6c4def4995096eab72c38358ffdeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569da80848b8001bc12867337f51d1c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a569da80848b8001bc12867337f51d1c9">identical_Graphs</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph1, <a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph2, std::string &amp;trace)</td></tr>
<tr class="memdesc:a569da80848b8001bc12867337f51d1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two Graphs to report if they are data-identical.  <a href="namespacefz.html#a569da80848b8001bc12867337f51d1c9">More...</a><br /></td></tr>
<tr class="separator:a569da80848b8001bc12867337f51d1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d56dcf9ec811c82f940e7061ce1661b"><td class="memItemLeft" align="right" valign="top"><a id="a0d56dcf9ec811c82f940e7061ce1661b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>append_filter_bit_status</b> (std::string &amp;s, bool bitflag, std::string label, std::string lower_str, std::string upper_str)</td></tr>
<tr class="separator:a0d56dcf9ec811c82f940e7061ce1661b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e57f3d34eb8255b60ea053ec466d776"><td class="memItemLeft" align="right" valign="top"><a id="a4e57f3d34eb8255b60ea053ec466d776"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>graphmod_results_add_to_info_str</b> (const <a class="el" href="structfz_1_1Graphmod__result.html">Graphmod_result</a> &amp;modres, std::string &amp;infostr)</td></tr>
<tr class="separator:a4e57f3d34eb8255b60ea053ec466d776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99455b568fc2d7dbf7b1c150197bb28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ac99455b568fc2d7dbf7b1c150197bb28">Node_completed_repeating</a> (<a class="el" href="classfz_1_1Node.html">Node</a> &amp;node, <a class="el" href="classfz_1_1Edit__flags.html">Edit_flags</a> &amp;editflags, time_t t_ref=<a class="el" href="namespacefz.html#aef05dd6bfa4d4a09d3eace4949b6fab0a328419ab650b1af199fdb58a44105aaa">RTt_unspecified</a>)</td></tr>
<tr class="memdesc:ac99455b568fc2d7dbf7b1c150197bb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depending on the tdpattern type of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>, potentially modify its targetdate in accordance with that repetition pattern and reset its completion ratio.  <a href="namespacefz.html#ac99455b568fc2d7dbf7b1c150197bb28">More...</a><br /></td></tr>
<tr class="separator:ac99455b568fc2d7dbf7b1c150197bb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51db678bb5c84838eae7c598afeb2ecb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a51db678bb5c84838eae7c598afeb2ecb">Node_completed_non_repeating_more_required</a> (<a class="el" href="classfz_1_1Node.html">Node</a> &amp;node, <a class="el" href="classfz_1_1Edit__flags.html">Edit_flags</a> &amp;editflags, time_t seconds_applied)</td></tr>
<tr class="memdesc:a51db678bb5c84838eae7c598afeb2ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">For non-repeating Nodes, this corrects the specified required time to reflect the actual time taken to complete the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>, while also setting the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> completed.  <a href="namespacefz.html#a51db678bb5c84838eae7c598afeb2ecb">More...</a><br /></td></tr>
<tr class="separator:a51db678bb5c84838eae7c598afeb2ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33c35dfbdc3f1d405cc4f6d9b54290d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab33c35dfbdc3f1d405cc4f6d9b54290d">Node_completion_update_within_required</a> (<a class="el" href="classfz_1_1Node.html">Node</a> &amp;node, <a class="el" href="classfz_1_1Edit__flags.html">Edit_flags</a> &amp;editflags, float seconds_applied, float seconds_required)</td></tr>
<tr class="memdesc:ab33c35dfbdc3f1d405cc4f6d9b54290d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> completion ratio between 0.0 and 1.0.  <a href="namespacefz.html#ab33c35dfbdc3f1d405cc4f6d9b54290d">More...</a><br /></td></tr>
<tr class="separator:ab33c35dfbdc3f1d405cc4f6d9b54290d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7549e0f879bb89ae170db487ced95cd9"><td class="memItemLeft" align="right" valign="top"><a id="a7549e0f879bb89ae170db487ced95cd9"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_enum_td_property</b> (&quot;('unspecified','inherit','variable','fixed','exact')&quot;)</td></tr>
<tr class="separator:a7549e0f879bb89ae170db487ced95cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8eb5b2d3cc88e7c31c21f894fb41795"><td class="memItemLeft" align="right" valign="top"><a id="ab8eb5b2d3cc88e7c31c21f894fb41795"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_enum_td_pattern</b> (&quot;('patt_daily','patt_workdays','patt_weekly','patt_biweekly','patt_monthly','patt_endofmonthoffset','patt_yearly','OLD_patt_span','patt_nonperiodic')&quot;)</td></tr>
<tr class="separator:ab8eb5b2d3cc88e7c31c21f894fb41795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e2e0c10e0a99c02075317aeeb6c1c5"><td class="memItemLeft" align="right" valign="top"><a id="a27e2e0c10e0a99c02075317aeeb6c1c5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_nodelayout</b> (&quot;id char(16) PRIMARY KEY,&quot; &quot;topics smallint[],&quot; &quot;topicrelevance real[],&quot; &quot;valuation real,&quot; &quot;completion real,&quot; &quot;required integer,&quot; &quot;text text,&quot; &quot;targetdate timestamp (0),&quot; &quot;tdproperty <a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">td_property</a>,&quot; &quot;isperiodic boolean,&quot; &quot;tdperiodic td_pattern,&quot; &quot;tdevery integer,&quot; &quot;tdspan integer&quot;)</td></tr>
<tr class="separator:a27e2e0c10e0a99c02075317aeeb6c1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73614ef8b5bc9f7003d3bac5de7813bf"><td class="memItemLeft" align="right" valign="top"><a id="a73614ef8b5bc9f7003d3bac5de7813bf"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_edgelayout</b> (&quot;id char(33),&quot; &quot;dependency real,&quot; &quot;significance real,&quot; &quot;importance real,&quot; &quot;urgency real,&quot; &quot;priority real&quot;)</td></tr>
<tr class="separator:a73614ef8b5bc9f7003d3bac5de7813bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95d4dae6638078251973dce703bc6da"><td class="memItemLeft" align="right" valign="top"><a id="ac95d4dae6638078251973dce703bc6da"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_topiclayout</b> (&quot;id smallint,&quot; &quot;supid smallint,&quot; &quot;tag text,&quot; &quot;title text,&quot; &quot;keyword text[],&quot; &quot;relevance real[]&quot;)</td></tr>
<tr class="separator:ac95d4dae6638078251973dce703bc6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99302d2f14ee4f41fbe2a9e2eed2c2c0"><td class="memItemLeft" align="right" valign="top"><a id="a99302d2f14ee4f41fbe2a9e2eed2c2c0"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_NNLlayout</b> (&quot;name char(81) PRIMARY KEY,&quot; &quot;features smallint,&quot; &quot;maxsize integer,&quot; &quot;nodeids char(16)[]&quot;)</td></tr>
<tr class="separator:a99302d2f14ee4f41fbe2a9e2eed2c2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab205a2fcc8d2839e75a2a426c201bfca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab205a2fcc8d2839e75a2a426c201bfca">handle_one_modification_pq</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph, PGconn *conn, const std::string &amp;schemaname, NNLmod_update_set &amp;nnlupdates, const <a class="el" href="structfz_1_1Graphmod__result.html">Graphmod_result</a> &amp;change_data)</td></tr>
<tr class="memdesc:ab205a2fcc8d2839e75a2a426c201bfca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the type of modification that was carried out in one <a class="el" href="structfz_1_1Graphmod__result.html" title="This is the data structure used by the server to return information about the successful results of a...">Graphmod_result</a> object.  <a href="namespacefz.html#ab205a2fcc8d2839e75a2a426c201bfca">More...</a><br /></td></tr>
<tr class="separator:ab205a2fcc8d2839e75a2a426c201bfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe38748c6da4110ea71ee010642d3606"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#afe38748c6da4110ea71ee010642d3606">get_Topic_pq_field_numbers</a> (PGresult *res)</td></tr>
<tr class="memdesc:afe38748c6da4110ea71ee010642d3606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve field column numbers for topics query to make sure the correct field numbers are used.  <a href="namespacefz.html#afe38748c6da4110ea71ee010642d3606">More...</a><br /></td></tr>
<tr class="separator:afe38748c6da4110ea71ee010642d3606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c85e3e526a0195ae67354ec8da0961"><td class="memItemLeft" align="right" valign="top"><a id="a66c85e3e526a0195ae67354ec8da0961"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_Node_pq_field_numbers</b> (PGresult *res)</td></tr>
<tr class="separator:a66c85e3e526a0195ae67354ec8da0961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d83157fc9e0622a67f569ec7b4e821"><td class="memItemLeft" align="right" valign="top"><a id="af8d83157fc9e0622a67f569ec7b4e821"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_Edge_pq_field_numbers</b> (PGresult *res)</td></tr>
<tr class="separator:af8d83157fc9e0622a67f569ec7b4e821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2debd26aeea489a11f6f3efb25b28572"><td class="memItemLeft" align="right" valign="top">Topic_KeyRel_Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a2debd26aeea489a11f6f3efb25b28572">keyrel_from_pq</a> (std::string keywordstr, std::string relevancestr)</td></tr>
<tr class="memdesc:a2debd26aeea489a11f6f3efb25b28572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert textual arrays of keywords and keyword-relevance values to a vector of <a class="el" href="structfz_1_1Topic__Keyword.html">Topic_Keyword</a> pairs.  <a href="namespacefz.html#a2debd26aeea489a11f6f3efb25b28572">More...</a><br /></td></tr>
<tr class="separator:a2debd26aeea489a11f6f3efb25b28572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2218c0801453155ac1531a857fd4e6"><td class="memItemLeft" align="right" valign="top"><a id="a0f2218c0801453155ac1531a857fd4e6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>read_Topics_pq</b> (PGconn *conn, std::string schemaname, <a class="el" href="classfz_1_1Topic__Tags.html">Topic_Tags</a> &amp;topictags)</td></tr>
<tr class="separator:a0f2218c0801453155ac1531a857fd4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de97e67d19ad7d3d8bd98bd13f2cb27"><td class="memItemLeft" align="right" valign="top"><a id="a9de97e67d19ad7d3d8bd98bd13f2cb27"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>node_topics_from_pq</b> (<a class="el" href="classfz_1_1Node.html">Node</a> &amp;node, std::string topicsstr, std::string topicrelevancestr)</td></tr>
<tr class="separator:a9de97e67d19ad7d3d8bd98bd13f2cb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658f2d4bdcf3d5fced3a350eed24d1a3"><td class="memItemLeft" align="right" valign="top"><a id="a658f2d4bdcf3d5fced3a350eed24d1a3"></a>
<a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">td_property</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tdproperty_from_pq</b> (std::string pqtdproperty)</td></tr>
<tr class="separator:a658f2d4bdcf3d5fced3a350eed24d1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47cf2abbaba0b2f748c0d170a543c5c"><td class="memItemLeft" align="right" valign="top"><a id="aa47cf2abbaba0b2f748c0d170a543c5c"></a>
td_pattern&#160;</td><td class="memItemRight" valign="bottom"><b>tdpattern_from_pq</b> (std::string pqtdpattern)</td></tr>
<tr class="separator:aa47cf2abbaba0b2f748c0d170a543c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a879fdf29f58852f12083396988690"><td class="memItemLeft" align="right" valign="top"><a id="af4a879fdf29f58852f12083396988690"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>read_Nodes_pq</b> (PGconn *conn, std::string schemaname, <a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="separator:af4a879fdf29f58852f12083396988690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80adfe467cc24306945531b24fc2d766"><td class="memItemLeft" align="right" valign="top"><a id="a80adfe467cc24306945531b24fc2d766"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>read_Edges_pq</b> (PGconn *conn, std::string schemaname, <a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="separator:a80adfe467cc24306945531b24fc2d766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cca301ebe00d24e81905c3402059ba1"><td class="memItemLeft" align="right" valign="top"><a id="a9cca301ebe00d24e81905c3402059ba1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_NNL_pq_field_numbers</b> (PGresult *res)</td></tr>
<tr class="separator:a9cca301ebe00d24e81905c3402059ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1668a3b60e6b48e973fd195aff3e3de9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfz_1_1Topic.html">Topic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a1668a3b60e6b48e973fd195aff3e3de9">main_topic</a> (const <a class="el" href="classfz_1_1Topic__Tags.html">Topic_Tags</a> &amp;topictags, const <a class="el" href="classfz_1_1Node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:a1668a3b60e6b48e973fd195aff3e3de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the main <a class="el" href="classfz_1_1Topic.html">Topic</a> of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>, as indicated by the maximum Topic_Relevance value.  <a href="namespacefz.html#a1668a3b60e6b48e973fd195aff3e3de9">More...</a><br /></td></tr>
<tr class="separator:a1668a3b60e6b48e973fd195aff3e3de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa142fcdccbb8510c806f415ef6559e93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfz_1_1Topic.html">Topic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aa142fcdccbb8510c806f415ef6559e93">main_topic</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;_graph, <a class="el" href="classfz_1_1Node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:aa142fcdccbb8510c806f415ef6559e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the main <a class="el" href="classfz_1_1Topic.html">Topic</a> of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>, as indicated by the maximum Topic_Relevance value.  <a href="namespacefz.html#aa142fcdccbb8510c806f415ef6559e93">More...</a><br /></td></tr>
<tr class="separator:aa142fcdccbb8510c806f415ef6559e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b2eb1f97a5184525295ddd841db00b"><td class="memItemLeft" align="right" valign="top"><a id="ae3b2eb1f97a5184525295ddd841db00b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>all_numbers</b> (const std::string &amp;s, size_t from, size_t before)</td></tr>
<tr class="separator:ae3b2eb1f97a5184525295ddd841db00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca8aeb60ace2b85c9010f9576cfc316"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a9ca8aeb60ace2b85c9010f9576cfc316">convert_special_data_word_html</a> (const std::string &amp;wstr, size_t from, size_t bef)</td></tr>
<tr class="memdesc:a9ca8aeb60ace2b85c9010f9576cfc316"><td class="mdescLeft">&#160;</td><td class="mdescRight">This analyzes a token to identify special data, which is converted by adding a useful link.  <a href="namespacefz.html#a9ca8aeb60ace2b85c9010f9576cfc316">More...</a><br /></td></tr>
<tr class="separator:a9ca8aeb60ace2b85c9010f9576cfc316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbbb262820388617f57a0881e141c6e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#afbbbb262820388617f57a0881e141c6e">convert_special_data_html</a> (const std::string &amp;htmlstr, size_t frompos, size_t beforepos, bool remove_extra_space=false, const std::string &amp;token_sep=&quot; \t\n\r\f\v&quot;)</td></tr>
<tr class="memdesc:afbbbb262820388617f57a0881e141c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This tokenizes, i.e.  <a href="namespacefz.html#afbbbb262820388617f57a0881e141c6e">More...</a><br /></td></tr>
<tr class="separator:afbbbb262820388617f57a0881e141c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1caa4e337bfa2b43ba2afd91237acef2"><td class="memItemLeft" align="right" valign="top"><a id="a1caa4e337bfa2b43ba2afd91237acef2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>found_end_of_closing_href_tag</b> (size_t pos, const std::string &amp;htmlstr, size_t &amp;pos_after_href_closing)</td></tr>
<tr class="separator:a1caa4e337bfa2b43ba2afd91237acef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad129ac575bb7a02584b8aece761757fb"><td class="memItemLeft" align="right" valign="top"><a id="ad129ac575bb7a02584b8aece761757fb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>hexchar</b> (unsigned char c, unsigned char &amp;hex1, unsigned char &amp;hex2)</td></tr>
<tr class="separator:ad129ac575bb7a02584b8aece761757fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3be8dc4c8df2ffff30795e117a2a007"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#af3be8dc4c8df2ffff30795e117a2a007">json_post_process_valuestring</a> (const std::string &amp;rawstr)</td></tr>
<tr class="memdesc:af3be8dc4c8df2ffff30795e117a2a007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post-process the raw value string extracted from a JSON structure.  <a href="namespacefz.html#af3be8dc4c8df2ffff30795e117a2a007">More...</a><br /></td></tr>
<tr class="separator:af3be8dc4c8df2ffff30795e117a2a007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d2b0e332e8c8cb2da50ef8a3fd395f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ac5d2b0e332e8c8cb2da50ef8a3fd395f">pq_LBlayout</a> (&quot;id timestamp (0) PRIMARY KEY&quot;)</td></tr>
<tr class="memdesc:ac5d2b0e332e8c8cb2da50ef8a3fd395f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notes about the Postgres <a class="el" href="classfz_1_1Log.html">Log</a> layout:  <a href="namespacefz.html#ac5d2b0e332e8c8cb2da50ef8a3fd395f">More...</a><br /></td></tr>
<tr class="separator:ac5d2b0e332e8c8cb2da50ef8a3fd395f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5c069b6383bc4a981651bd9a25f2c5"><td class="memItemLeft" align="right" valign="top"><a id="a7a5c069b6383bc4a981651bd9a25f2c5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_LClayout</b> (&quot;id timestamp (0) PRIMARY KEY,&quot; &quot;nid char(16),&quot; &quot;tclose timestamp (0)&quot;)</td></tr>
<tr class="separator:a7a5c069b6383bc4a981651bd9a25f2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040c6fbb221224626b2495d36555ba20"><td class="memItemLeft" align="right" valign="top"><a id="a040c6fbb221224626b2495d36555ba20"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_LElayout</b> (&quot;id char(16),&quot; &quot;nid char(16),&quot; &quot;text text&quot;)</td></tr>
<tr class="separator:a040c6fbb221224626b2495d36555ba20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163df4ed695f0e00f7d1ff4c0efbf966"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a163df4ed695f0e00f7d1ff4c0efbf966">read_Breakpoints_pq</a> (<a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq, <a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:a163df4ed695f0e00f7d1ff4c0efbf966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load full Breakpoints table into Log::breakpoints.  <a href="namespacefz.html#a163df4ed695f0e00f7d1ff4c0efbf966">More...</a><br /></td></tr>
<tr class="separator:a163df4ed695f0e00f7d1ff4c0efbf966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c13e8ff9e09d7fa7218c9b024eee6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#af0c13e8ff9e09d7fa7218c9b024eee6e">get_Chunk_pq_field_numbers</a> (PGresult *res)</td></tr>
<tr class="memdesc:af0c13e8ff9e09d7fa7218c9b024eee6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve field column numbers for chunks query to make sure the correct field numbers are used.  <a href="namespacefz.html#af0c13e8ff9e09d7fa7218c9b024eee6e">More...</a><br /></td></tr>
<tr class="separator:af0c13e8ff9e09d7fa7218c9b024eee6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d216093fa5bf63db9826208d535ba7d"><td class="memItemLeft" align="right" valign="top"><a id="a8d216093fa5bf63db9826208d535ba7d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_Entry_pq_field_numbers</b> (PGresult *res)</td></tr>
<tr class="separator:a8d216093fa5bf63db9826208d535ba7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099b3ef08695bb2eb63a19ddffb39c8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a099b3ef08695bb2eb63a19ddffb39c8b">read_Chunks_pq</a> (<a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq, <a class="el" href="classfz_1_1Log.html">Log</a> &amp;log, std::string wherestr=&quot;&quot;, std::string limitdirstr=&quot;&quot;)</td></tr>
<tr class="memdesc:a099b3ef08695bb2eb63a19ddffb39c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load full Chunks table into Log::chunks.  <a href="namespacefz.html#a099b3ef08695bb2eb63a19ddffb39c8b">More...</a><br /></td></tr>
<tr class="separator:a099b3ef08695bb2eb63a19ddffb39c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33a508dd163fea401543abc5f20a8a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae33a508dd163fea401543abc5f20a8a2">read_Entries_pq</a> (<a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq, <a class="el" href="classfz_1_1Log.html">Log</a> &amp;log, std::string wherestr=&quot;&quot;)</td></tr>
<tr class="memdesc:ae33a508dd163fea401543abc5f20a8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load full Entries table into Log::entries.  <a href="namespacefz.html#ae33a508dd163fea401543abc5f20a8a2">More...</a><br /></td></tr>
<tr class="separator:ae33a508dd163fea401543abc5f20a8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0924e10402414b80f16c8ca32a95e4ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a0924e10402414b80f16c8ca32a95e4ad">read_Entries_first_pass_pq</a> (<a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq, <a class="el" href="classfz_1_1Log.html">Log</a> &amp;log, std::string wherestr=&quot;&quot;)</td></tr>
<tr class="memdesc:a0924e10402414b80f16c8ca32a95e4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">First-Pass Load of Entries into Log::entries.  <a href="namespacefz.html#a0924e10402414b80f16c8ca32a95e4ad">More...</a><br /></td></tr>
<tr class="separator:a0924e10402414b80f16c8ca32a95e4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c6fa427c22259b7632366d7d009d46"><td class="memItemLeft" align="right" valign="top"><a id="a07c6fa427c22259b7632366d7d009d46"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_History_pq_field_numbers</b> (PGresult *res)</td></tr>
<tr class="separator:a07c6fa427c22259b7632366d7d009d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44746243b35649cc63d0d6b478695a2e"><td class="memItemLeft" align="right" valign="top"><a id="a44746243b35649cc63d0d6b478695a2e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>replace_double_quotes</b> (std::string &amp;s)</td></tr>
<tr class="separator:a44746243b35649cc63d0d6b478695a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26517e2044ebeab12a0870dd60f5c2fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a26517e2044ebeab12a0870dd60f5c2fc">convert_array_output_to_input_pq</a> (std::string &amp;entryids_str)</td></tr>
<tr class="memdesc:a26517e2044ebeab12a0870dd60f5c2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unfortunately, Postgres output strings with array data cannot simply be used unmodified as array input data.  <a href="namespacefz.html#a26517e2044ebeab12a0870dd60f5c2fc">More...</a><br /></td></tr>
<tr class="separator:a26517e2044ebeab12a0870dd60f5c2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91705abf58235063050e071bc20586c"><td class="memItemLeft" align="right" valign="top"><a id="ab91705abf58235063050e071bc20586c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parse_PQValues_to_Node_history</b> (PGresult *res, int r, <a class="el" href="structfz_1_1Node__history.html">Node_history</a> &amp;nodehist, std::string &amp;nodeid_str)</td></tr>
<tr class="separator:ab91705abf58235063050e071bc20586c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a495d238d3b9443ea475cecdfb126d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab1a495d238d3b9443ea475cecdfb126d">load_Node_history_pq</a> (<a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;apq, <a class="el" href="classfz_1_1Log.html">Log</a> &amp;log, const <a class="el" href="structfz_1_1Log__filter.html">Log_filter</a> &amp;filter, std::string &amp;chunkwherestr, std::string &amp;entrywherestr)</td></tr>
<tr class="memdesc:ab1a495d238d3b9443ea475cecdfb126d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get lists of <a class="el" href="classfz_1_1Log.html">Log</a> chunks and <a class="el" href="classfz_1_1Log.html">Log</a> entries from the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> history cache table and load all of the chunks and entries listed there into a <a class="el" href="classfz_1_1Log.html">Log</a> object.  <a href="namespacefz.html#ab1a495d238d3b9443ea475cecdfb126d">More...</a><br /></td></tr>
<tr class="separator:ab1a495d238d3b9443ea475cecdfb126d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc70e10f68c650a94ac774d642f7f85"><td class="memItemLeft" align="right" valign="top"><a id="a9fc70e10f68c650a94ac774d642f7f85"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>chunk_key_list_pq</b> (const Log_chunk_ID_key_set &amp;chunks)</td></tr>
<tr class="separator:a9fc70e10f68c650a94ac774d642f7f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a57ace339ac0d550b72e670755881b1"><td class="memItemLeft" align="right" valign="top"><a id="a5a57ace339ac0d550b72e670755881b1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>entry_key_list_pq</b> (const Log_entry_ID_key_set &amp;entries)</td></tr>
<tr class="separator:a5a57ace339ac0d550b72e670755881b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2022e10fe1d991308d72fcec1a286b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfz_1_1Topic.html">Topic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae2022e10fe1d991308d72fcec1a286b3">main_topic</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;_graph, <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &amp;chunk)</td></tr>
<tr class="memdesc:ae2022e10fe1d991308d72fcec1a286b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the main <a class="el" href="classfz_1_1Topic.html">Topic</a> of a <a class="el" href="classfz_1_1Log.html">Log</a> chunk's <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>, as indicated by the maximum Topic_Relevance value.  <a href="namespacefz.html#ae2022e10fe1d991308d72fcec1a286b3">More...</a><br /></td></tr>
<tr class="separator:ae2022e10fe1d991308d72fcec1a286b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3abb29c608556e6534dbb67c4878f16"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Log_chunks_Map::iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ad3abb29c608556e6534dbb67c4878f16">Breakpoint_Indices</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:ad3abb29c608556e6534dbb67c4878f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">This converts the list of <a class="el" href="classfz_1_1Log.html">Log</a> breakpoint <a class="el" href="classfz_1_1Log.html">Log</a> chunk IDs into a list of indices into the list of <a class="el" href="classfz_1_1Log.html">Log</a> chunks (in Log::chunks).  <a href="namespacefz.html#ad3abb29c608556e6534dbb67c4878f16">More...</a><br /></td></tr>
<tr class="separator:ad3abb29c608556e6534dbb67c4878f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99de56e900ef8f39ac539d88521905ab"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a99de56e900ef8f39ac539d88521905ab">Log_span_in_seconds</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:a99de56e900ef8f39ac539d88521905ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the span in seconds from when the <a class="el" href="classfz_1_1Log.html">Log</a> was started (first cunk) to its most recent chunk.  <a href="namespacefz.html#a99de56e900ef8f39ac539d88521905ab">More...</a><br /></td></tr>
<tr class="separator:a99de56e900ef8f39ac539d88521905ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99ee1f9eb33cd43975a1e2ba185affc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab99ee1f9eb33cd43975a1e2ba185affc">Log_span_in_days</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:ab99ee1f9eb33cd43975a1e2ba185affc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the span in days from when the <a class="el" href="classfz_1_1Log.html">Log</a> was started (first cunk) to its most recent chunk.  <a href="namespacefz.html#ab99ee1f9eb33cd43975a1e2ba185affc">More...</a><br /></td></tr>
<tr class="separator:ab99ee1f9eb33cd43975a1e2ba185affc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac852c19de9635df74fca9eab2d419e5b"><td class="memItemLeft" align="right" valign="top">ymd_tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ac852c19de9635df74fca9eab2d419e5b">Log_span_years_months_days</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:ac852c19de9635df74fca9eab2d419e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the span in years, months and days from when the <a class="el" href="classfz_1_1Log.html">Log</a> was started (first cunk) to its most recent chunk.  <a href="namespacefz.html#ac852c19de9635df74fca9eab2d419e5b">More...</a><br /></td></tr>
<tr class="separator:ac852c19de9635df74fca9eab2d419e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab884385219138cc37ab39ee30c8da295"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ab884385219138cc37ab39ee30c8da295">Chunks_per_Breakpoint</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:ab884385219138cc37ab39ee30c8da295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the frequency distribution for the number of <a class="el" href="classfz_1_1Log.html">Log</a> chunks per <a class="el" href="classfz_1_1Log.html">Log</a> breakpoint.  <a href="namespacefz.html#ab884385219138cc37ab39ee30c8da295">More...</a><br /></td></tr>
<tr class="separator:ab884385219138cc37ab39ee30c8da295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0d1276ea12c9ed4a27ba5cb0296d14"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a4f0d1276ea12c9ed4a27ba5cb0296d14">Chunks_total_minutes</a> (<a class="el" href="structfz_1_1Log__chunks__Map.html">Log_chunks_Map</a> &amp;chunks)</td></tr>
<tr class="memdesc:a4f0d1276ea12c9ed4a27ba5cb0296d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the total number of minutes logged for all <a class="el" href="classfz_1_1Log.html">Log</a> chunks in the specified deque.  <a href="namespacefz.html#a4f0d1276ea12c9ed4a27ba5cb0296d14">More...</a><br /></td></tr>
<tr class="separator:a4f0d1276ea12c9ed4a27ba5cb0296d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c5acaefdebe1051c4ff921bc754e68"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a31c5acaefdebe1051c4ff921bc754e68">TimeStamp</a> (const char *dateformat, time_t t)</td></tr>
<tr class="memdesc:a31c5acaefdebe1051c4ff921bc754e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate time stamp.  <a href="namespacefz.html#a31c5acaefdebe1051c4ff921bc754e68">More...</a><br /></td></tr>
<tr class="separator:a31c5acaefdebe1051c4ff921bc754e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70525212cc7a8fff346a1540c8c8f8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfz_1_1Topic.html">Topic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#af70525212cc7a8fff346a1540c8c8f8a">main_topic</a> (<a class="el" href="classfz_1_1Topic__Tags.html">Topic_Tags</a> &amp;topictags, <a class="el" href="classfz_1_1Node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:af70525212cc7a8fff346a1540c8c8f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the main <a class="el" href="classfz_1_1Topic.html">Topic</a> of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>, as indicated by the maximum Topic_Relevance value.  <a href="namespacefz.html#af70525212cc7a8fff346a1540c8c8f8a">More...</a><br /></td></tr>
<tr class="separator:af70525212cc7a8fff346a1540c8c8f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a932c08376dcd6e99d985bcd032aa8187"><td class="memItemLeft" align="right" valign="top"><a id="a932c08376dcd6e99d985bcd032aa8187"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mute_error</b> = false</td></tr>
<tr class="separator:a932c08376dcd6e99d985bcd032aa8187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57b0efbfc91e9c65004b3d40dd3ff71"><td class="memItemLeft" align="right" valign="top"><a id="ae57b0efbfc91e9c65004b3d40dd3ff71"></a>
<a class="el" href="structfz_1_1Stack__Tracer.html">Stack_Tracer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ae57b0efbfc91e9c65004b3d40dd3ff71">errtracer</a></td></tr>
<tr class="memdesc:ae57b0efbfc91e9c65004b3d40dd3ff71"><td class="mdescLeft">&#160;</td><td class="mdescRight">The global stack tracer variable. <br /></td></tr>
<tr class="separator:ae57b0efbfc91e9c65004b3d40dd3ff71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6eca7b9586ecff715a8ad5bd26efb3e"><td class="memItemLeft" align="right" valign="top"><a id="ab6eca7b9586ecff715a8ad5bd26efb3e"></a>
<a class="el" href="classfz_1_1Errors.html">Errors</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ErrQ</b></td></tr>
<tr class="separator:ab6eca7b9586ecff715a8ad5bd26efb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcb97eafaecf389dd6dd7a9cbde00ed"><td class="memItemLeft" align="right" valign="top"><a id="aafcb97eafaecf389dd6dd7a9cbde00ed"></a>
<a class="el" href="classfz_1_1Errors.html">Errors</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WarnQ</b></td></tr>
<tr class="separator:aafcb97eafaecf389dd6dd7a9cbde00ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc03bdd20fad96262b1e13b2bb897780"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_commands_str</b> [_pqcommand_NUM]</td></tr>
<tr class="separator:acc03bdd20fad96262b1e13b2bb897780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba84cce5b733cf4ca721bd800103b1c4"><td class="memItemLeft" align="right" valign="top"><a id="aba84cce5b733cf4ca721bd800103b1c4"></a>
<a class="el" href="classfz_1_1Simulate__PQ__Changes.html">Simulate_PQ_Changes</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SimPQ</b></td></tr>
<tr class="separator:aba84cce5b733cf4ca721bd800103b1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5946fa5b803240f1c0cd734f214c8c15"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>td_property_str</b> [_tdprop_num]</td></tr>
<tr class="separator:a5946fa5b803240f1c0cd734f214c8c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdf6ef39f17c7f41bec3c89e472b0c7"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">td_property</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>td_property_map</b></td></tr>
<tr class="separator:a6bdf6ef39f17c7f41bec3c89e472b0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64dd91504fdcea08cc7617a5314ec6d2"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>td_pattern_str</b> [_patt_num]</td></tr>
<tr class="separator:a64dd91504fdcea08cc7617a5314ec6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b29454d06889dc887c6a36ca1c8f83b"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, td_pattern &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>td_pattern_map</b></td></tr>
<tr class="separator:a4b29454d06889dc887c6a36ca1c8f83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c09898831c45c42a4875335c5c5ec21"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, Edit_flags_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>flagbylabel</b></td></tr>
<tr class="separator:a5c09898831c45c42a4875335c5c5ec21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1f933c98077a8f99e1d371b33ac65b"><td class="memItemLeft" align="right" valign="top">const std::map&lt; Graph_modification_request, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Graph_modification_request_str</b></td></tr>
<tr class="separator:aae1f933c98077a8f99e1d371b33ac65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b2654accac9e8891359985237e495e"><td class="memItemLeft" align="right" valign="top"><a id="a08b2654accac9e8891359985237e495e"></a>
<a class="el" href="classfz_1_1graph__mem__managers.html">graph_mem_managers</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a08b2654accac9e8891359985237e495e">graphmemman</a></td></tr>
<tr class="memdesc:a08b2654accac9e8891359985237e495e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global access to shared memory managers for <a class="el" href="classfz_1_1Graph.html">Graph</a> data structures. <br /></td></tr>
<tr class="separator:a08b2654accac9e8891359985237e495e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd4b0fb0c54c1b32ee6a18e72bfccf1"><td class="memItemLeft" align="right" valign="top"><a id="a5bd4b0fb0c54c1b32ee6a18e72bfccf1"></a>
<a class="el" href="structfz_1_1formalizer__base__streams.html">formalizer_base_streams</a>&#160;</td><td class="memItemRight" valign="bottom"><b>base</b></td></tr>
<tr class="separator:a5bd4b0fb0c54c1b32ee6a18e72bfccf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812e6aee98e3ba6635c8fc4bed8ad57c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfz_1_1the__standard__object.html">the_standard_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#a812e6aee98e3ba6635c8fc4bed8ad57c">standard</a></td></tr>
<tr class="memdesc:a812e6aee98e3ba6635c8fc4bed8ad57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This object projects one unique and clear interface with settings for standardized Formalizer programs, including exit hooks and other important requirements.  <a href="namespacefz.html#a812e6aee98e3ba6635c8fc4bed8ad57c">More...</a><br /></td></tr>
<tr class="separator:a812e6aee98e3ba6635c8fc4bed8ad57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c6b78f22faaba74483392e9188a336"><td class="memItemLeft" align="right" valign="top">const std::map&lt; http_response_code, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>http_response_code_map</b></td></tr>
<tr class="separator:ab7c6b78f22faaba74483392e9188a336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d8c691662e60b7f7a041e6d67ff4ac"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>weekday_str</b> [day_of_week::_num_dow]</td></tr>
<tr class="separator:a05d8c691662e60b7f7a041e6d67ff4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0448bb7f1a2a03d28a3e64ad9cb22a61"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, Edit_flags_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tdpropbylabel</b></td></tr>
<tr class="separator:a0448bb7f1a2a03d28a3e64ad9cb22a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc52933ef4168620f90311de4df2a78"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_topic_fieldnames</b> [_pqt_NUM]</td></tr>
<tr class="separator:a6fc52933ef4168620f90311de4df2a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae700e2bafc4331d3347a1962a14d7b65"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_node_fieldnames</b> [_pqn_NUM]</td></tr>
<tr class="separator:ae700e2bafc4331d3347a1962a14d7b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58eb1389cf1205452a7dfd69e988dcb6"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_edge_fieldnames</b> [_pqe_NUM]</td></tr>
<tr class="separator:a58eb1389cf1205452a7dfd69e988dcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5133964c1ea32f8104d9f5b750bd56"><td class="memItemLeft" align="right" valign="top"><a id="adc5133964c1ea32f8104d9f5b750bd56"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>pq_topic_field</b> [_pqt_NUM]</td></tr>
<tr class="separator:adc5133964c1ea32f8104d9f5b750bd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba2fa538b482567b16dd5a7ef50fcc1"><td class="memItemLeft" align="right" valign="top"><a id="abba2fa538b482567b16dd5a7ef50fcc1"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>pq_node_field</b> [_pqn_NUM]</td></tr>
<tr class="separator:abba2fa538b482567b16dd5a7ef50fcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07927c6740fdad3a437a306546ffeb81"><td class="memItemLeft" align="right" valign="top"><a id="a07927c6740fdad3a437a306546ffeb81"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>pq_edge_field</b> [_pqe_NUM]</td></tr>
<tr class="separator:a07927c6740fdad3a437a306546ffeb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721c8cc078a6b39b2603c86680c0b573"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">td_property</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tdprop_by_pqtdprop</b></td></tr>
<tr class="separator:a721c8cc078a6b39b2603c86680c0b573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c65c6c42a33bdb3871ee3ce28ca0db"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, td_pattern &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tdpatt_by_pqtdpatt</b></td></tr>
<tr class="separator:ad7c65c6c42a33bdb3871ee3ce28ca0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a3b61cbcee151ad5409ad5e01466cd"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_NNL_fieldnames</b> [_pqNNL_NUM]</td></tr>
<tr class="separator:ad0a3b61cbcee151ad5409ad5e01466cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0adaba1f184616b5de6b289b901a79e"><td class="memItemLeft" align="right" valign="top"><a id="ad0adaba1f184616b5de6b289b901a79e"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>pq_NNL_field</b> [_pqNNL_NUM]</td></tr>
<tr class="separator:ad0adaba1f184616b5de6b289b901a79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e63f3d2130ee19138dccdf85336b8c"><td class="memItemLeft" align="right" valign="top">const std::map&lt; const char *, Boolean_Tag_Flags::boolean_flag, <a class="el" href="structfz_1_1cmp__cstr.html">cmp_cstr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>boolean_flag_map</b></td></tr>
<tr class="separator:a67e63f3d2130ee19138dccdf85336b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d42a3a9cb94c374b5cfe167196db73"><td class="memItemLeft" align="right" valign="top">const std::map&lt; Boolean_Tag_Flags::boolean_flag, const std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>boolean_flag_str_map</b></td></tr>
<tr class="separator:a22d42a3a9cb94c374b5cfe167196db73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace795313bd567e5ab648f4ab92598bba"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, text_interpretation &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>text_interpretation_flags_map</b></td></tr>
<tr class="separator:ace795313bd567e5ab648f4ab92598bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04ef6e0f35fe1bf076661e5cdddc084"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#ac04ef6e0f35fe1bf076661e5cdddc084">html_special_codes</a></td></tr>
<tr class="memdesc:ac04ef6e0f35fe1bf076661e5cdddc084"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is only a partial list.  <a href="namespacefz.html#ac04ef6e0f35fe1bf076661e5cdddc084">More...</a><br /></td></tr>
<tr class="separator:ac04ef6e0f35fe1bf076661e5cdddc084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15799708deb829c9e79b07585c3d887f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>href_match_vec</b></td></tr>
<tr class="separator:a15799708deb829c9e79b07585c3d887f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a9d7f3f75c181024b7eb9154486b0d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><b>copyhtmljs_template_A</b></td></tr>
<tr class="separator:a75a9d7f3f75c181024b7eb9154486b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac69e178c4df23d74f96359d2befa23"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><b>copyhtmljs_template_B</b></td></tr>
<tr class="separator:a9ac69e178c4df23d74f96359d2befa23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729990e405965c2ca1f9477eb7441936"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><b>copyvaluejs_template_A</b></td></tr>
<tr class="separator:a729990e405965c2ca1f9477eb7441936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8851b96747b0e8a3f65052c5fd0a599"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><b>copyvaluejs_template_B</b></td></tr>
<tr class="separator:aa8851b96747b0e8a3f65052c5fd0a599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891acb04fd8751af330b359683bf1f32"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_chunk_fieldnames</b> [_pqlc_NUM]</td></tr>
<tr class="separator:a891acb04fd8751af330b359683bf1f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e1faf355d3b06d2b95e06e207f1cb7"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_entry_fieldnames</b> [_pqle_NUM]</td></tr>
<tr class="separator:a75e1faf355d3b06d2b95e06e207f1cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c60bcc3ec5facb69675fa478256a5a"><td class="memItemLeft" align="right" valign="top"><a id="a88c60bcc3ec5facb69675fa478256a5a"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>pq_chunk_field</b> [_pqlc_NUM]</td></tr>
<tr class="separator:a88c60bcc3ec5facb69675fa478256a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5220e38267cfa691460e3665ae9aee1d"><td class="memItemLeft" align="right" valign="top"><a id="a5220e38267cfa691460e3665ae9aee1d"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>pq_entry_field</b> [_pqle_NUM]</td></tr>
<tr class="separator:a5220e38267cfa691460e3665ae9aee1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc3e17bc68db256eb5e791bd38a0224"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pq_history_fieldnames</b> [3]</td></tr>
<tr class="separator:a7fc3e17bc68db256eb5e791bd38a0224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8016bd002284cb01795f9e54b9771126"><td class="memItemLeft" align="right" valign="top"><a id="a8016bd002284cb01795f9e54b9771126"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>pq_history_field</b> [3]</td></tr>
<tr class="separator:a8016bd002284cb01795f9e54b9771126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab0d860bf18ea1cc2acb7577f4f294f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfz_1_1ReferenceTime.html">ReferenceTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#aeab0d860bf18ea1cc2acb7577f4f294f">maintime</a></td></tr>
<tr class="memdesc:aeab0d860bf18ea1cc2acb7577f4f294f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Every program that uses core Formalizer functions that depend on time stamping includes <a class="el" href="ReferenceTime_8hpp_source.html">ReferenceTime.hpp</a> (it is automatically included through <a class="el" href="TimeStamp_8hpp.html" title="This header file declares Formalizer TimeStamp format and operations.">TimeStamp.hpp</a>).  <a href="namespacefz.html#aeab0d860bf18ea1cc2acb7577f4f294f">More...</a><br /></td></tr>
<tr class="separator:aeab0d860bf18ea1cc2acb7577f4f294f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead4bec27bc9c408cb51da01c66f5010"><td class="memItemLeft" align="right" valign="top"><a id="aead4bec27bc9c408cb51da01c66f5010"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>standard_mute_cache_quiet</b> = false</td></tr>
<tr class="separator:aead4bec27bc9c408cb51da01c66f5010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88317527ed22c08d5af37ecbb4aedb45"><td class="memItemLeft" align="right" valign="top"><a id="a88317527ed22c08d5af37ecbb4aedb45"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>standard_mute_cache_veryverbose</b> = false</td></tr>
<tr class="separator:a88317527ed22c08d5af37ecbb4aedb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5a3897998ce3677a7b50a6e18e12f0"><td class="memItemLeft" align="right" valign="top"><a id="a3c5a3897998ce3677a7b50a6e18e12f0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>standard_mute_cache_mute_error</b> = false</td></tr>
<tr class="separator:a3c5a3897998ce3677a7b50a6e18e12f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fce015cc53230952afbdbc408efa260"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ext_mimetype</b></td></tr>
<tr class="separator:a3fce015cc53230952afbdbc408efa260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d66e38e251a8692684776b13aceacfe"><td class="memItemLeft" align="right" valign="top">constexpr const std::tm&#160;</td><td class="memItemRight" valign="bottom"><b>safe_max_localtime</b></td></tr>
<tr class="separator:a7d66e38e251a8692684776b13aceacfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576c20054fa81e82da8f2aeb7c6ff559"><td class="memItemLeft" align="right" valign="top">constexpr const std::tm&#160;</td><td class="memItemRight" valign="bottom"><b>safe_undefined_localtime</b></td></tr>
<tr class="separator:a576c20054fa81e82da8f2aeb7c6ff559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2e6fb9c1745757fd6019d8546038b5"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefz.html#abc2e6fb9c1745757fd6019d8546038b5">NODE_ID_STRSZ</a> = 16+1</td></tr>
<tr class="memdesc:abc2e6fb9c1745757fd6019d8546038b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reusable directly from Graphtypes:  <a href="namespacefz.html#abc2e6fb9c1745757fd6019d8546038b5">More...</a><br /></td></tr>
<tr class="separator:abc2e6fb9c1745757fd6019d8546038b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d7911385f100d7569a3cfb28a10ae6"><td class="memItemLeft" align="right" valign="top"><a id="ad6d7911385f100d7569a3cfb28a10ae6"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>EDGE_ID_STRSZ</b> = 16+1+16+1</td></tr>
<tr class="separator:ad6d7911385f100d7569a3cfb28a10ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea81244aed520480a5ee7b70775e18e"><td class="memItemLeft" align="right" valign="top"><a id="aaea81244aed520480a5ee7b70775e18e"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>TOPIC_KEYWORD_STRSZ</b> = 40+1</td></tr>
<tr class="separator:aaea81244aed520480a5ee7b70775e18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cacce2f62a38eb6b7ae99dbe1f712d"><td class="memItemLeft" align="right" valign="top"><a id="a34cacce2f62a38eb6b7ae99dbe1f712d"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>TOPIC_TAG_STRSZ</b> = 60+1</td></tr>
<tr class="separator:a34cacce2f62a38eb6b7ae99dbe1f712d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae6a4d28eb79c270b61ab5b636d8646"><td class="memItemLeft" align="right" valign="top"><a id="afae6a4d28eb79c270b61ab5b636d8646"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>TOPIC_TITLE_STRSZ</b> = 60+1</td></tr>
<tr class="separator:afae6a4d28eb79c270b61ab5b636d8646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752067f6df08348dbc7cf60f2f20fe94"><td class="memItemLeft" align="right" valign="top"><a id="a752067f6df08348dbc7cf60f2f20fe94"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>TOPIC_KEYREL_ARRSZ</b> = 16</td></tr>
<tr class="separator:a752067f6df08348dbc7cf60f2f20fe94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4acec9be9e7b87772b0134e343c6d29"><td class="memItemLeft" align="right" valign="top"><a id="aa4acec9be9e7b87772b0134e343c6d29"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>TOPIC_TAGS_ARRSZ</b> = 1000</td></tr>
<tr class="separator:aa4acec9be9e7b87772b0134e343c6d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>On Ubuntu, to install the libpq libraries, including the libpq-fe.h header file, do: sudo apt-get install libpq-dev You may also have to add /usr/include or /usr/include/postgresql to the CPATH or to the includes in the Makefile, e.g. </p>
<p>NOTE: This library component has been taken out of active maintenance to save on unnecessary compilation time, since it is not presently being used by any core or tools programs.</p>
<p>The utf8.cpp and <a class="el" href="utf8_8hpp.html" title="This header serves as a core utility wrapper for the open source cpputf library.">utf8.hpp</a> files are core utility wrappers for the open source cpputf library.</p>
<p>A simmple set of templating functions.</p>
<p>General collection of functions used for string I/O with files and streams.</p>
<p>General collection of functions for process detection and lock files.</p>
<p>General collection of functions for reading and writing a JSON subset format.</p>
<p>General collection of functions for working with HTML strings.</p>
<p>This source file was separated out of Graphtypes.cpp in order to produce a separate compiled .obj file for <a class="el" href="classfz_1_1Graph.html">Graph</a> comparison (friend) helper utility functions.</p>
<p>General collection of functions used in various Core and Tool programs.</p>
<p>General collection of functions used for binary I/O with files and streams.</p>
<p>-I/usr/include/postgresql.</p>
<p>Those functions will not be needed by every program that needs the <a class="el" href="classfz_1_1Graph.html">Graph</a> data type header.</p>
<p>In many cases, this can be a small fast replacement for a feature-rich templating library such as <code>inja</code>.</p>
<p>See details in <a class="el" href="utf8_8hpp.html" title="This header serves as a core utility wrapper for the open source cpputf library.">utf8.hpp</a>. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a619e9f686624f66e6323f7da1ae2a46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619e9f686624f66e6323f7da1ae2a46c">&#9670;&nbsp;</a></span>Boolean_Tag_Flags_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::uint32_t <a class="el" href="namespacefz.html#a619e9f686624f66e6323f7da1ae2a46c">fz::Boolean_Tag_Flags_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A bitmask of flags for the data components of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>. </p>
<p>Note A: This is not only used to specify modifications (see Graphmodify), but also to build filters (see Graphinfo). Note B: Graphmodify objects that are instantiated in shared memory inherit this, so this class needs to remain free of container class variables. </p>

</div>
</div>
<a id="abec42076c72022f11008c3bcf9636554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec42076c72022f11008c3bcf9636554">&#9670;&nbsp;</a></span>byte_vector_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;uint8_t&gt; <a class="el" href="namespacefz.html#abec42076c72022f11008c3bcf9636554">fz::byte_vector_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<h2>Comparing map types </h2>
<h2><code><a class="el" href="structEPS__map.html">EPS_map</a></code></h2>
<p>Originally developed for EPS group mapping in fzupdate, based on developments reaching back to the Formalizer 1.x code in <code>dil2al</code>.</p>
<p>The purpose is to map time in intervals called <code>slots</code>. The default size of a <code>slot</code> is 5 minutes. Each <code>slot</code> is mapped as a pair that associates a UNIX epoch time with a pointer to a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>.</p>
<p>If <code>time_t</code> is a <code>long</code> on a 64 bit system and pointers are also 64 bits then each slot theoretically consumes 16 bytes. Mapping a year composed of 364*24*60 = 525600 minutes in 5 minute slots then requires at least 1681920 bytes (about 1.6 MBytes).</p>
<p>Additionally: <code><a class="el" href="structEPS__map.html">EPS_map</a></code> also creates a meta-data map (<code>node_vector_index</code>) from <a class="el" href="structfz_1_1Node__ID__key.html" title="Standardized Formalizer Node ID key.">Node_ID_key</a> to vector index to align with a vector of <code><a class="el" href="structeps__data.html">eps_data</a></code> for each <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> that is mapped into the temporal map.</p>
<h2><code><a class="el" href="structMinute__Record__Map.html" title="Note A: The populate() function assigns Node pointers to the record minutes in accordance with a spec...">Minute_Record_Map</a></code></h2>
<p>Originally developed to map how time was actually spent, as far as available data in the <a class="el" href="classfz_1_1Log.html">Log</a> is sufficiently accurate and complete. Of course, the same data type could be used to map a (candidate) Schedule into the future.</p>
<p>As the name suggests, the default interval size is 1 minute. The temporal mapping is a simple vector or pointers to Nodes, each corresponding to a specific minute, between specified <code>t_start</code> and <code>t_end</code>. Methods are provided to easily map a <a class="el" href="classfz_1_1Log.html">Log</a> interval and to work with pointer elements at any time within that interval.</p>
<p>If a pointer is represented by 64 bits then each minute consumes 8 bytes. Mapping a year then requires at least 4204800 bytes (about 4.2 MBytes).</p>
<p>Additionally: A separately defined <code><a class="el" href="structNode__Category__Cache__Map.html">Node_Category_Cache_Map</a></code> can be used to flexibly and with high specificity categorize mapped Nodes, and then, optionnaly, to translate the categorized inspection of the <code><a class="el" href="structMinute__Record__Map.html" title="Note A: The populate() function assigns Node pointers to the record minutes in accordance with a spec...">Minute_Record_Map</a></code> even further by translating the output though a second <code>cat_translation_map</code>. In summary, this provides a combination of filtering, mapping, inspection, and transformation.</p>
<h2><code><a class="el" href="structfz_1_1Byte__Map.html">Byte_Map</a></code></h2>
<p>The <code><a class="el" href="structfz_1_1Byte__Map.html">Byte_Map</a></code> is intended for temporal mapping that combines <a class="el" href="classfz_1_1Graph.html">Graph</a> data with either <a class="el" href="classfz_1_1Log.html">Log</a> or Schedule data, but where it is not necessary to be able to track back from a data point in the map to the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> that produced it.</p>
<p>Instead, a <code><a class="el" href="structfz_1_1Byte__Map.html">Byte_Map</a></code> is meant to be used to carry out calculations over collections of time points while being relatively conservative in terms of memory consumption and CPU effort devoted to translating data points (hence no bit map).</p>
<p>For example, each byte (<code>uint8_t</code>) can be associated with 1 minute of a time span, a specific type of <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> (e.g. repeating) can be associated with the value 1 and mapped. Summing the value content of each byte in the map then produces a count of the number of minutes that are associated with such Nodes.</p>
<p>A year of 525600 minutes consumes 525600 bytes in a <code><a class="el" href="structfz_1_1Byte__Map.html">Byte_Map</a></code> (i.e. about 0.5 MBytes). </p>

</div>
</div>
<a id="a9e51cecf62d27bf997fda163c4ad80b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e51cecf62d27bf997fda163c4ad80b1">&#9670;&nbsp;</a></span>Log_chunk_iterator_interval</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt; Log_chunk_ptr_map::iterator, Log_chunk_ptr_map::iterator &gt; <a class="el" href="namespacefz.html#a9e51cecf62d27bf997fda163c4ad80b1">fz::Log_chunk_iterator_interval</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structInterval.html">Interval</a> types for the Log_chunks_Deque. </p>
<p><a class="el" href="structInterval.html">Interval</a> type for the <a class="el" href="structfz_1_1Log__chunks__Map.html">Log_chunks_Map</a> </p>

</div>
</div>
<a id="aa0bd892bb50b2004fbf6189c332149e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0bd892bb50b2004fbf6189c332149e2">&#9670;&nbsp;</a></span>Log_entries_Map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt; const <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a>, std::unique_ptr&lt; <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> &gt; &gt; <a class="el" href="namespacefz.html#aa0bd892bb50b2004fbf6189c332149e2">fz::Log_entries_Map</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<h3><a class="el" href="classfz_1_1Log.html">Log</a> entries (map)</h3>
<p>A map of smart pointers to <a class="el" href="classfz_1_1Log.html">Log</a> entries, referenced by <a class="el" href="classfz_1_1Log.html">Log</a> entry ID key. This is how entries are connected in the <a class="el" href="classfz_1_1Log.html">Log</a> data structure.</p>
<p>Consecutive entries (ordered by ID) are the primary records of the <a class="el" href="classfz_1_1Log.html">Log</a>, as stored in database format. </p>

</div>
</div>
<a id="a35f2fb9dc6e9c0137dd3cc763316a097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f2fb9dc6e9c0137dd3cc763316a097">&#9670;&nbsp;</a></span>Node_List</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bi::deque&lt;<a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a>, Node_ID_key_allocator&gt; <a class="el" href="namespacefz.html#a35f2fb9dc6e9c0137dd3cc763316a097">fz::Node_List</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type used for named Lists (or ordered collections) of Nodes. </p>
<p>For detailed information see <a href="https://trello.com/c/zcUpEAXi">https://trello.com/c/zcUpEAXi</a>, and for reasons why these Lists store <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> ID keys instead of shared-memory pointers to Nodes see: <a href="https://trello.com/c/zcUpEAXi/189-fzserverpq-named-lists#comment-5fac08dc178a257eb6f953ac">https://trello.com/c/zcUpEAXi/189-fzserverpq-named-lists#comment-5fac08dc178a257eb6f953ac</a> </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a95a7b508456ccb1691f487ed136d52d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a7b508456ccb1691f487ed136d52d4">&#9670;&nbsp;</a></span>exit_status_code</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefz.html#a95a7b508456ccb1691f487ed136d52d4">fz::exit_status_code</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standardized exit codes for the Formalizer environment. </p>
<p>Note: If you modify this, please also modify error.py. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a95a7b508456ccb1691f487ed136d52d4a705b1561a859fa4dfba9b3e3045d9f24"></a>exit_NUMENUMS&#160;</td><td class="fielddoc"><p>this one simplifies corresponding array definition, e.g. char[exit_NUMENUMS] </p>
</td></tr>
</table>

</div>
</div>
<a id="ad68bce1f115f5d6e9618e1ea1518e30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68bce1f115f5d6e9618e1ea1518e30a">&#9670;&nbsp;</a></span>PQ_Command_Variant</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefz.html#ad68bce1f115f5d6e9618e1ea1518e30a">fz::PQ_Command_Variant</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad68bce1f115f5d6e9618e1ea1518e30aaa635b87c5a7bfc8edbc3de36ac5d63c2"></a>pq_command_runsilent&#160;</td><td class="fielddoc"><p>this is the default </p>
</td></tr>
<tr><td class="fieldname"><a id="ad68bce1f115f5d6e9618e1ea1518e30aac0b188614f2dcefaa28cee9e0c37ddde"></a>pq_command_log&#160;</td><td class="fielddoc"><p>run and write to log file </p>
</td></tr>
<tr><td class="fieldname"><a id="ad68bce1f115f5d6e9618e1ea1518e30aac66415affc9c53289c3b68d2b6d3a432"></a>pq_command_simulate&#160;</td><td class="fielddoc"><p>write to log file only </p>
</td></tr>
</table>

</div>
</div>
<a id="a6fd9cd34cd3b99c03b59b7054f5709df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd9cd34cd3b99c03b59b7054f5709df">&#9670;&nbsp;</a></span>pq_LBfields</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefz.html#a6fd9cd34cd3b99c03b59b7054f5709df">fz::pq_LBfields</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classfz_1_1Log.html">Log</a> Breakpoint fields: </p>
<ul>
<li><code>pqlb_id</code>: a <a class="el" href="classfz_1_1Log.html">Log</a> chunk ID identifies each Breakpoint. </li>
</ul>

</div>
</div>
<a id="a229dcedb04cce4ee361097ae545fec1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229dcedb04cce4ee361097ae545fec1a">&#9670;&nbsp;</a></span>pq_LCfields</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefz.html#a229dcedb04cce4ee361097ae545fec1a">fz::pq_LCfields</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classfz_1_1Log.html">Log</a> chunk fields: </p>
<ul>
<li><code>pqlc_id</code>: ID that also specifies the start time of a chunk.</li>
<li><code>pqlc_nid</code>: <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> ID of the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> to which the chunk belongs.</li>
<li><code>pqlc_tclose</code>: Chunk close time (or infinity if the cuhnk is still open). </li>
</ul>

</div>
</div>
<a id="a1adf8c508a2a57973cb07be9a12d345f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adf8c508a2a57973cb07be9a12d345f">&#9670;&nbsp;</a></span>pq_LEfields</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefz.html#a1adf8c508a2a57973cb07be9a12d345f">fz::pq_LEfields</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classfz_1_1Log.html">Log</a> entry fields: </p>
<ul>
<li><code>pqle_id</code>: ID that corresponds to a <a class="el" href="classfz_1_1Log.html">Log</a> chunk ID, with an index position.</li>
<li><code>pqle_nid</code>: possible <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> ID when the entry does not belong to the same <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> as the chunk.</li>
<li><code>pqle_text</code>: Entry text content. </li>
</ul>

</div>
</div>
<a id="aef05dd6bfa4d4a09d3eace4949b6fab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef05dd6bfa4d4a09d3eace4949b6fab0">&#9670;&nbsp;</a></span>ReferenceTime_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefz.html#aef05dd6bfa4d4a09d3eace4949b6fab0">fz::ReferenceTime_t</a> : std::time_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aef05dd6bfa4d4a09d3eace4949b6fab0a627f41ff4b5237b95dea7d92863e3b15"></a>RTt_invalid_time_stamp&#160;</td><td class="fielddoc"><p>a numerical rendering of 'ERROR' </p>
</td></tr>
<tr><td class="fieldname"><a id="aef05dd6bfa4d4a09d3eace4949b6fab0a328419ab650b1af199fdb58a44105aaa"></a>RTt_unspecified&#160;</td><td class="fielddoc"><p>when scheduling this is interpreted as 'no specified target date to take into account' </p>
</td></tr>
<tr><td class="fieldname"><a id="aef05dd6bfa4d4a09d3eace4949b6fab0a9803c17416a694a786f71407e6276512"></a>RTt_unconnected&#160;</td><td class="fielddoc"><p>special code used by <a class="el" href="classfz_1_1Node.html#a3ff58c0cd01e3418955b7918a7fd26fd" title="This function attempt to determine an inherited target date from superior Nodes.">Node::inherit_targetdate()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="aef05dd6bfa4d4a09d3eace4949b6fab0ad567131680cdfe5720218682688975a4"></a>RTt_maxtime&#160;</td><td class="fielddoc"><p>this is sometimes also used as a code (e.g. see <a class="el" href="classfz_1_1Node.html#a3ff58c0cd01e3418955b7918a7fd26fd" title="This function attempt to determine an inherited target date from superior Nodes.">Node::inherit_targetdate()</a>) </p>
</td></tr>
</table>

</div>
</div>
<a id="a6c45e5e183774ed3322e5c3d445b3f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c45e5e183774ed3322e5c3d445b3f70">&#9670;&nbsp;</a></span>td_property</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">fz::td_property</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For more information about td_property values, as well as future expansions, please see the Formalizer documentation section <a href="https://docs.google.com/document/d/1rYPFgzFgjkF1xGx3uABiXiaDR5sfmOzqYQRqSntcyyY/edit#heading=h.nu3mb52d1k6n">Target date parameters in Graph v2.0+</a>. </p>
<p>Also consider Note 2 of the documentation of dil2graph.cc:get_Node_Target_Date() about target date hints in the <a class="el" href="classfz_1_1Graph.html">Graph</a> 2.0+ format parameters. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae767b87541ed3adf95ef80fb4cab307e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae767b87541ed3adf95ef80fb4cab307e">&#9670;&nbsp;</a></span>ActualTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::time_t fz::ActualTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly provide the actual system time. </p>
<p>This function is called where an emulated time status cannot be applied, such as when generating time stamps for backup files. </p>

</div>
</div>
<a id="a05a717325b4590dc3385f550c66bff75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a717325b4590dc3385f550c66bff75">&#9670;&nbsp;</a></span>allocate_Graph_modifications_in_shared_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfz_1_1Graph__modifications.html">Graph_modifications</a> * fz::allocate_Graph_modifications_in_shared_memory </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>segname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>segsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A client program uses this function to allocate new shared memory and to construct an empty <code><a class="el" href="classfz_1_1Graph__modifications.html" title="This data structure is the most efficient method to request a stack of Graph modifications.">Graph_modifications</a></code> object there. </p>
<p>That objet is used to communicate <a class="el" href="classfz_1_1Graph.html">Graph</a> modification requests to <code>fzserverpq</code>. </p>

</div>
</div>
<a id="a39614b069f7453689a159d7df30189fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39614b069f7453689a159d7df30189fc">&#9670;&nbsp;</a></span>append_Log_chunk_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::append_Log_chunk_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &amp;&#160;</td>
          <td class="paramname"><em>chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append Chunk to existing table in schema of PostgreSQL database. </p>
<p>Note: Please make sure that you close any open <a class="el" href="classfz_1_1Log.html">Log</a> chunk before appending a new one!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk</td><td>A valid <a class="el" href="classfz_1_1Log.html">Log</a> chunk object. </td></tr>
    <tr><td class="paramname">pa</td><td>Access object with database name and Formalizer schema name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classfz_1_1Log.html">Log</a> chunk was successfully stored in the database.</dd></dl>
<p>Note: Please make sure that you close any open <a class="el" href="classfz_1_1Log.html">Log</a> chunk before appending a new one!</p>
<p>Note: Although this function is an 'append_' function it simply uses the 'add_Logchunk_pq()' call. There is nothing append-specific about this call, and it can be used equally well to insert a chunk at any place in the <a class="el" href="classfz_1_1Log.html">Log</a>. To avoid any confusion, this library includes the function call 'insert_Log_chunk_pq()', which calls this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk</td><td>A valid <a class="el" href="classfz_1_1Log.html">Log</a> chunk object. </td></tr>
    <tr><td class="paramname">pa</td><td>Access object with database name and Formalizer schema name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classfz_1_1Log.html">Log</a> chunk was successfully stored in the database. </dd></dl>

</div>
</div>
<a id="abe44bca9b25db84f4d7fca4326ce26b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe44bca9b25db84f4d7fca4326ce26b8">&#9670;&nbsp;</a></span>append_Log_entry_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::append_Log_entry_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append Entry to existing table in schema of PostgreSQL database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>A valid <a class="el" href="classfz_1_1Log.html">Log</a> entry object. </td></tr>
    <tr><td class="paramname">pa</td><td>Access object with database name and Formalizer schema name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classfz_1_1Log.html">Log</a> entry was successfully stored in the database.</dd></dl>
<p>Note: Although this function is an 'append_' function it simply uses the 'add_Logentry_pq()' call. There is nothing append-specific about this call, and it can be used equally well to insert an entry at any place in the <a class="el" href="classfz_1_1Log.html">Log</a>. To avoid any confusion, this library includes the function call 'insert_Log_entry_pq()', which calls this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>A valid <a class="el" href="classfz_1_1Log.html">Log</a> entry object. </td></tr>
    <tr><td class="paramname">pa</td><td>Access object with database name and Formalizer schema name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classfz_1_1Log.html">Log</a> entry was successfully stored in the database. </dd></dl>

</div>
</div>
<a id="a7ad93411e21c8c804d2b47e1e0beb4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad93411e21c8c804d2b47e1e0beb4b9">&#9670;&nbsp;</a></span>append_string_to_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::append_string_to_file </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream::iostate *&#160;</td>
          <td class="paramname"><em>writestate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the full contents of a string to a file. </p>
<p>If the file does not exist then it will be created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path of the file. </td></tr>
    <tr><td class="paramname">s</td><td>Reference to the string. </td></tr>
    <tr><td class="paramname">writestate</td><td>Optional return of the iostate flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if appending to the file was successful. </dd></dl>

</div>
</div>
<a id="ab26caa1b821a4715dbec90c174a95e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26caa1b821a4715dbec90c174a95e97">&#9670;&nbsp;</a></span>array_from_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; fz::array_from_pq </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pq_array_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a single string containing Postgres query output that represents an array into a vector of strings. </p>
<p>The Postgres array should be enclosed in curly brackets.</p>
<p>WARNING: This function assumes that every comma indicates a next element of the array. It does not consider the case where array elements may be quoted text that contains commas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pq_array_str</td><td>the Postgres query output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of strings, one for each array element. </dd></dl>

</div>
</div>
<a id="ab46dcb3b9640365e0a78e28feed3d09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46dcb3b9640365e0a78e28feed3d09a">&#9670;&nbsp;</a></span>batch_to_NNL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::batch_to_NNL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Batchmod__targetdates.html">Batchmod_targetdates</a> &amp;&#160;</td>
          <td class="paramname"><em>batchnodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>list_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy Nodes from a batch to a Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List. </p>
<p>This does not include synchronization to database. See, for example, how this is used when processing a <code>batchmod_targetdates</code> request in <code>fzserverpq</code>. </p>

</div>
</div>
<a id="ad3abb29c608556e6534dbb67c4878f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3abb29c608556e6534dbb67c4878f16">&#9670;&nbsp;</a></span>Breakpoint_Indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Log_chunks_Map::iterator &gt; fz::Breakpoint_Indices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This converts the list of <a class="el" href="classfz_1_1Log.html">Log</a> breakpoint <a class="el" href="classfz_1_1Log.html">Log</a> chunk IDs into a list of indices into the list of <a class="el" href="classfz_1_1Log.html">Log</a> chunks (in Log::chunks). </p>
<p>Note: All <a class="el" href="classfz_1_1Log.html">Log</a> chunks must be loaded into memory before calling this function.</p>
<p>If a breakpoint was not found then the corresponding element of the vector of indices has the value log::num_Chunks(), pointing beyond all valid <a class="el" href="classfz_1_1Log.html">Log</a> chunks in the deque.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>a <a class="el" href="classfz_1_1Log.html">Log</a> object where all <a class="el" href="classfz_1_1Log.html">Log</a> chunks are in the chunks deque. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of indices into log::chunks. </dd></dl>

</div>
</div>
<a id="abca86ba1c3f53596224cbff46786d7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca86ba1c3f53596224cbff46786d7af">&#9670;&nbsp;</a></span>check_and_make_lockfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fz::check_and_make_lockfile </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>lockfilepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>extrainfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a lockfile that contains a PID and time stamp, plus optional extra info. </p>
<p>The extra info is assumed to be a simple string unless it begins with '{', in which case it is assumed to be in JSON format.</p>
<p>The file is created in a simple pseudo-JSON format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lockfilepath</td><td>The path of the lockfile to create. </td></tr>
    <tr><td class="paramname">extrainfo</td><td>Any additional data to include. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the lockfile was made, 1 if it already existed, or -1 on error. </dd></dl>

</div>
</div>
<a id="ac5030189781f4e027de8b67b55c13ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5030189781f4e027de8b67b55c13ed9">&#9670;&nbsp;</a></span>check_and_read_lockfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fz::check_and_read_lockfile </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>lockfilepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>lockfilecontent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test to see if a lockfile exists and read it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lockfilepath</td><td>The path of a lockfile. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lockfilecontent</td><td>A string variable to receive the lockfile contents. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the lockfile does not exist, 1 if it does exist, -1 on error. </dd></dl>

</div>
</div>
<a id="ab884385219138cc37ab39ee30c8da295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab884385219138cc37ab39ee30c8da295">&#9670;&nbsp;</a></span>Chunks_per_Breakpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; fz::Chunks_per_Breakpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the frequency distribution for the number of <a class="el" href="classfz_1_1Log.html">Log</a> chunks per <a class="el" href="classfz_1_1Log.html">Log</a> breakpoint. </p>
<p>Note: All <a class="el" href="classfz_1_1Log.html">Log</a> chunks must be loaded into memory before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>a <a class="el" href="classfz_1_1Log.html">Log</a> object where all <a class="el" href="classfz_1_1Log.html">Log</a> chunks are in the chunks deque. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of counts. </dd></dl>

</div>
</div>
<a id="a4f0d1276ea12c9ed4a27ba5cb0296d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f0d1276ea12c9ed4a27ba5cb0296d14">&#9670;&nbsp;</a></span>Chunks_total_minutes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long fz::Chunks_total_minutes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1Log__chunks__Map.html">Log_chunks_Map</a> &amp;&#160;</td>
          <td class="paramname"><em>chunks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the total number of minutes logged for all <a class="el" href="classfz_1_1Log.html">Log</a> chunks in the specified deque. </p>
<p>Sum of durations of <a class="el" href="classfz_1_1Log.html">Log</a> chunks.</p>
<p>For example, this can be used to determine the actual time applied to a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> by loading a <a class="el" href="classfz_1_1Log.html">Log</a> map with all the <a class="el" href="classfz_1_1Log.html">Log</a> Chunks that belong to a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> (see fzloghtml::get_Log_interval()).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunks</td><td>a deque containing a sorted list <a class="el" href="classfz_1_1Log__chunk.html" title="Specifies the start time, Node, close time, and set of entries of a Log chunk.">Log_chunk</a> pointers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum total of time logged in minutes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunks</td><td>a deque containing a sorted list <a class="el" href="classfz_1_1Log__chunk.html" title="Specifies the start time, Node, close time, and set of entries of a Log chunk.">Log_chunk</a> pointers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum total of time logged in minutes. </dd></dl>

</div>
</div>
<a id="a3cd066a32696261830f98ca59ce4a7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd066a32696261830f98ca59ce4a7f0">&#9670;&nbsp;</a></span>Clean_Exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::Clean_Exit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ecode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up after yourself before you exit. </p>
<p>Call this to exit the program and log any remaining errors in the queue.</p>
<p>The ERRWARN_SUMMARY() macro can be used to print a summary report before calling this function. After this function the queues will be empty.</p>
<p>Note: If you are using <a class="el" href="standard_8hpp.html" title="This header file declares standard structures and functions that should be used with any standardized...">standard.hpp</a> (which every Formalizer program should) then do not use this function. The correct exit processes will be set up by member functions and initialization of the <code><a class="el" href="namespacefz.html#a812e6aee98e3ba6635c8fc4bed8ad57c" title="This object projects one unique and clear interface with settings for standardized Formalizer program...">fz::standard</a></code> object instead. In your program, you can then simply call <code>exit(error_code)</code> or <code>standard.exit(error_code)</code>. Both will do the same thing. </p>

</div>
</div>
<a id="aefadca0ccb3cfd802ca2f7648e9cac25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefadca0ccb3cfd802ca2f7648e9cac25">&#9670;&nbsp;</a></span>client_socket_shmem_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::client_socket_shmem_request </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>request_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>server_ip_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>response_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A minimal TCP client communication function used to make the server aware of a request specified by data in shared memory. </p>
<p>Note: This client-server messaging function is only meant to be used with short pre-defined message strings, while data is shared through shared memory. A different function should be used for generic client-server stream communication.</p>
<p>The return value of this function communication success or failure on the client side. According to the protocol, problems on the server side are signaled by a response of "ERROR". In that case, check the shared memory for a possible "error" data structure with additional information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request_str</td><td>A string that identifies the shared memory segment for request data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">server_ip_address</td><td>Normally this is "127.0.0.1" for shared memory exchanges. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_number</td><td>An agreed port number for the communication. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">response_str</td><td>The server response string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if communication succeeded.</dd></dl>
<p>Although this function was created to communicate shmem requests, it can probably be used for any TCP client communication.</p>
<p>Note: This client-server messaging function is only meant to be used with short pre-defined message strings, while data is shared through shared memory. A different function should be used for generic client-server stream communication.</p>
<p>The return value of this function communication success or failure on the client side. According to the protocol, problems on the server side are signaled by a response of "ERROR". In that case, check the shared memory for a possible "error" data structure with additional information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request_str</td><td>A string that identifies the shared memory segment for request data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">server_ip_address</td><td>Normally this is "127.0.0.1" for shared memory exchanges. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_number</td><td>An agreed port number for the communication. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">response_str</td><td>The server response string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if communication succeeded. </dd></dl>

</div>
</div>
<a id="a23878d23a56d64f8838ea960784ff451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23878d23a56d64f8838ea960784ff451">&#9670;&nbsp;</a></span>close_Log_chunk_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::close_Log_chunk_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &amp;&#160;</td>
          <td class="paramname"><em>chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the Chunk specified, which must already exist within a table in schema of PostgreSQL database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk</td><td>A valid <a class="el" href="classfz_1_1Log.html">Log</a> chunk object with valid t_close time. </td></tr>
    <tr><td class="paramname">pa</td><td>Access object with database name and Formalizer schema name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classfz_1_1Log.html">Log</a> chunk was successfully updated to closed status.</dd></dl>
<p>Note that this same function can be used to reopen a <a class="el" href="classfz_1_1Log.html">Log</a> chunk by specifying a <code>t_close</code> time equal to <code>FZ_TCHUNK_OPEN</code>. See how this is done in <code>fzlog.cpp:reopen_chunk()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk</td><td>A valid <a class="el" href="classfz_1_1Log.html">Log</a> chunk object with valid t_close time. </td></tr>
    <tr><td class="paramname">pa</td><td>Access object with database name and Formalizer schema name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classfz_1_1Log.html">Log</a> chunk was successfully updated to closed status. </dd></dl>

</div>
</div>
<a id="ad724f1008a1a3be0113e7c8d29239988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad724f1008a1a3be0113e7c8d29239988">&#9670;&nbsp;</a></span>config_parse_text_interpretation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">text_interpretation fz::config_parse_text_interpretation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>csflags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A useful function to convert a set of comma separated flag identifiers into a <code>text_interpretation</code> flags bitmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csflags</td><td>String with comma separated flag identifiers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A bitmap with text_interpretation flags. </dd></dl>

</div>
</div>
<a id="a9bde9da1de78d7bc0492b22eba9630e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bde9da1de78d7bc0492b22eba9630e8">&#9670;&nbsp;</a></span>connection_setup_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PGconn * fz::connection_setup_pq </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up a connection with an existing Postgres database. </p>
<p>This also prepares a safe search search path. The database needs to exist. If necessary, create it with the command <code>createdb [databasename]</code> (which defaults to the user name).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td>dbname the identifier of a database in a local Postgres setup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the connection if successfully created, otherwise NULL. </dd></dl>

</div>
</div>
<a id="a26517e2044ebeab12a0870dd60f5c2fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26517e2044ebeab12a0870dd60f5c2fc">&#9670;&nbsp;</a></span>convert_array_output_to_input_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::convert_array_output_to_input_pq </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>entryids_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unfortunately, Postgres output strings with array data cannot simply be used unmodified as array input data. </p>
<p>Here are some things this needs to do:</p><ul>
<li>If there are double quotes in the string then it's almost ready, just replace those with single quotes.</li>
<li>Otherwise, you have to put single quotes around every of the comma delimited elements. </li>
</ul>

</div>
</div>
<a id="afbbbb262820388617f57a0881e141c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbbb262820388617f57a0881e141c6e">&#9670;&nbsp;</a></span>convert_special_data_html()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::convert_special_data_html </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>htmlstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>frompos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>beforepos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_extra_space</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token_sep</em> = <code>&quot;&#160;\t\n\r\f\v&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This tokenizes, i.e. </p>
<p>finds words separated by white space, in order to convert special data, which we assume is identifiable within a token. This function is applied only to parts of a string that were NOT part of an HTML tag, as found in <a class="el" href="namespacefz.html#a6e85b9d67d3d04d7c5bc2ae623e416c4" title="Efficiently and reliably filter snippets of HTML text such that they become optimally embeddable with...">make_embeddable_html()</a>.</p>
<p>Note: According to RFC 3986, a valid URI may contain any of the following characters:</p>
<p>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~:/?#[]@!$&amp;'()*+,;=</p>
<p>Because of this, auto-detection of a URL can fail if the URL is followed immediately by a sentence divider such as ".,;:!?". If you want auto-detection to work, add a space.</p>
<p>If you wish to detect simplified URLs between square brackets then you can add '[]' to the default set used in token_sep.</p>
<p>Instead, you can use the extra-space-after-URL convention and have the extra space automatically removed by setting the 'remove_extra_space' flag. This will detect if a URI is followed by ' ' and one of '.,:])' and remove the extra space.</p>
<p>***TODO:</p><ul>
<li>Possibly apply the tokenize-first approach explained in <a class="el" href="namespacefz.html#a6e85b9d67d3d04d7c5bc2ae623e416c4" title="Efficiently and reliably filter snippets of HTML text such that they become optimally embeddable with...">make_embeddable_html()</a>.</li>
<li>Ideally, only a '.' that is followed by a token_sep character, or that is the last character in the string should be treated as a '.' when processing a URI, otherwise it should be treated as part of the URI.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">htmlstr</td><td>The string in which to convert identified special data. </td></tr>
    <tr><td class="paramname">frompos</td><td>Process string from this position. </td></tr>
    <tr><td class="paramname">beforepos</td><td>Process string up to but not including this position. </td></tr>
    <tr><td class="paramname">remove_extra_space</td><td>Remove space that was added just to identify links. </td></tr>
    <tr><td class="paramname">token_sep</td><td>A set of characters to recognize as token separators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The updated string with conversions applied. </dd></dl>

</div>
</div>
<a id="a9ca8aeb60ace2b85c9010f9576cfc316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca8aeb60ace2b85c9010f9576cfc316">&#9670;&nbsp;</a></span>convert_special_data_word_html()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::convert_special_data_word_html </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>wstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This analyzes a token to identify special data, which is converted by adding a useful link. </p>
<p>At present, this identifies and converts to links URLs, <a class="el" href="classfz_1_1Log.html">Log</a> chunk IDs, <a class="el" href="classfz_1_1Log.html">Log</a> entry IDs and <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> IDs. </p>

</div>
</div>
<a id="a5ceb82b53b009d791ad638a4d8cb2ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ceb82b53b009d791ad638a4d8cb2ce1">&#9670;&nbsp;</a></span>copy_from_id_button()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::copy_from_id_button </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>button_class</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates HTML for a button that will copy contents from the innerHTML of a DOM object with a specific id to the clipboard. </p>
<p>Use this with <a class="el" href="namespacefz.html#af426ac4cce3a1975a5211a589ff3fa12" title="Generates Javascript for a function top copy contents from the innerHTML of a DOM object with a speci...">copy_html_from_id_js()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the object from which to copy. </td></tr>
    <tr><td class="paramname">label</td><td>The text to show on the button. </td></tr>
    <tr><td class="paramname">button_class</td><td>Optional extra button class CSS identifiers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The HTML to embed. </dd></dl>

</div>
</div>
<a id="a1b83645cda140b818a9980c7e516d4a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b83645cda140b818a9980c7e516d4a0">&#9670;&nbsp;</a></span>copy_from_input_button()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::copy_from_input_button </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>button_class</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="namespacefz.html#a5ceb82b53b009d791ad638a4d8cb2ce1" title="Generates HTML for a button that will copy contents from the innerHTML of a DOM object with a specifi...">copy_from_id_button()</a>, but copies the value of an input element. </p>
<p>Note that the input element must have an id, not just a name field. Use this with <a class="el" href="namespacefz.html#abe9a11b9dee3b2ceea3433706046c6a6" title="Like copy_html_from_id_js(), but copies the value of an input element.">copy_value_from_id_js()</a>. </p>

</div>
</div>
<a id="af426ac4cce3a1975a5211a589ff3fa12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af426ac4cce3a1975a5211a589ff3fa12">&#9670;&nbsp;</a></span>copy_html_from_id_js()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::copy_html_from_id_js </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates Javascript for a function top copy contents from the innerHTML of a DOM object with a specific id to the clipboard. </p>
<p>Use this with <a class="el" href="namespacefz.html#a5ceb82b53b009d791ad638a4d8cb2ce1" title="Generates HTML for a button that will copy contents from the innerHTML of a DOM object with a specifi...">copy_from_id_button()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the object from which to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Javascript function to include (between &lt;script&gt; tags or in a .js file). </dd></dl>

</div>
</div>
<a id="acefbed699792377f1fb0c4ffc77f1d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefbed699792377f1fb0c4ffc77f1d46">&#9670;&nbsp;</a></span>copy_Incomplete_to_List()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fz::copy_Incomplete_to_List </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>to_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>from_max</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>to_max</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>_features</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>_maxsize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a number of <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> IDs from a list of incomplete Nodes sorted by effective target date to a Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A valid <a class="el" href="classfz_1_1Graph.html">Graph</a> data structure. </td></tr>
    <tr><td class="paramname">to_name</td><td>The name of the target Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List. </td></tr>
    <tr><td class="paramname">from_max</td><td>Copy at most this many <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> IDs (0 means no limit). </td></tr>
    <tr><td class="paramname">to_max</td><td>Copy until the Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List contains this many <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> IDs or more (0 means no limit). </td></tr>
    <tr><td class="paramname">_features</td><td>Optional features to set if the target Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List is new. </td></tr>
    <tr><td class="paramname">_maxsize</td><td>Optional maximum size to set if the target Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List is new. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> IDs copied. </dd></dl>

</div>
</div>
<a id="abe9a11b9dee3b2ceea3433706046c6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9a11b9dee3b2ceea3433706046c6a6">&#9670;&nbsp;</a></span>copy_value_from_id_js()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::copy_value_from_id_js </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="namespacefz.html#af426ac4cce3a1975a5211a589ff3fa12" title="Generates Javascript for a function top copy contents from the innerHTML of a DOM object with a speci...">copy_html_from_id_js()</a>, but copies the value of an input element. </p>
<p>Use this with <a class="el" href="namespacefz.html#a1b83645cda140b818a9980c7e516d4a0" title="Like copy_from_id_button(), but copies the value of an input element.">copy_from_input_button()</a>. </p>

</div>
</div>
<a id="a125c22828646b624c8e4f4775f84dc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125c22828646b624c8e4f4775f84dc5d">&#9670;&nbsp;</a></span>create_Breakpoints_table_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Breakpoints_table_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;&#160;</td>
          <td class="paramname"><em>apq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new database table for Breakpoints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apq</td><td>active database connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if table was successfully created. </dd></dl>

</div>
</div>
<a id="ad2da8c677f43a85e7f86d9074e468962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2da8c677f43a85e7f86d9074e468962">&#9670;&nbsp;</a></span>create_Edges_table_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Edges_table_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new database table for Edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>active database connection. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if table was successfully created. </dd></dl>

</div>
</div>
<a id="abe69e72e6cc57d40e3738f2bb2d7b1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe69e72e6cc57d40e3738f2bb2d7b1bc">&#9670;&nbsp;</a></span>create_Enum_Types_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Enum_Types_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create enumerated types in database for <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> and <a class="el" href="classfz_1_1Edge.html">Edge</a> data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>active database connection. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if types were successfully created. </dd></dl>

</div>
</div>
<a id="a44280392e614e1145d3c5a27aa640b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44280392e614e1145d3c5a27aa640b59">&#9670;&nbsp;</a></span>create_Formalizer_schema_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Formalizer_schema_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new database schema for Formalizer data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>active database connection. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if schema was successfully created. </dd></dl>

</div>
</div>
<a id="aebd926038748af1ffa7f75a0f6643c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd926038748af1ffa7f75a0f6643c38">&#9670;&nbsp;</a></span>create_Guide_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Guide_table </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;&#160;</td>
          <td class="paramname"><em>apq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>guidetable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>guidetablelayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the table for Guide snippets if it does not already exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>is an open database connection. </td></tr>
    <tr><td class="paramname">schemaname</td><td>is the Formalizer schema name (usually Graph_access::pq_schemaname). </td></tr>
    <tr><td class="paramname">guidetable</td><td>is the Guide table name (e.g. "guide_system"). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44a2d42be5384357b19e513b20b1c77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a2d42be5384357b19e513b20b1c77b">&#9670;&nbsp;</a></span>create_Logchunks_table_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Logchunks_table_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;&#160;</td>
          <td class="paramname"><em>apq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new database table for <a class="el" href="classfz_1_1Log.html">Log</a> chunks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apq</td><td>active database connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if table was successfully created. </dd></dl>

</div>
</div>
<a id="aa8ef5ef0384e0d621bbff628679d3981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ef5ef0384e0d621bbff628679d3981">&#9670;&nbsp;</a></span>create_Logentries_table_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Logentries_table_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;&#160;</td>
          <td class="paramname"><em>apq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new database table for <a class="el" href="classfz_1_1Log.html">Log</a> entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apq</td><td>active database connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if table was successfully created. </dd></dl>

</div>
</div>
<a id="a75375e8fb94d22f2facb4085afe93de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75375e8fb94d22f2facb4085afe93de9">&#9670;&nbsp;</a></span>create_Nodes_table_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Nodes_table_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new database table for Nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>active database connection. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if table was successfully created. </dd></dl>

</div>
</div>
<a id="a2359bd1e82e68f38bd9d900588887fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2359bd1e82e68f38bd9d900588887fde">&#9670;&nbsp;</a></span>create_Topics_table_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::create_Topics_table_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new database table for Topics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>active database connection. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if table was successfully created. </dd></dl>

</div>
</div>
<a id="ab43f90f38e3046a0b7593d9d306217b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43f90f38e3046a0b7593d9d306217b6">&#9670;&nbsp;</a></span>delete_Log_entry_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::delete_Log_entry_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete Entry from existing table in schema of PostgreSQL database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>A valid <a class="el" href="classfz_1_1Log.html">Log</a> entry object. </td></tr>
    <tr><td class="paramname">pa</td><td>Access object with database name and Formalizer schema name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classfz_1_1Log.html">Log</a> entry was successfully deleted from the database. </dd></dl>

</div>
</div>
<a id="a9d1083f529f49b38c70a3a77eec5cf08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1083f529f49b38c70a3a77eec5cf08">&#9670;&nbsp;</a></span>Delete_Named_Node_List_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::Delete_Named_Node_List_pq </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>listname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List from the NamedNodeLists table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dbname</td><td>Database name. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
    <tr><td class="paramname">listname</td><td>Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfully deleted. </dd></dl>

</div>
</div>
<a id="ab2f47cae19dab82915dc813045ee3cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f47cae19dab82915dc813045ee3cfe">&#9670;&nbsp;</a></span>Entries_total_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long fz::Entries_total_text </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacefz.html#aa0bd892bb50b2004fbf6189c332149e2">Log_entries_Map</a> &amp;&#160;</td>
          <td class="paramname"><em>entries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the total number of characters in <a class="el" href="classfz_1_1Log.html">Log</a> entry description text in the specified map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entries</td><td>a map containing <a class="el" href="structfz_1_1Log__entry__ID__key.html" title="Standardized Formalizer Log entry ID key.">Log_entry_ID_key</a> and <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> smart pointer pairs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum total of text characters. </dd></dl>

</div>
</div>
<a id="a4df6964ef0bf050076248edb5be67f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df6964ef0bf050076248edb5be67f44">&#9670;&nbsp;</a></span>entry_minor_id_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::entry_minor_id_pq </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minor_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts the <a class="el" href="classfz_1_1Log.html">Log</a> entry minor ID to a three digit zero-padded integer for storage in Postgres. </p>
<p>This does not affect how the minor ID is retrieved and converted back to its constituent part of a <a class="el" href="classfz_1_1Log.html">Log</a> entry ID. This is done to ensure that order comparisons and sorting in Postgres are produce the same results as with the lexical comparison operators defined for <a class="el" href="structfz_1_1Log__TimeStamp.html" title="Timestamp IDs in the format required for Log IDs.">Log_TimeStamp</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minor_id</td><td>A <a class="el" href="classfz_1_1Log.html">Log</a> entry minor-ID number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A zero-padded three digit numerical string. </dd></dl>

</div>
</div>
<a id="a8a40b1a728ffe05a3aca94bc24daff0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a40b1a728ffe05a3aca94bc24daff0e">&#9670;&nbsp;</a></span>epochtime_from_timestamp_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t fz::epochtime_from_timestamp_pq </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pqtimestamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert Postgres query result time stamp strings to Unix time, for example, for <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> target date parameter. </p>
<p>The format returned by PQgetvalue() is '2015-01-03 16:00:00'. As long as DATESTYLE has not been altered (e.g. with 'set datestyle to DMY'), the standard ISO format is YMD. It might be best to confirm that. Empty or 'infinity' (or other non-numerical time stamps) are interpreted as unspecified, for which -1 is returned.</p>
<p>This uses the UTC / Local Time convention built into <a class="el" href="namespacefz.html#a50b50bdd16d9e99e3ff4bf398f3fe68f" title="Convert a Formalizer time stamp string into local Unix time.">time_stamp_time()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pqtimestamp</td><td>a time stamp string obtained via PQgetvalue(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unix time stamp as seconds since 00:00:00 UTC, January 1, 1970 or -1 when unspecified or invalid format. </dd></dl>

</div>
</div>
<a id="a5cdf2285bd874038959c3aca55feac8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdf2285bd874038959c3aca55feac8d">&#9670;&nbsp;</a></span>error_summary_wrapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::error_summary_wrapper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wrapped version of ERRWARN_SUMMARY that can be stacked. </p>
<p>This can be suppressed either by setting base.out to nullptr or by setting the standard.quiet flag. (Note that this flag receives a copy of any formalizer_standard_program::quiet when formalizer_standard_program::exit() is used.) </p>

</div>
</div>
<a id="a8bd34bad3bec22615ba4ffda20aa2d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd34bad3bec22615ba4ffda20aa2d2d">&#9670;&nbsp;</a></span>file_to_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::file_to_buffer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ifstream::iostate *&#160;</td>
          <td class="paramname"><em>readstate</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the full contents of a binary file into a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>of the file. </td></tr>
    <tr><td class="paramname">buf</td><td>reference to the receiving buffer. </td></tr>
    <tr><td class="paramname">readstate</td><td>returns the iostate flags when provided (default: nullptr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the read into buffer was successful. </dd></dl>

</div>
</div>
<a id="a60a2a6715fce1e3b724ddd482214fb0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a2a6715fce1e3b724ddd482214fb0a">&#9670;&nbsp;</a></span>file_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::file_to_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ifstream::iostate *&#160;</td>
          <td class="paramname"><em>readstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the full contents of a (text) file into a string. </p>
<p>The contents of the receiving string are replaced. For efficiency, this function finds the size of the file and reserves space in the string before pulling in the content.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>of the file. </td></tr>
    <tr><td class="paramname">s</td><td>reference to the receiving string. </td></tr>
    <tr><td class="paramname">readstate</td><td>returns the iostate flags when provided (default: nullptr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the read into string was successful. </dd></dl>

</div>
</div>
<a id="a39456418d635eb17a761d96fbf62ceb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39456418d635eb17a761d96fbf62ceb1">&#9670;&nbsp;</a></span>find_Graph_modifications_in_shared_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfz_1_1Graph__modifications.html">Graph_modifications</a> * fz::find_Graph_modifications_in_shared_memory </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>segment_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classfz_1_1Graph.html">Graph</a> server program uses this function to find shared memory that contains a <code>Graph_modification</code> object. </p>
<p>That object is parsed to respond to modification requests. </p>

</div>
</div>
<a id="a56fd22f72beee5ca8516df2fdef88123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56fd22f72beee5ca8516df2fdef88123">&#9670;&nbsp;</a></span>find_Node_by_idstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node_Graph_ptr_pair fz::find_Node_by_idstr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>node_idstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>graph_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> in a <a class="el" href="classfz_1_1Graph.html">Graph</a> by its ID key from a string. </p>
<p>The <a class="el" href="classfz_1_1Graph.html">Graph</a> is obtained from shared memory (if available) if a valid pointer is not already provided.</p>
<p>Note: If the <a class="el" href="classfz_1_1Graph.html">Graph</a> is found (or already known), but the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> is not found then the pair returned contains the valid <a class="el" href="classfz_1_1Graph.html">Graph</a> pointer and a nullptr for the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_idstr</td><td>A string specifying a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> ID key. </td></tr>
    <tr><td class="paramname">graph_ptr</td><td>A pointer to the <a class="el" href="classfz_1_1Graph.html">Graph</a>, if previously identified in shared memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of valid pointers to a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> and to the <a class="el" href="classfz_1_1Graph.html">Graph</a>, or nullptr for <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> or <a class="el" href="classfz_1_1Graph.html">Graph</a> not found. </dd></dl>

</div>
</div>
<a id="a0f4f9a2b8943c1b429238e348efd47dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4f9a2b8943c1b429238e348efd47dc">&#9670;&nbsp;</a></span>find_server_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::find_server_address </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>ipaddr_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discover this server's IP address from the perspective of a connecting TCP client. </p>
<p>This method should work irrespective of the network device being used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ipaddr_str</td><td>Reference to string variable that receives the IP address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful. </dd></dl>

</div>
</div>
<a id="af0c13e8ff9e09d7fa7218c9b024eee6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c13e8ff9e09d7fa7218c9b024eee6e">&#9670;&nbsp;</a></span>get_Chunk_pq_field_numbers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::get_Chunk_pq_field_numbers </td>
          <td>(</td>
          <td class="paramtype">PGresult *&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve field column numbers for chunks query to make sure the correct field numbers are used. </p>
<p>This is an extra safety measure in case formats are changed in the future and in case of potential database version mismatch.</p>
<p>This function updates the field numbers in <code>pq_chunk_field</code>. The field names that this version assumes are in the variable <code>pq_chunk_fieldnames</code>. The fields are enumerated with <code>pq_LCfields</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>a valid pointer obtained by <code>PQgetResult()</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all the field names were found. </dd></dl>

</div>
</div>
<a id="a0935a21886cd77a134efd55059d2ef13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0935a21886cd77a134efd55059d2ef13">&#9670;&nbsp;</a></span>get_content()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacefz.html#a95a7b508456ccb1691f487ed136d52d4">exit_status_code</a>, std::string &gt; fz::get_content </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>utf8_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>content_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>errmsg_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to fill a string with text content if it was empty. </p>
<p>E.g. see how this is used in fzaddnode.cpp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">utf8_text</td><td>A string reference to receive the content (if not already present). </td></tr>
    <tr><td class="paramname">content_path</td><td>A possible path to a file containing text content. </td></tr>
    <tr><td class="paramname">errmsg_target</td><td>A short string to be used in error messages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair with a proposed exit code (exit_ok if no problem) and possible error message (empty if no problem). </dd></dl>

</div>
</div>
<a id="ac5e9d57226726175af8c8e276edd0c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e9d57226726175af8c8e276edd0c58">&#9670;&nbsp;</a></span>get_DIL_entry_num_superiors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fz::get_DIL_entry_num_superiors </td>
          <td>(</td>
          <td class="paramtype">DIL_entry *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of connections from a DIL entry to Superiors. </p>
<p>Note: Perhaps this function belongs in the utilities.cc library of dil2al.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>pointer to DIL_entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count of number of connections to Superiors. </dd></dl>

</div>
</div>
<a id="aa7838e7b982bd5a885f69f42a8fa929c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7838e7b982bd5a885f69f42a8fa929c">&#9670;&nbsp;</a></span>get_DIL_Graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Detailed_Items_List * fz::get_DIL_Graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To USE and COMPILE : </p>
<p>Load the whole Detailed_Items_List and return a pointer to its data structure.</p>
<ol type="1">
<li>The up-to-date dil2al.hh header file must be on the include path, e.g. by adding -I/home/randalk/src/dil2al.</li>
<li>The necessary functions that are declared there must be compiled in up-to-date object files made accessible, e.g. by adding them in dependencies and in the build command.</li>
</ol>
<p>For an example, see the Makefile of formalizer/tools/dil2graph.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to Detailed_Items_List object, or NULL if unsuccessful. </dd></dl>

</div>
</div>
<a id="a02517c2cf1052f55bb388a0808fdaa1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02517c2cf1052f55bb388a0808fdaa1b">&#9670;&nbsp;</a></span>get_DIL_hierarchy_num_connections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fz::get_DIL_hierarchy_num_connections </td>
          <td>(</td>
          <td class="paramtype">Detailed_Items_List *&#160;</td>
          <td class="paramname"><em>dil</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of connections in a DIL hierarchy. </p>
<p>Note: Perhaps this function belongs in the utilties.cc library of dil2al.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dil</td><td>pointer to DIL hierarchy (Detailed_Items_List). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count of total number of connections in the hierarchy. </dd></dl>

</div>
</div>
<a id="a004bd737f1c412b124eaf7ca6df90603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004bd737f1c412b124eaf7ca6df90603">&#9670;&nbsp;</a></span>get_DIL_Topics_File_List()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; fz::get_DIL_Topics_File_List </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the actual set of Topical DIL Files that exist in the dil2al base directory. </p>
<p>This function requires that <code>basedir</code> is valid, otherwise the <a class="el" href="namespacefz.html#aa23b82243a12ae2b0d35ccb70d785857" title="Execute a shell command and retrieve the standard output as a string.">shellcmd2str()</a> call will throw a runtime_error. This function does not distinguish between actual files and symlinks (see detect_DIL_Topics_Symlinks()).</p>
<p>Note: Perhaps this function belongs in the utilities.cc library of dil2al.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the absolute file name strings of each Topical DIL File. </dd></dl>

</div>
</div>
<a id="a43dbf64dc00781a4cd1308f0842ebad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43dbf64dc00781a4cd1308f0842ebad4">&#9670;&nbsp;</a></span>get_enclosed_substring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::get_enclosed_substring </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>open_enclosure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>close_enclosure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>alt_return</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find and return a substring enclosed by opening and closing characters. </p>
<p>This is often used to find labels between brackets, e.g. [SOME-LABEL].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to search in. </td></tr>
    <tr><td class="paramname">open_enclosure</td><td>The opening character before the substring. </td></tr>
    <tr><td class="paramname">close_enclosure</td><td>The closing character after the substring. </td></tr>
    <tr><td class="paramname">alt_return</td><td>The string to return if an enclosed substring was not found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The substring between enclosing characters or the alt_return string. </dd></dl>

</div>
</div>
<a id="a9f3fa62a73b340350dec9f23936460f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3fa62a73b340350dec9f23936460f8">&#9670;&nbsp;</a></span>get_Log_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::get_Log_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>chunk_id_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1entry__data.html">entry_data</a> &amp;&#160;</td>
          <td class="paramname"><em>edata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the <a class="el" href="classfz_1_1Log.html">Log</a> to find specific entry point. </p>
<p>The results are returned in an <code><a class="el" href="structfz_1_1entry__data.html" title="A useful data structure for keeping related data together.">entry_data</a></code> structure, which includes information about the corresponding <a class="el" href="classfz_1_1Log.html">Log</a> chunk and about the specified <a class="el" href="classfz_1_1Log.html">Log</a> entry. It also makes the in-memory <a class="el" href="classfz_1_1Graph.html">Graph</a> available via pointer.</p>
<p>This function sets the following <code><a class="el" href="structfz_1_1entry__data.html" title="A useful data structure for keeping related data together.">entry_data</a></code> structure variables:</p>
<p>log_ptr Unique_ptr receives and owns a <a class="el" href="classfz_1_1Log.html">Log</a> object. c_newest Receives pointer to corresponding <a class="el" href="classfz_1_1Log__chunk.html" title="Specifies the start time, Node, close time, and set of entries of a Log chunk.">Log_chunk</a> object. c_newest_chunk_t Set to open time (==chunk ID) of corresponding <a class="el" href="classfz_1_1Log.html">Log</a> chunk. is_open True if the corresponding <a class="el" href="classfz_1_1Log.html">Log</a> chunk is open, false otherwise. e_newest Receives pointer to the specified <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> object in the <a class="el" href="classfz_1_1Log.html">Log</a> chunk (as per pre-set newest_minor_id).</p>
<p>Note that the behavior of the call to <code>Log::get_newest_Entry()</code> that sets e_newest is different here than when called on other <a class="el" href="classfz_1_1Log.html">Log</a> intervals. Here, only the last <a class="el" href="classfz_1_1Log.html">Log</a> chunk is loaded from the database, so that there are no entries if that chunk has none. Under other circumstances it would be possible that an empty most recent <a class="el" href="classfz_1_1Log.html">Log</a> chunk would return as newest <a class="el" href="classfz_1_1Log.html">Log</a> entry an object for the last entry in the preceding <a class="el" href="classfz_1_1Log.html">Log</a> chunk.</p>
<p>The <code>edata.newest_minor_id</code> must be set to the enumerator of the <a class="el" href="classfz_1_1Log.html">Log</a> entry within the <a class="el" href="classfz_1_1Log.html">Log</a> chunk specified by <code>chunk_id_str</code>.</p>
<p>Special case: If 'edata.newest_minor_id==0' then the last entry in the <a class="el" href="classfz_1_1Log.html">Log</a> chunk will be returned in 'e_newest' and 'newest_minor_id' (which is then modified by this function).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pa</td><td>A valid initialization object for database access. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk_id_str</td><td>The ID string of a <a class="el" href="classfz_1_1Log.html">Log</a> chunk. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">edata</td><td>A convenient structure for the related data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a542231619261106a93cda6c951047a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542231619261106a93cda6c951047a04">&#9670;&nbsp;</a></span>get_newest_Log_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::get_newest_Log_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1entry__data.html">entry_data</a> &amp;&#160;</td>
          <td class="paramname"><em>edata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the <a class="el" href="classfz_1_1Log.html">Log</a> to find most recent entry points. </p>
<p>The results are returned in an <code><a class="el" href="structfz_1_1entry__data.html" title="A useful data structure for keeping related data together.">entry_data</a></code> structure, which includes information about the most recent <a class="el" href="classfz_1_1Log.html">Log</a> chunk and about the most recent <a class="el" href="classfz_1_1Log.html">Log</a> entry. It also makes the in-memory <a class="el" href="classfz_1_1Graph.html">Graph</a> available via pointer.</p>
<p>This function sets the following <code><a class="el" href="structfz_1_1entry__data.html" title="A useful data structure for keeping related data together.">entry_data</a></code> structure variables:</p>
<p>log_ptr Unique_ptr receives and owns a <a class="el" href="classfz_1_1Log.html">Log</a> object. c_newest Receives pointer to most recent <a class="el" href="classfz_1_1Log__chunk.html" title="Specifies the start time, Node, close time, and set of entries of a Log chunk.">Log_chunk</a> object. It the <a class="el" href="classfz_1_1Log.html">Log</a> is completely empty (a new install) then this is nullptr. c_newest_chunk_t Set to open time (==chunk ID) of most recent <a class="el" href="classfz_1_1Log.html">Log</a> chunk, or <code>RTt_unspecified</code> if there are none. is_open True if the most recent <a class="el" href="classfz_1_1Log.html">Log</a> chunk is open, false otherwise (including when the <a class="el" href="classfz_1_1Log.html">Log</a> is empty). e_newest Receives pointer to the most recent <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> object in the <a class="el" href="classfz_1_1Log.html">Log</a> chunk, nullptr if there is none, which is true both if the <a class="el" href="classfz_1_1Log.html">Log</a> chunk is empty and if the <a class="el" href="classfz_1_1Log.html">Log</a> is empty. newest_minor_id Set to the minor ID of the entry at e_newest, or 0 if there is none.</p>
<p>Note that the behavior of the call to <code>Log::get_newest_Entry()</code> that sets e_newest is different here than when called on other <a class="el" href="classfz_1_1Log.html">Log</a> intervals. Here, only the last <a class="el" href="classfz_1_1Log.html">Log</a> chunk is loaded from the database, so that there are no entries if that chunk has none. Under other circumstances it would be possible that an empty most recent <a class="el" href="classfz_1_1Log.html">Log</a> chunk would return as newest <a class="el" href="classfz_1_1Log.html">Log</a> entry an object for the last entry in the preceding <a class="el" href="classfz_1_1Log.html">Log</a> chunk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pa</td><td>A valid initialization object for database access. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">edata</td><td>A convenient structure for the related data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6879de9cbd1cbf4936df50b67786e959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6879de9cbd1cbf4936df50b67786e959">&#9670;&nbsp;</a></span>get_process_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fz::get_process_status </td>
          <td>(</td>
          <td class="paramtype">pid_t&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get process status from /proc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>Process ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the process is running or sleeping normally, 0 if not found, -1 if error. </dd></dl>

</div>
</div>
<a id="acb11c293fe75898f1b9643466b018e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb11c293fe75898f1b9643466b018e9f">&#9670;&nbsp;</a></span>GET_token_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GET_token_value_vec fz::GET_token_values </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>httpgetstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>argseparator</em> = <code>'&amp;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert portion of a HTTP GET string into a vector of token-value pairs. </p>
<p>Note: For a more complete token-value extraction that includes decoding of %-codes, see the functions in the <code>cgihandler</code> library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">httpgetstr</td><td>A (portion) of an HTTP GET string. </td></tr>
    <tr><td class="paramname">argseparator</td><td>Separator character (normally '&amp;'). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of token-value pairs. </dd></dl>

</div>
</div>
<a id="afe38748c6da4110ea71ee010642d3606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe38748c6da4110ea71ee010642d3606">&#9670;&nbsp;</a></span>get_Topic_pq_field_numbers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::get_Topic_pq_field_numbers </td>
          <td>(</td>
          <td class="paramtype">PGresult *&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve field column numbers for topics query to make sure the correct field numbers are used. </p>
<p>This is an extra safety measure in case formats are changed in the future and in case of potential database version mismatch.</p>
<p>This function updates the field numbers in pq_topic_field. The field names that this version assumes are in the variable pq_topic_fieldnames. The fields are enumerated with pq_Tfields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>a valid pointer obtained by PQgetResult(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all the field names were found. </dd></dl>

</div>
</div>
<a id="a827b8c92cd9a30aeb67974458b5cc0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827b8c92cd9a30aeb67974458b5cc0b6">&#9670;&nbsp;</a></span>Graph_modify_add_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfz_1_1Edge.html">Edge_ptr</a> fz::Graph_modify_add_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>graph_segname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Graphmod__data.html">Graphmod_data</a> &amp;&#160;</td>
          <td class="paramname"><em>gmoddata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classfz_1_1Edge.html">Edge</a> in the <a class="el" href="classfz_1_1Graph.html">Graph</a>'s shared segment and add it to the <a class="el" href="classfz_1_1Graph.html">Graph</a>. </p>
<p>For a detailed description of the process, see the fzgraph README.md. @params graph Must be a valid reference to the <a class="el" href="classfz_1_1Graph.html">Graph</a>. @params graph_segname The name of a shared memory segment containing superiors and dependencies information. @params gmoddata Contains data for the new <a class="el" href="classfz_1_1Edge.html">Edge</a> in an object pointed to by gmoddata.edge_ptr. </p><dl class="section return"><dt>Returns</dt><dd>The pointer to the <a class="el" href="classfz_1_1Edge.html">Edge</a> object that provided requested data is returned upon success. A null pointer otherwise. </dd></dl>

</div>
</div>
<a id="a5539a3a36958457da6b2a29693e8dd6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5539a3a36958457da6b2a29693e8dd6a">&#9670;&nbsp;</a></span>Graph_modify_batch_node_tpassrepeating()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t fz::Graph_modify_batch_node_tpassrepeating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>graph_segname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Graphmod__data.html">Graphmod_data</a> &amp;&#160;</td>
          <td class="paramname"><em>gmoddata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the targetdates of a batch of repeating Nodes past t_pass time. </p>
<p>Updated notes are put into an 'repeating_updated' Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List.</p>
<p>Note that the 'repeating_updated' NNL is modified even if no Nodes were updated. If the number of updated Nodes is zero then the NNL is simply deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A memory-resident <a class="el" href="classfz_1_1Graph.html">Graph</a>. </td></tr>
    <tr><td class="paramname">graph_segname</td><td>The shared memory segment name of the memory-resident <a class="el" href="classfz_1_1Graph.html">Graph</a>. </td></tr>
    <tr><td class="paramname">gmoddata</td><td>A <a class="el" href="classfz_1_1Graph.html">Graph</a> modifications data structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of Nodes modified (and placed in 'repeating_updated'), or -1 for error. </dd></dl>

</div>
</div>
<a id="ac85e6fa77b067a4325f52513f547047c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85e6fa77b067a4325f52513f547047c">&#9670;&nbsp;</a></span>handle_Graph_modifications_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::handle_Graph_modifications_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Graphmod__results.html">Graphmod_results</a> &amp;&#160;</td>
          <td class="paramname"><em>modifications</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process the defined set of possible modifications of <a class="el" href="classfz_1_1Graph.html">Graph</a> data and carry out those modifications in the database. </p>
<p>This is called after modifications have been made in the in-memory <a class="el" href="classfz_1_1Graph.html">Graph</a> data structure. See, for example, how this is used in <code>fzserverpq:handle_request_stack()</code>.</p>
<p>Note: For development information about the proposed set of possible modifications, see <a href="https://trello.com/c/FxSP8If8">https://trello.com/c/FxSP8If8</a>.</p>
<p>For more information about the complete path involved in modifications, see <a href="https://trello.com/c/eUjjF1yZ">https://trello.com/c/eUjjF1yZ</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A valid <a class="el" href="classfz_1_1Graph.html">Graph</a> structure that contains modified data. </td></tr>
    <tr><td class="paramname">dbname</td><td>The Postgres database name. </td></tr>
    <tr><td class="paramname">schemaname</td><td>The Postgres schema name for Formalizer data. </td></tr>
    <tr><td class="paramname">modifications</td><td>A data structure detailing modifications to apply.</td></tr>
  </table>
  </dd>
</dl>
<p>This is called after modifications have been made in the in-memory <a class="el" href="classfz_1_1Graph.html">Graph</a> data structure. See, for example, how this is used in <code>fzserverpq:handle_request_stack()</code>.</p>
<p>Note: For development information about the proposed set of possible modifications, see <a href="https://trello.com/c/FxSP8If8">https://trello.com/c/FxSP8If8</a>.</p>
<p>For more information about the complete path involved in modifications, see <a href="https://trello.com/c/eUjjF1yZ">https://trello.com/c/eUjjF1yZ</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A valid <a class="el" href="classfz_1_1Graph.html">Graph</a> structure that contains modified data. </td></tr>
    <tr><td class="paramname">dbname</td><td>The Postgres database name. </td></tr>
    <tr><td class="paramname">schemaname</td><td>The Postgres schema name for Formalizer data. </td></tr>
    <tr><td class="paramname"><a class="el" href="structfz_1_1Graphmod__results.html" title="This is the results object that manages the collection of results for all requests on the stack.">Graphmod_results</a></td><td>A data structure detailing modifications to apply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28b2010b68d787bc1f202bb9c0402822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b2010b68d787bc1f202bb9c0402822">&#9670;&nbsp;</a></span>handle_Graph_modifications_unshared_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::handle_Graph_modifications_unshared_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Graphmod__unshared__results.html">Graphmod_unshared_results</a> &amp;&#160;</td>
          <td class="paramname"><em>modifications</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process the defined set of possible modifications of <a class="el" href="classfz_1_1Graph.html">Graph</a> data and carry out those modifications in the database. </p>
<p>This version of the call does not use shared memory.</p>
<p>This is called after modifications have been made in the in-memory <a class="el" href="classfz_1_1Graph.html">Graph</a> data structure. See, for example, how this is used in <code>fzserverpq:handle_request_stack()</code>.</p>
<p>Note: For development information about the proposed set of possible modifications, see <a href="https://trello.com/c/FxSP8If8">https://trello.com/c/FxSP8If8</a>.</p>
<p>For more information about the complete path involved in modifications, see <a href="https://trello.com/c/eUjjF1yZ">https://trello.com/c/eUjjF1yZ</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A valid <a class="el" href="classfz_1_1Graph.html">Graph</a> structure that contains modified data. </td></tr>
    <tr><td class="paramname">dbname</td><td>The Postgres database name. </td></tr>
    <tr><td class="paramname">schemaname</td><td>The Postgres schema name for Formalizer data. </td></tr>
    <tr><td class="paramname">modifications</td><td>A data structure detailing modifications to apply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab205a2fcc8d2839e75a2a426c201bfca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab205a2fcc8d2839e75a2a426c201bfca">&#9670;&nbsp;</a></span>handle_one_modification_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::handle_one_modification_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>schemaname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NNLmod_update_set &amp;&#160;</td>
          <td class="paramname"><em>nnlupdates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Graphmod__result.html">Graphmod_result</a> &amp;&#160;</td>
          <td class="paramname"><em>change_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret the type of modification that was carried out in one <a class="el" href="structfz_1_1Graphmod__result.html" title="This is the data structure used by the server to return information about the successful results of a...">Graphmod_result</a> object. </p>
<p>Call the corresponding database update function.</p>
<p>This is called both from functions that use shared memory and those that do not, i.e. from <a class="el" href="namespacefz.html#ac85e6fa77b067a4325f52513f547047c" title="Process the defined set of possible modifications of Graph data and carry out those modifications in ...">handle_Graph_modifications_pq()</a> and from <a class="el" href="namespacefz.html#a28b2010b68d787bc1f202bb9c0402822" title="Process the defined set of possible modifications of Graph data and carry out those modifications in ...">handle_Graph_modifications_unshared_pq()</a>. In this manner, the same process is used from fzserverpq calls that communicate through shared memory and those that communicate through the FZ TCP API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A valid <a class="el" href="classfz_1_1Graph.html">Graph</a> structure that contains modified data. </td></tr>
    <tr><td class="paramname">conn</td><td>An active connection to the database. </td></tr>
    <tr><td class="paramname">schemaname</td><td>The Postgres schema name for Formalizer data. </td></tr>
    <tr><td class="paramname">nnlupdates</td><td>A set of NNL updates. </td></tr>
    <tr><td class="paramname">change_data</td><td>A valid <a class="el" href="structfz_1_1Graphmod__result.html" title="This is the data structure used by the server to return information about the successful results of a...">Graphmod_result</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful. </dd></dl>

</div>
</div>
<a id="a569da80848b8001bc12867337f51d1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569da80848b8001bc12867337f51d1c9">&#9670;&nbsp;</a></span>identical_Graphs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::identical_Graphs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>trace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two Graphs to report if they are data-identical. </p>
<p>friend (utility) functions</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph1</td><td>the first <a class="el" href="classfz_1_1Graph.html">Graph</a>. </td></tr>
    <tr><td class="paramname">graph2</td><td>the second <a class="el" href="classfz_1_1Graph.html">Graph</a>. </td></tr>
    <tr><td class="paramname">trace</td><td>if a difference is found then this contains a trace. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two Graphs are equivalent. </dd></dl>

</div>
</div>
<a id="a96f4dc710aff55f6fd9c2e111d7df259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f4dc710aff55f6fd9c2e111d7df259">&#9670;&nbsp;</a></span>identical_Nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::identical_Nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>trace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if two <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> objects contain the same data. </p>
<p>Note that this does not compare the rapid-access Edges_Set supedges and depedges, since they are sets of pointers created as <a class="el" href="classfz_1_1Graph.html">Graph</a> Edges are added. They might end up in a different order, but they ought to be the same ones as in the Edge_Map. </p>

</div>
</div>
<a id="a5ae4b124721a2a2a59d23b208ddc5e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae4b124721a2a2a59d23b208ddc5e61">&#9670;&nbsp;</a></span>Init_Named_Node_Lists_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::Init_Named_Node_Lists_pq </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Postgres storage of Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> Lists: </p>
<p>The current implementation is meant to be easy and not error prone. All Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> Lists are kept in the same table to avoid having to find tables or strays if there is any desynchronization. Also, any modification of a Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List updates that entire stored List. This way, the Postgres function does not need to know or care about exactly which element of a list (which can contain multiple copies of the same <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> ID) was added or removed. The Postgres stored version is simply made to reflect the state of the in-memory List.</p>
<p>This is probably not the most rapid implementation. If the Formalizer ever ends up carrying out many List manipulations for large Lists then it may be worthwhile to reimplement in a manner where only carefully indicated individual elements are updated.</p>
<ul>
<li>The 'NamedNodeLists' table contains all Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> Lists, each one is a table row.</li>
<li>Each row specifies the name of the List, a features code (yet to be utilized), and then an array that holds all <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> IDs.</li>
</ul>
<p>Supported operations are:</p><ul>
<li>Initialize NamedNodeLists (deletes existing and starts fresh).</li>
<li>Update a List (creates or replaces a row with new content).</li>
<li>Delete a List (removes a row). Initialize the NamedNodeLists table.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dbname</td><td>Database name. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if initialized successfully. </dd></dl>

</div>
</div>
<a id="a5007b00e853ca6197ecbda5704c1642e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5007b00e853ca6197ecbda5704c1642e">&#9670;&nbsp;</a></span>is_json_comment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::is_json_comment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>keylabel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify json key labels that are actually comments. </p>
<p>E.g. see how this is used in config.cpp. </p>

</div>
</div>
<a id="a30be49d20ac6c8ba1b313fc295a235a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30be49d20ac6c8ba1b313fc295a235a2">&#9670;&nbsp;</a></span>is_leapyear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::is_leapyear </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>year</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A simple leap year test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">year</td><td>the year. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it is a leap year. </dd></dl>

</div>
</div>
<a id="ab58aac8e7a504103a1f9fd7f005f4a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58aac8e7a504103a1f9fd7f005f4a35">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::join </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>svec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Efficient concatenation of strings from vector of strings with optional delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">svec</td><td>Vector of strings. </td></tr>
    <tr><td class="paramname">delim</td><td>Optional delimiter string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string composed of all strings in the vector, each separated by the delimiter. </dd></dl>

</div>
</div>
<a id="a436d3fb0b87afd17f5c45ff0e50145fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436d3fb0b87afd17f5c45ff0e50145fe">&#9670;&nbsp;</a></span>json_get_label_value_pairs_from_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">jsonlite_label_value_pairs fz::json_get_label_value_pairs_from_string </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>jsoncontentstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string containing JSON subset content into a map of parameter label-value pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jsoncontentstr</td><td>A string in JSON subset format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map in jsonlite_label_value_pairs format. </dd></dl>

</div>
</div>
<a id="a615f67507873ff02f050b57a562b028d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615f67507873ff02f050b57a562b028d">&#9670;&nbsp;</a></span>json_get_param_value_lines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">jsonlite_lines fz::json_get_param_value_lines </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>configcontentstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the content of a JSON subset string into a vector of '"parameter" : "value"' statement strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">configcontentstr</td><td>A string in the JSON subset format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of strings, each of which contains a parameter-value statement. </dd></dl>

</div>
</div>
<a id="aec59f006cec171ddbb6e0fc0c91b6312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec59f006cec171ddbb6e0fc0c91b6312">&#9670;&nbsp;</a></span>json_label_value_pairs_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::json_label_value_pairs_to_string </td>
          <td>(</td>
          <td class="paramtype">const jsonlite_label_value_pairs &amp;&#160;</td>
          <td class="paramname"><em>labelvaluepairs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert JSON subset label-value pairs into a JSON content string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">labelvaluepairs</td><td>A map in jsonlite_label_value_pairs format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing the JSON content.</dd></dl>
<p>This conversion automatically skips any empty labels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">labelvaluepairs</td><td>A map in jsonlite_label_value_pairs format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing the JSON content. </dd></dl>

</div>
</div>
<a id="a6128b734ed961d522923052e768e200b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6128b734ed961d522923052e768e200b">&#9670;&nbsp;</a></span>json_param_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">jsonlite_label_value_pair fz::json_param_value </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>par_value_pair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract parameter label and parameter value from a content line. </p>
<p>A line typically has this format: '"somelabel" : "somevalue"'</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">par_value_pair</td><td>A string in the expected format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of strings representing the parameter and the value.</dd></dl>
<p>A line typically has this format: '"somelabel" : "somevalue"'</p>
<p>Note that JSON does not support comments as such. To add comments simply add some data such as '"__comment1__" : "This is a comment."'.</p>
<p>And to deactivate a configuration option, just turn the variable key into a comment.</p>
<p>Important assumptions:</p>
<ul>
<li>The value is a double-quotes enclosed string. (This function does not read other JSON value types directly. *** It is quite easy to add a function that does. Just grab everything after the colon, drop possible comma at end, strip whitespace on both ends of the value. Then identify its type and parse.)</li>
<li>The parameter label does not contain double quotes.</li>
<li>A colon and any amount of whitespace separates label and value.</li>
<li>The value can contain double quotes.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">par_value_pair</td><td>A string in the expected format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of strings representing the parameter and the value. </dd></dl>

</div>
</div>
<a id="af3be8dc4c8df2ffff30795e117a2a007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3be8dc4c8df2ffff30795e117a2a007">&#9670;&nbsp;</a></span>json_post_process_valuestring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::json_post_process_valuestring </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rawstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post-process the raw value string extracted from a JSON structure. </p>
<p>Note: At the moment all this does is post-process string-type values to convert escaped double quotes to regular double quotes.</p>
<p>*** This can be extended to identify and evaluate multiple value types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rawstr</td><td>Reference to the raw value string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Processed value string. </dd></dl>

</div>
</div>
<a id="a2debd26aeea489a11f6f3efb25b28572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2debd26aeea489a11f6f3efb25b28572">&#9670;&nbsp;</a></span>keyrel_from_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Topic_KeyRel_Vector fz::keyrel_from_pq </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>keywordstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>relevancestr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert textual arrays of keywords and keyword-relevance values to a vector of <a class="el" href="structfz_1_1Topic__Keyword.html">Topic_Keyword</a> pairs. </p>
<p>Keywords are allowed to contain more than one word, separated by spaces. This function strips away the front and back double-quotes that the PGgetvalue() function returns around such composite keywords.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keywordstr</td><td>string containing the textual array of keywords. </td></tr>
    <tr><td class="paramname">relevancestr</td><td>string containing the textual array of relevance values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of <a class="el" href="structfz_1_1Topic__Keyword.html">Topic_Keyword</a> pairs of (keyword,relevance). </dd></dl>

</div>
</div>
<a id="aef824584d56abd3b06028a3925a9541c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef824584d56abd3b06028a3925a9541c">&#9670;&nbsp;</a></span>load_Edge_parameter_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; fz::load_Edge_parameter_interval </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pq_Efields&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>from_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>num_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load specific <a class="el" href="classfz_1_1Edge.html">Edge</a> parameter column interval from PostgreSQL database. </p>
<p>This interface attempts to hide as much as possible about the Postgres specifics of the operation, in order to preserve a Formalizer database access protocol across different possible underlying database choices.</p>
<p>Note: For this reason, the lowest possible interval start is 0 (not 1, as per SQL row numbering convention).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dbname</td><td>the Postgres database. </td></tr>
    <tr><td class="paramname">schemaname</td><td>the Formalizer schema name (usually provided by Graph_access::pq_schemaname) </td></tr>
    <tr><td class="paramname">param</td><td>the enumerated parameter identifier. </td></tr>
    <tr><td class="paramname">from_row</td><td>the first row in the interval, counting from 0. </td></tr>
    <tr><td class="paramname">num_rows</td><td>the number of rows in the intervial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector with string elements, one for each row. </dd></dl>

</div>
</div>
<a id="a615c9833189de86268653cf1fc95f092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615c9833189de86268653cf1fc95f092">&#9670;&nbsp;</a></span>load_Graph_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::load_Graph_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load all the Nodes, Edges and Topics of the <a class="el" href="classfz_1_1Graph.html">Graph</a> from the PostgreSQL database. </p>
<p>Note: If the <code>graph</code> is initialized with <code>persistent_NNL == true</code> then this will also call <code><a class="el" href="namespacefz.html#a3b1472e23f0f82663c96212be38c02ba" title="Load Named Node Lists into memory-resident cache.">load_Named_Node_Lists_pq()</a></code>. See for example how this is used in <code>Graphaccess::request_Graph_copy()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>a <a class="el" href="classfz_1_1Graph.html">Graph</a> for the Nodes and Edges, etc, typically empty. </td></tr>
    <tr><td class="paramname">dbname</td><td>database name. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classfz_1_1Graph.html">Graph</a> was successfully loaded from the database. </dd></dl>

</div>
</div>
<a id="a0fc58c8f8b64e771f86e4e90d1b63da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc58c8f8b64e771f86e4e90d1b63da1">&#9670;&nbsp;</a></span>load_last_chunk_and_entry_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::load_last_chunk_and_entry_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the last <a class="el" href="classfz_1_1Log.html">Log</a> chunk and last <a class="el" href="classfz_1_1Log.html">Log</a> entry in the table. </p>
<p>This function uses a <code><a class="el" href="structfz_1_1Log__filter.html" title="Filter structure used to set up selective Log reading.">Log_filter</a></code> that specifies end-to-front reading limited to 1 chunk and calls <code><a class="el" href="namespacefz.html#a87cb582cc69257b4d2a364f7da5f47c0" title="Load the Log chunks and Log entries that satisfy a specific filter.">load_partial_Log_pq()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>A <a class="el" href="classfz_1_1Log.html">Log</a> for the Chunks and Entries, can be empty or may be added to. </td></tr>
    <tr><td class="paramname">pa</td><td>Access object with database name and schema name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the last chunk and last entry were successfully loaded from the database. </dd></dl>

</div>
</div>
<a id="a5688f3a5a5bb5066690ccff97430eaaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5688f3a5a5bb5066690ccff97430eaaa">&#9670;&nbsp;</a></span>load_Log_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::load_Log_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the full <a class="el" href="classfz_1_1Log.html">Log</a> with all <a class="el" href="classfz_1_1Log.html">Log</a> chunks, <a class="el" href="classfz_1_1Log.html">Log</a> entries and Breakpoints from the PostgresSQL database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>a <a class="el" href="classfz_1_1Log.html">Log</a> for the Chunks, Entries and Breakpoints, typically empty. </td></tr>
    <tr><td class="paramname">pa</td><td>access object with database name and schema name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classfz_1_1Log.html">Log</a> was succesfully loaded from the database. </dd></dl>

</div>
</div>
<a id="a3b1472e23f0f82663c96212be38c02ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1472e23f0f82663c96212be38c02ba">&#9670;&nbsp;</a></span>load_Named_Node_Lists_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::load_Named_Node_Lists_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> Lists into memory-resident cache. </p>
<p>Note: This deletes any Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> Lists data that was already in the <a class="el" href="classfz_1_1Graph.html">Graph</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td><a class="el" href="classfz_1_1Graph.html">Graph</a> that will contain the Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> Lists. </td></tr>
    <tr><td class="paramname">dbname</td><td>Database name. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfully loaded. </dd></dl>

</div>
</div>
<a id="a9cd0122917acf4a863edde0051f01600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd0122917acf4a863edde0051f01600">&#9670;&nbsp;</a></span>load_Node_history_cache_entry_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::load_Node_history_cache_entry_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;&#160;</td>
          <td class="paramname"><em>apq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a> &amp;&#160;</td>
          <td class="paramname"><em>nkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Node__history.html">Node_history</a> &amp;&#160;</td>
          <td class="paramname"><em>nodehist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the cached <a class="el" href="classfz_1_1Log.html">Log</a> history of a specific <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">apq</td><td>Access object with database name and schema name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nkey</td><td>A <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> ID key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodehist</td><td>A <a class="el" href="structfz_1_1Node__history.html" title="Log history by Node expressed as a list of Log chunks and a list of Log entries for each Node for whi...">Node_history</a> object that receives the resulting data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af54c18b69cccab6a8254eab47bdcc1f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54c18b69cccab6a8254eab47bdcc1f9">&#9670;&nbsp;</a></span>load_Node_history_cache_table_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::load_Node_history_cache_table_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node__histories.html">Node_histories</a> &amp;&#160;</td>
          <td class="paramname"><em>nodehistories</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a <a class="el" href="classfz_1_1Node__histories.html" title="These Node histories are generated (and cached) in a manner where the set of chunks lists only those ...">Node_histories</a> object from a complete cache table in the database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pa</td><td>Access object with valid database and schema identifiers. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodehistories</td><td>A <a class="el" href="classfz_1_1Node__histories.html" title="These Node histories are generated (and cached) in a manner where the set of chunks lists only those ...">Node_histories</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if cache table loading was successful. </dd></dl>

</div>
</div>
<a id="ab1a495d238d3b9443ea475cecdfb126d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a495d238d3b9443ea475cecdfb126d">&#9670;&nbsp;</a></span>load_Node_history_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::load_Node_history_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;&#160;</td>
          <td class="paramname"><em>apq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Log__filter.html">Log_filter</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>chunkwherestr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>entrywherestr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get lists of <a class="el" href="classfz_1_1Log.html">Log</a> chunks and <a class="el" href="classfz_1_1Log.html">Log</a> entries from the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> history cache table and load all of the chunks and entries listed there into a <a class="el" href="classfz_1_1Log.html">Log</a> object. </p>
<p>This function is called by <code><a class="el" href="namespacefz.html#a87cb582cc69257b4d2a364f7da5f47c0" title="Load the Log chunks and Log entries that satisfy a specific filter.">load_partial_Log_pq()</a></code> if the filter specifies a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>.</p>
<p>Note that the history cache reflects a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>'s actual chain of chunks and entries. This does NOT include chunks that belong to other Nodes, even if those chunks contain entries that belong to this node. Consequently, IF the presentation of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> history should include only complete chunks then chunks and extra entries need to be added to the history.</p>
<p>The entries to load are derived by SUBSTRING from chunk IDs. That takes care of loading all entries in the chunks within a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>'s history. Separately, and in advance, entries that are not within Node-owned chunks need to be identified and the corresponding chunks added to the set-to-load.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apq</td><td>Access object with database name and schema name. </td></tr>
    <tr><td class="paramname">log</td><td><a class="el" href="classfz_1_1Log.html">Log</a> object where Chunks and Entries are added. </td></tr>
    <tr><td class="paramname">filter</td><td>A <a class="el" href="structfz_1_1Log__filter.html" title="Filter structure used to set up selective Log reading.">Log_filter</a> structure where at least the nkey is specified. </td></tr>
    <tr><td class="paramname">chunkwherestr</td><td>A prepared PQ WHERE string specifying <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> and possibly time interval. </td></tr>
    <tr><td class="paramname">entrywherestr</td><td>A prepared PQ WHERE string specifying <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfully loaded into <a class="el" href="classfz_1_1Log.html">Log</a>. </dd></dl>

</div>
</div>
<a id="ad24f78e052197d9844de69ba284cfade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24f78e052197d9844de69ba284cfade">&#9670;&nbsp;</a></span>load_Node_parameter_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; fz::load_Node_parameter_interval </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pq_Nfields&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>from_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>num_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load specific <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> parameter column interval from PostgreSQL database. </p>
<p>This interface attempts to hide as much as possible about the Postgres specifics of the operation, in order to preserve a Formalizer database access protocol across different possible underlying database choices.</p>
<p>Note: For this reason, the lowest possible interval start is 0 (not 1, as per SQL row numbering convention).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dbname</td><td>the Postgres database. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
    <tr><td class="paramname">param</td><td>the enumerated parameter identifier. </td></tr>
    <tr><td class="paramname">from_row</td><td>the first row in the interval, counting from 0. </td></tr>
    <tr><td class="paramname">num_rows</td><td>the number of rows in the intervial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector with string elements, one for each row. </dd></dl>

</div>
</div>
<a id="a87cb582cc69257b4d2a364f7da5f47c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87cb582cc69257b4d2a364f7da5f47c0">&#9670;&nbsp;</a></span>load_partial_Log_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::load_partial_Log_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Log__filter.html">Log_filter</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the <a class="el" href="classfz_1_1Log.html">Log</a> chunks and <a class="el" href="classfz_1_1Log.html">Log</a> entries that satisfy a specific filter. </p>
<p>The filter may specify a time interval and may specify a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> to which the <a class="el" href="classfz_1_1Log.html">Log</a> chunks and <a class="el" href="classfz_1_1Log.html">Log</a> entries must belong. The filter can also specify a limit on the number of <a class="el" href="classfz_1_1Log.html">Log</a> chunks to load, and it can specify loading back-to-front (i.e. from latest to earliest).</p>
<p>Note: Presently, using a limit or back-to-front does not (yet) work with a specified <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>.</p>
<p>Examples:</p><ul>
<li>t_from is set, limit&gt;0 : read n chunks from t_from</li>
<li>limit&gt;0, back_to_front: read n chunks from end of <a class="el" href="classfz_1_1Log.html">Log</a></li>
<li>t_from and t_to are set: read all chunks in [t_from, t_to]</li>
<li>nkey is set: read onlny chunks belonging to <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a></li>
<li>limit&gt;0: read n chunks from beginning of <a class="el" href="classfz_1_1Log.html">Log</a></li>
<li>t_to is set, limit&gt;0: read n chunks before and including t_to</li>
</ul>
<p>This can also be used by smart on-demand <a class="el" href="classfz_1_1Log.html">Log</a> caching modes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>A <a class="el" href="classfz_1_1Log.html">Log</a> for the Chunks and Entries, can be empty or may be added to. </td></tr>
    <tr><td class="paramname">pa</td><td>Access object with database name and schema name. </td></tr>
    <tr><td class="paramname">filter</td><td>A selective <a class="el" href="classfz_1_1Log.html">Log</a> reading filter structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classfz_1_1Log.html">Log</a> was succesfully loaded from the database. </dd></dl>

</div>
</div>
<a id="ab99ee1f9eb33cd43975a1e2ba185affc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99ee1f9eb33cd43975a1e2ba185affc">&#9670;&nbsp;</a></span>Log_span_in_days()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double fz::Log_span_in_days </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report the span in days from when the <a class="el" href="classfz_1_1Log.html">Log</a> was started (first cunk) to its most recent chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>the <a class="el" href="classfz_1_1Log.html">Log</a> for which to report the span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the decimal number of days. </dd></dl>

</div>
</div>
<a id="a99de56e900ef8f39ac539d88521905ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99de56e900ef8f39ac539d88521905ab">&#9670;&nbsp;</a></span>Log_span_in_seconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long fz::Log_span_in_seconds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report the span in seconds from when the <a class="el" href="classfz_1_1Log.html">Log</a> was started (first cunk) to its most recent chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>the <a class="el" href="classfz_1_1Log.html">Log</a> for which to report the span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of seconds. </dd></dl>

</div>
</div>
<a id="ac852c19de9635df74fca9eab2d419e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac852c19de9635df74fca9eab2d419e5b">&#9670;&nbsp;</a></span>Log_span_years_months_days()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ymd_tuple fz::Log_span_years_months_days </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report the span in years, months and days from when the <a class="el" href="classfz_1_1Log.html">Log</a> was started (first cunk) to its most recent chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>the <a class="el" href="classfz_1_1Log.html">Log</a> for which to report the span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple of [year, month, day]. </dd></dl>

</div>
</div>
<a id="a6f5b51cf9b3ad61ff50bdc19ff635d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5b51cf9b3ad61ff50bdc19ff635d33">&#9670;&nbsp;</a></span>lowercase_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::lowercase_equal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lowermatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_at</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a lower case match string with part of a content string in any combination of lower and upper case characters. </p>
<p>This is handy when checking for HTML tags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lowermatch</td><td>A lower case string that must be matched. </td></tr>
    <tr><td class="paramname">content</td><td>A string containing HTML text and tags. </td></tr>
    <tr><td class="paramname">start_at</td><td>Location within content string at which to start matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is a complete match. </dd></dl>

</div>
</div>
<a id="a6aae98945caac45aa7d78a74a5e90d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aae98945caac45aa7d78a74a5e90d8d">&#9670;&nbsp;</a></span>lowercase_match_skipping_spaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::lowercase_match_skipping_spaces </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>match_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_at</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>url_start_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a multi-part lower case match string with possible space or tab separated components with part of a content string in any combination of lower and upper case characters. </p>
<p>For example, use this to check for a 'a href="' tag specialization.</p>
<p>Note: If the multi-part match must contain a space between two parts then that space must be included in one of the specified parts, e.g. "a " in the example above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">match_vec</td><td>Vector of lower case strings that must be matched. </td></tr>
    <tr><td class="paramname">content</td><td>A string containing HTML text and tags. </td></tr>
    <tr><td class="paramname">start_at</td><td>Location within content string at which to start matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is a complete match. </dd></dl>

</div>
</div>
<a id="afd5ff5bae87c93c494f719806115accc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5ff5bae87c93c494f719806115accc">&#9670;&nbsp;</a></span>ltrim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; fz::ltrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>t</em> = <code>&quot;&#160;\t\n\r\f\v&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim whitespace from the front of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a string. </td></tr>
    <tr><td class="paramname">t</td><td>a string containing whitespace characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the trimmed string. </dd></dl>

</div>
</div>
<a id="a1668a3b60e6b48e973fd195aff3e3de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1668a3b60e6b48e973fd195aff3e3de9">&#9670;&nbsp;</a></span>main_topic() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfz_1_1Topic.html">Topic</a>* fz::main_topic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Topic__Tags.html">Topic_Tags</a> &amp;&#160;</td>
          <td class="paramname"><em>topictags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the main <a class="el" href="classfz_1_1Topic.html">Topic</a> of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>, as indicated by the maximum Topic_Relevance value. </p>
<p>friend (utility) functions</p>
<p>Note: This is a friend function in order to ensure that the search for the <a class="el" href="classfz_1_1Topic.html">Topic</a> object is called only when a valid <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, arranged by integer Index-ID.">Topic_Tags</a> list can provid pointers to them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, arranged by integer Index-ID.">Topic_Tags</a></td><td>a valid <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, arranged by integer Index-ID.">Topic_Tags</a> list. </td></tr>
    <tr><td class="paramname">node</td><td>a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> for which the main <a class="el" href="classfz_1_1Topic.html">Topic</a> is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="classfz_1_1Topic.html">Topic</a> object (or nullptr if not found). </dd></dl>

</div>
</div>
<a id="ae2022e10fe1d991308d72fcec1a286b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2022e10fe1d991308d72fcec1a286b3">&#9670;&nbsp;</a></span>main_topic() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfz_1_1Topic.html">Topic</a> * fz::main_topic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &amp;&#160;</td>
          <td class="paramname"><em>chunk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the main <a class="el" href="classfz_1_1Topic.html">Topic</a> of a <a class="el" href="classfz_1_1Log.html">Log</a> chunk's <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>, as indicated by the maximum Topic_Relevance value. </p>
<p>friend (utility) functions</p>
<p>Note: This is a friend function in order to ensure that the search for the <a class="el" href="classfz_1_1Topic.html">Topic</a> object is called only when a valid <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, arranged by integer Index-ID.">Topic_Tags</a> list can provid pointers to them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_graph</td><td>a valid <a class="el" href="classfz_1_1Graph.html">Graph</a> with <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, arranged by integer Index-ID.">Topic_Tags</a> list. </td></tr>
    <tr><td class="paramname">chunk</td><td>a <a class="el" href="classfz_1_1Log__chunk.html" title="Specifies the start time, Node, close time, and set of entries of a Log chunk.">Log_chunk</a> for which the main <a class="el" href="classfz_1_1Topic.html">Topic</a> is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="classfz_1_1Topic.html">Topic</a> object (or nullptr if not found). </dd></dl>

</div>
</div>
<a id="aa142fcdccbb8510c806f415ef6559e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa142fcdccbb8510c806f415ef6559e93">&#9670;&nbsp;</a></span>main_topic() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfz_1_1Topic.html">Topic</a> * fz::main_topic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the main <a class="el" href="classfz_1_1Topic.html">Topic</a> of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>, as indicated by the maximum Topic_Relevance value. </p>
<p>Note: This is a friend function in order to ensure that the search for the <a class="el" href="classfz_1_1Topic.html">Topic</a> object is called only when a valid <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, arranged by integer Index-ID.">Topic_Tags</a> list that is known to a valid <a class="el" href="classfz_1_1Graph.html">Graph</a> can provid pointers to them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_graph</td><td>a valid <a class="el" href="classfz_1_1Graph.html">Graph</a> that has a <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, arranged by integer Index-ID.">Topic_Tags</a> list. </td></tr>
    <tr><td class="paramname">node</td><td>a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> for which the main <a class="el" href="classfz_1_1Topic.html">Topic</a> is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="classfz_1_1Topic.html">Topic</a> object (or nullptr if not found). </dd></dl>

</div>
</div>
<a id="af70525212cc7a8fff346a1540c8c8f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70525212cc7a8fff346a1540c8c8f8a">&#9670;&nbsp;</a></span>main_topic() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfz_1_1Topic.html">Topic</a>* fz::main_topic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Topic__Tags.html">Topic_Tags</a> &amp;&#160;</td>
          <td class="paramname"><em>topictags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the main <a class="el" href="classfz_1_1Topic.html">Topic</a> of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>, as indicated by the maximum Topic_Relevance value. </p>
<p>friend (utility) functions</p>
<p>Note: This is a friend function in order to ensure that the search for the <a class="el" href="classfz_1_1Topic.html">Topic</a> object is called only when a valid <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, arranged by integer Index-ID.">Topic_Tags</a> list can provid pointers to them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, arranged by integer Index-ID.">Topic_Tags</a></td><td>a valid <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, arranged by integer Index-ID.">Topic_Tags</a> list. </td></tr>
    <tr><td class="paramname">node</td><td>a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> for which the main <a class="el" href="classfz_1_1Topic.html">Topic</a> is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="classfz_1_1Topic.html">Topic</a> object (or nullptr if not found). </dd></dl>

</div>
</div>
<a id="a487b4b2d73b7195c20bac646e588483e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487b4b2d73b7195c20bac646e588483e">&#9670;&nbsp;</a></span>make_button()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::make_button </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>samepage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make HTML code for a link button. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>A link to open when the button is pressed. </td></tr>
    <tr><td class="paramname">label</td><td>The label to put on the button. </td></tr>
    <tr><td class="paramname">samepage</td><td>If true then the link is opened in the same browser page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HTML code string to embed. </dd></dl>

</div>
</div>
<a id="a6e85b9d67d3d04d7c5bc2ae623e416c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e85b9d67d3d04d7c5bc2ae623e416c4">&#9670;&nbsp;</a></span>make_embeddable_html()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::make_embeddable_html </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>htmlstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">text_interpretation&#160;</td>
          <td class="paramname"><em>interpretation</em> = <code>text_interpretation::raw</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>special_urls</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>replacements</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Efficiently and reliably filter snippets of HTML text such that they become optimally embeddable within other HTML. </p>
<p>The <code>interpretation</code> parameter is a collection of flags defined in the <code>text_interpretation</code> enum (see above). This can be used to request additional transformations of the raw text. For example, you can detect URL links that were not surrounded by HREF code using the <code>detect_links</code> flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">htmlstr</td><td>A string in HTML format. </td></tr>
    <tr><td class="paramname">detect_links</td><td>If true then convert recognized data into links. </td></tr>
    <tr><td class="paramname">special_urls</td><td>An optional pointer to a list of special URL indicators to look for (e.g. @FZSERVER@). </td></tr>
    <tr><td class="paramname">replacements</td><td>Pointer to list of replacement URLs to insert where a special URL occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string of embeddable HTML.</dd></dl>
<p>With the <code>detect_links</code> option, this filter also detects interesting information that would be improved if presented as a link and adds such a link.</p>
<p>See the comment above the <a class="el" href="namespacefz.html#afbbbb262820388617f57a0881e141c6e" title="This tokenizes, i.e.">convert_special_data_html()</a> function for more details and options. That type of conversion is not applied to content between <a href="">and </a> tags, because that would lead to possible links within links.</p>
<p>WARNING: The 'full_markdown' text_interpretation option is not yet supported!</p>
<p>***TODO: It might be ideal to replace this function with one that starts by fully tokenizing the htmlstr, by filling a vector with pieces, each found by using a set of delimiters "\t\n\r\f\v.:/[]!(),;", saving the delimited content and the delimiters, then walking through the vector item by item to construct a new string, while entering conversion modes as prescribed by each item or delimiter. This could be the most versatile, intelligent, and yet fast method. It may also be fine to apply this tokenization-first method just to the non-html-token content that is sent to <a class="el" href="namespacefz.html#afbbbb262820388617f57a0881e141c6e" title="This tokenizes, i.e.">convert_special_data_html()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">htmlstr</td><td>A string in HTML format. </td></tr>
    <tr><td class="paramname">interpretation</td><td>A bit-pattern of flags used in text interpretation with options: detect_links, emptyline_is_par, full_markdown. </td></tr>
    <tr><td class="paramname">special_urls</td><td>Optional list of special URL components, such as @FZSERVER@ that are automatically replaced. </td></tr>
    <tr><td class="paramname">replacements</td><td>Optional list of replacements to use for special URL components. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string of embeddable HTML. </dd></dl>

</div>
</div>
<a id="abdd43dd007911040fd9782a1130ed653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd43dd007911040fd9782a1130ed653">&#9670;&nbsp;</a></span>mimetype_by_extension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; fz::mimetype_by_extension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a MIME type string reference that corresponds with the extension of a file path. </p>
<p>Note: This function does not 'sniff' the file content to determine if the extension correctly points out the MIME type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_path</td><td>The path to a file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MIME type string reference. </dd></dl>

</div>
</div>
<a id="a78f0023444dc67285cc9a602d1d5c10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f0023444dc67285cc9a602d1d5c10c">&#9670;&nbsp;</a></span>modify_Log_chunk_id_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::modify_Log_chunk_id_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &amp;&#160;</td>
          <td class="paramname"><em>chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>new_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change Chunk Open time, i.e. </p>
<p>the <a class="el" href="classfz_1_1Log.html">Log</a> chunk ID. The chunk must already exist within a table in schema of PostgreSQL database.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk</td><td>A valid <a class="el" href="classfz_1_1Log.html">Log</a> chunk object. </td></tr>
    <tr><td class="paramname">new_id</td><td>A new open time that will also be the new ID. </td></tr>
    <tr><td class="paramname">pa</td><td>Access object with database name and Formalizer schema name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classfz_1_1Log.html">Log</a> chunk was successfully updated. </dd></dl>

</div>
</div>
<a id="ab9606435e254ac48f610d6005aa10b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9606435e254ac48f610d6005aa10b2e">&#9670;&nbsp;</a></span>modify_Log_chunk_nid_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::modify_Log_chunk_nid_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> &amp;&#160;</td>
          <td class="paramname"><em>chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> to which the Chunk specified belongs. </p>
<p>The chunk must already exist within a table in schema of PostgreSQL database.</p>
<p>Note:</p><ul>
<li>After changing Chunk ownership the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> histories cache should be refreshed.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk</td><td>A valid <a class="el" href="classfz_1_1Log.html">Log</a> chunk object with the updated node_id. </td></tr>
    <tr><td class="paramname">pa</td><td>Access object with database name and Formalizer schema name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classfz_1_1Log.html">Log</a> chunk nid was successfully updated. </dd></dl>

</div>
</div>
<a id="a3adda9ab95cfd243eed46edac8f84a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adda9ab95cfd243eed46edac8f84a96">&#9670;&nbsp;</a></span>Node_advance_repeating()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::Node_advance_repeating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_advance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Edit__flags.html">Edit_flags</a> &amp;&#160;</td>
          <td class="paramname"><em>editflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>t_ref</em> = <code><a class="el" href="namespacefz.html#aef05dd6bfa4d4a09d3eace4949b6fab0a328419ab650b1af199fdb58a44105aaa">RTt_unspecified</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the targetdate of a repeating <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> by carrying out one or more iterations of advances in accordance with its <code>tdpattern</code> periodicity. </p>
<p>Notes:</p><ol type="1">
<li>For repeating Nodes with limited <code>tdspan</code> at least one instance will remain. Refusing to complete and advance past the final instance of such a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> is a safety precaution, so that incomplete Nodes are not mysteriously eliminated from the schedule merely by updating the schedule.</li>
<li>When a repeating <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> with limited <code>tdspan</code> is modified to <code>tdspan &lt; 2</code> then the <code>tdspan</code> is set to 0 and the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> no longer <code>repeats</code>, but the <code>tdpattern</code> is left unchanged. It can be used as a cached reminder of a previous repetition pattern setting (e.g. in case you with add more iterations).</li>
<li>If a <code>tdspan==1</code> is found then it is set to 0 and <code>repeats</code> is turned off, just to to ensure a valid <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> setting, in case the unexpected setting was a result of manual modification.</li>
<li>At present, <code>t_ref</code> IS NOT USED FOR ANYTHING (!!!). Consequently, advancing a repeating <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> with this function does not pay attention to passing any particular time. This is probably by <code><a class="el" href="namespacefz.html#a369a33ebf770a5ad54a404a07ccae4db" title="Update repeating Nodes past a specific time.">Update_repeating_Nodes()</a></code> uses a while-loop to make single-step advances for each repeating <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>. Perhaps this is the desired behavior, as it allows a completed repeating <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> to move on to its next instance, even if that is beyond current (emulated) time. Otherwise, repeating Nodes completed before the target date of their current instance might put themselves back on the Schedule for the same day. Then again - does it need to be done this way? Or can using <code>t_ref</code> in this function apply a test such that a repeating <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> can move on to an instance beyond t_ref, but will then stop advancing. If this were the protocol, then setting <code>t_ref=RTt_maxtime</code> would be the default to deactive such a constraint.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Reference to a valid <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> object. </td></tr>
    <tr><td class="paramname">N_advance</td><td>Number of iterations to advance. </td></tr>
    <tr><td class="paramname">editflags</td><td>Specifies the parameters that were modified. Use this to update the database. </td></tr>
    <tr><td class="paramname">t_ref</td><td>Optional reference time (if negative then Actual time is used). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True when advanvement modifications were made, false if an invalid circumstance was encountered.</dd></dl>
<p>Notes:</p><ol type="1">
<li>For repeating Nodes with limited <code>tdspan</code> at least one instance will remain. Refusing to complete and advance past the final instance of such a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> is a safety precaution, so that incomplete Nodes are not mysteriously eliminated from the schedule merely by updating the schedule.</li>
<li>When a repeating <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> with limited <code>tdspan</code> is modified to <code>tdspan &lt; 2</code> then the <code>tdspan</code> is set to 0 and the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> no longer <code>repeats</code>, but the <code>tdpattern</code> is left unchanged. It can be used as a cached reminder of a previous repetition pattern setting (e.g. in case you with add more iterations).</li>
<li>If a <code>tdspan==1</code> is found then it is set to 0 and <code>repeats</code> is turned off, just to to ensure a valid <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> setting, in case the unexpected setting was a result of manual modification.</li>
<li>At present, <code>t_ref</code> IS NOT USED FOR ANYTHING (!!!). Consequently, advancing a repeating <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> with this function does not pay attention to passing any particular time. This is probably by <code><a class="el" href="namespacefz.html#a369a33ebf770a5ad54a404a07ccae4db" title="Update repeating Nodes past a specific time.">Update_repeating_Nodes()</a></code> uses a while-loop to make single-step advances for each repeating <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>. Perhaps this is the desired behavior, as it allows a completed repeating <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> to move on to its next instance, even if that is beyond current (emulated) time. Otherwise, repeating Nodes completed before the target date of their current instance might put themselves back on the Schedule for the same day. Then again - does it need to be done this way? Or can using <code>t_ref</code> in this function apply a test such that a repeating <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> can move on to an instance beyond t_ref, but will then stop advancing. If this were the protocol, then setting <code>t_ref=RTt_maxtime</code> would be the default to deactive such a constraint.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Reference to a valid <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> object. </td></tr>
    <tr><td class="paramname">N_advance</td><td>Number of iterations to advance. </td></tr>
    <tr><td class="paramname">editflags</td><td>Specifies the parameters that were modified. Use this to update the database. </td></tr>
    <tr><td class="paramname">t_ref</td><td>Optional reference time (if negative then Actual time is used). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True when advancement modifications were made, false if an invalid circumstance was encountered. </dd></dl>

</div>
</div>
<a id="a288da0b8294bcae4c1259c43e1c55156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288da0b8294bcae4c1259c43e1c55156">&#9670;&nbsp;</a></span>Node_apply_minutes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfz_1_1Edit__flags.html">Edit_flags</a> fz::Node_apply_minutes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>add_minutes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>T_ref</em> = <code><a class="el" href="namespacefz.html#aef05dd6bfa4d4a09d3eace4949b6fab0a328419ab650b1af199fdb58a44105aaa">RTt_unspecified</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>'s completion ratio (and potentially updates required if completion exceeds 1.0) in response to having logged a number of minutes dedicated to the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>. </p>
<p>For repeating Nodes, updates the targetdate if specific conditions are met.</p>
<p>Notes:</p><ol type="1">
<li><code>add_minutes</code> is necessarily &gt;= 0, which is different than directly modifying parameters in ways that can increase or reduce. It only makes sense to log positive time.</li>
<li>Automatic correction of <code>required</code> when <code>completion &gt; 1.0</code> is a point where Formalizer 2.x behavior differs from that of Formalizer 1.x behavior.</li>
</ol>
<p>*** Future improvement notes: While automatically correcting <code>required</code> when <code>completion &gt; 1.0</code> is useful, it is not the full measure of improvements planned, which are:</p><ul>
<li><a href="https://trello.com/c/Rnm84Hld">Something better than completion ratio + time required</a>.</li>
<li><a href="https://trello.com/c/oa3zFBdd">Additional completion conditions</a>.</li>
<li><a href="https://trello.com/c/JqxApvhO">Tags that teach time required</a>.</li>
</ul>
<p>See, for example, how this is used in fzserverpq/tcp_server_handlers.cpp:node_add_logged_time().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Reference to a valid <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> object. </td></tr>
    <tr><td class="paramname">add_minutes</td><td>The number of minutes that were logged. </td></tr>
    <tr><td class="paramname">T_ref</td><td>An optional reference time (if negative then Actual time is used). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classfz_1_1Edit__flags.html" title="A bitmask of flags for the data components of a Node.">Edit_flags</a> indicating the parameters of the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> that were modified. Use this to update the database.</dd></dl>
<p>For repeating Nodes, updates the targetdate if specific conditions are met.</p>
<p>Notes:</p><ol type="1">
<li><code>add_minutes</code> is necessarily &gt;= 0, which is different than directly modifying parameters in ways that can increase or reduce. It only makes sense to log positive time.</li>
<li>Automatic correction of <code>required</code> when <code>completion &gt; 1.0</code> is a point where Formalizer 2.x behavior differs from that of Formalizer 1.x behavior.</li>
<li>Special care if needed when a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> is repeating, because target date updating must then happen for <code>completion &gt;= 1.0</code>.</li>
<li>If an invalid circumstance is encountered then the special flag Edit_flags::error is set. The calling function should still check for other flags and synchronize modifications to the database, as some modifications can take place before an error is encountered.</li>
</ol>
<p>*** Future improvement notes: A. While automatically correcting <code>required</code> when <code>completion &gt; 1.0</code> is useful, it is not the full measure of improvements planned, which are:</p><ul>
<li><a href="https://trello.com/c/Rnm84Hld">Something better than completion ratio + time required</a>.</li>
<li><a href="https://trello.com/c/oa3zFBdd">Additional completion conditions</a>.</li>
<li><a href="https://trello.com/c/JqxApvhO">Tags that teach time required</a>. B. Consider moving the <code>editflags</code> into the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> objects as a cache variable. Then, have the <code>set_</code> functions automatically modify the <code>editflags</code>. And add function to <code>clear_all_editflags()</code> that only certain programs can call (e.g. when loading the <a class="el" href="classfz_1_1Graph.html">Graph</a> into shared memory). This way, all normal paths that lead to <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> changes also cause flag setting. Optionally, you could then move some of these more sophisticated modification functions into the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> objects as well, as long as they still set flags.</li>
</ul>
<p>See, for example, how this is used in fzserverpq/tcp_server_handlers.cpp:node_add_logged_time().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Reference to a valid <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> object. </td></tr>
    <tr><td class="paramname">add_minutes</td><td>The number of minutes that were logged. </td></tr>
    <tr><td class="paramname">T_ref</td><td>An optional reference time (if negative then Actual time is used). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classfz_1_1Edit__flags.html" title="A bitmask of flags for the data components of a Node.">Edit_flags</a> indicating the parameters of the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> that were modified. Use this to update the database.</dd></dl>
<p>For repeating Nodes, updates the targetdate if specific conditions are met.</p>
<p>Notes:</p><ol type="1">
<li><code>add_minutes</code> is necessarily &gt;= 0, which is different than directly modifying parameters in ways that can increase or reduce. It only makes sense to log positive time.</li>
<li>Automatic correction of <code>required</code> when <code>completion &gt; 1.0</code> is a point where Formalizer 2.x behavior differs from that of Formalizer 1.x behavior.</li>
<li>If an invalid circumstance is encountered then the special flag Edit_flags::error is set. The calling function should still check for other flags and synchronize modifications to the database, as some modifications can take place before an error is encountered.</li>
</ol>
<p>*** Future improvement notes: A. While automatically correcting <code>required</code> when <code>completion &gt; 1.0</code> is useful, it is not the full measure of improvements planned, which are:</p><ul>
<li><a href="https://trello.com/c/Rnm84Hld">Something better than completion ratio + time required</a>.</li>
<li><a href="https://trello.com/c/oa3zFBdd">Additional completion conditions</a>.</li>
<li><a href="https://trello.com/c/JqxApvhO">Tags that teach time required</a>. B. Consider moving the <code>editflags</code> into the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> objects as a cache variable. Then, have the <code>set_</code> functions automatically modify the <code>editflags</code>. And add function to <code>clear_all_editflags()</code> that only certain programs can call (e.g. when loading the <a class="el" href="classfz_1_1Graph.html">Graph</a> into shared memory). This way, all normal paths that lead to <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> changes also cause flag setting. Optionally, you could then move some of these more sophisticated modification functions into the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> objects as well, as long as they still set flags.</li>
</ul>
<p>See, for example, how this is used in fzserverpq/tcp_server_handlers.cpp:node_add_logged_time().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Reference to a valid <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> object. </td></tr>
    <tr><td class="paramname">add_minutes</td><td>The number of minutes that were logged. </td></tr>
    <tr><td class="paramname">T_ref</td><td>An optional reference time (if negative then Actual time is used). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classfz_1_1Edit__flags.html" title="A bitmask of flags for the data components of a Node.">Edit_flags</a> indicating the parameters of the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> that were modified. Use this to update the database. </dd></dl>

</div>
</div>
<a id="a51db678bb5c84838eae7c598afeb2ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51db678bb5c84838eae7c598afeb2ecb">&#9670;&nbsp;</a></span>Node_completed_non_repeating_more_required()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::Node_completed_non_repeating_more_required </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Edit__flags.html">Edit_flags</a> &amp;&#160;</td>
          <td class="paramname"><em>editflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>seconds_applied</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For non-repeating Nodes, this corrects the specified required time to reflect the actual time taken to complete the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>, while also setting the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> completed. </p>
<p>This is a server function, e.g. called within <code>fzserverpq</code>, via the <code><a class="el" href="namespacefz.html#a288da0b8294bcae4c1259c43e1c55156" title="Updates a Node&#39;s completion ratio (and potentially updates required if completion exceeds 1....">Node_apply_minutes()</a></code> function below.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Reference to a valid <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> object. </td></tr>
    <tr><td class="paramname">editflags</td><td>Specifies the parameters modified. Used to update the database. </td></tr>
    <tr><td class="paramname">seconds_applied</td><td>The actual number of seconds that were applied to complete the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac99455b568fc2d7dbf7b1c150197bb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99455b568fc2d7dbf7b1c150197bb28">&#9670;&nbsp;</a></span>Node_completed_repeating()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::Node_completed_repeating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Edit__flags.html">Edit_flags</a> &amp;&#160;</td>
          <td class="paramname"><em>editflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>t_ref</em> = <code><a class="el" href="namespacefz.html#aef05dd6bfa4d4a09d3eace4949b6fab0a328419ab650b1af199fdb58a44105aaa">RTt_unspecified</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Depending on the tdpattern type of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>, potentially modify its targetdate in accordance with that repetition pattern and reset its completion ratio. </p>
<p>This does essentially the same as <code><a class="el" href="namespacefz.html#a3adda9ab95cfd243eed46edac8f84a96" title="Modify the targetdate of a repeating Node by carrying out one or more iterations of advances in accor...">Node_advance_repeating()</a></code> one iteration.</p>
<p>This is a server function, e.g. called within <code>fzserverpq</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Reference to a valid <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> object. </td></tr>
    <tr><td class="paramname">editflags</td><td>Specifies the parameters that were modified. Use this to update the database. </td></tr>
    <tr><td class="paramname">T_ref</td><td>Optional reference time (if negative then Actual time is used). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the repeating <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> was modified for the completed iteration, false if an invalid circumstance was encountered. </dd></dl>

</div>
</div>
<a id="ab33c35dfbdc3f1d405cc4f6d9b54290d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33c35dfbdc3f1d405cc4f6d9b54290d">&#9670;&nbsp;</a></span>Node_completion_update_within_required()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::Node_completion_update_within_required </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Edit__flags.html">Edit_flags</a> &amp;&#160;</td>
          <td class="paramname"><em>editflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>seconds_applied</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>seconds_required</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> completion ratio between 0.0 and 1.0. </p>
<p>This is a server function, e.g. called within <code>fzserverpq</code>, via the <code><a class="el" href="namespacefz.html#a288da0b8294bcae4c1259c43e1c55156" title="Updates a Node&#39;s completion ratio (and potentially updates required if completion exceeds 1....">Node_apply_minutes()</a></code> function below.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Reference to a valid <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> object. </td></tr>
    <tr><td class="paramname">editflags</td><td>Specifies the parameters modified. Used to update the database. </td></tr>
    <tr><td class="paramname">seconds_applied</td><td>The actual number of seconds applied to the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> so far. </td></tr>
    <tr><td class="paramname">seconds_required</td><td>The number of seconds predicted to be required to complete the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0203e69125707c24e32c03ae3c3658d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0203e69125707c24e32c03ae3c3658d">&#9670;&nbsp;</a></span>Node_Dependencies_fulldepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::Node_Dependencies_fulldepth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Subtree_Branch_Map &amp;&#160;</td>
          <td class="paramname"><em>fulldepth_dependencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="structfz_1_1Node__ID__key.html">Node_ID_key</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>do_not_follow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Node_Branch::branch_strength&#160;</td>
          <td class="paramname"><em>cmp_method</em> = <code>Node_Branch::none</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>strength</em> = <code>-999.9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect all unique Nodes in the dependencies tree of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>. </p>
<p>Note that do_not_follow should contain at least the ID key of node_ptr to prevent recursive follows. Also see how do_not_follow is used in <a class="el" href="namespacefz.html#ad3c571fbebb6453dab7977124d200c85" title="Collect the subtrees that are the full dependencies of all Nodes in a Named Nodes List.">Threads_Subtrees()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_ptr</td><td>A valid pointer to <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>. </td></tr>
    <tr><td class="paramname">fulldepth_dependencies</td><td>A Subtree_Branch_Map container for the resulting set of dependencies. </td></tr>
    <tr><td class="paramname">do_not_follow</td><td>A set of <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> ID keys that will not be followed when building the dependencies subtree. </td></tr>
    <tr><td class="paramname">cmp_method</td><td>The method to use to propagate branch strength. </td></tr>
    <tr><td class="paramname">strength</td><td>Incoming propagated branch strength. (The code -999.9 means that this is the first branch.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful. </dd></dl>

</div>
</div>
<a id="a1a96de898f3c588d8be7a65e37f5a579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a96de898f3c588d8be7a65e37f5a579">&#9670;&nbsp;</a></span>Node_ID_TimeStamp_from_epochtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::Node_ID_TimeStamp_from_epochtime </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>minor_id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>throw_if_invalid</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a usable <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> ID TimeStamp from an epoch time and a minor-ID. </p>
<p>This can also be used to produce valid <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> ID TimeStamps without the node-ID extension by specifying <code>minor_id = 0</code>. (See for example how that is used in <code>fzaddnode</code> to generate a base for a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> ID before choosing the minor-ID.)</p>
<p>Valid epoch times must be greater than 1999-01-01 00:00:00. If <code>throw_if_invalid</code> is true then an invalid epoch time causes <a class="el" href="classfz_1_1ID__exception.html" title="Exception thrown when a Node ID is of invalid form.">ID_exception</a> to be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A valid epoch time for a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> ID. </td></tr>
    <tr><td class="paramname">minor_id</td><td>A single-digit minor-ID (0 means time stamp only). </td></tr>
    <tr><td class="paramname">throw_if_invalid</td><td>If true then throw <a class="el" href="classfz_1_1ID__exception.html" title="Exception thrown when a Node ID is of invalid form.">ID_exception</a> for invalid specifications. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string with a valid <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> ID TimeStamp, including minor-ID if given (or empty if invalid). </dd></dl>

</div>
</div>
<a id="abc98b08458fd96c977eb59ee75aa1171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc98b08458fd96c977eb59ee75aa1171">&#9670;&nbsp;</a></span>Node_skip_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::Node_skip_num </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num_skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Edit__flags.html">Edit_flags</a> &amp;&#160;</td>
          <td class="paramname"><em>editflags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skip N instances of a repeating <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>. </p>
<p>Note A: This is using a while-loop, because of the issue in Note 4 of <a class="el" href="namespacefz.html#a3adda9ab95cfd243eed46edac8f84a96" title="Modify the targetdate of a repeating Node by carrying out one or more iterations of advances in accor...">Node_advance_repeating()</a>. Note B: This function does not take a <code>T_ref</code> parameter. It is specifically intended to enable skipping an arbitrary number of instances without regard to a time threshold.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The repeating <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> that should skip instances. </td></tr>
    <tr><td class="paramname">num_skip</td><td>The number of instances to skip. </td></tr>
    <tr><td class="paramname">editflags</td><td>Reference to <a class="el" href="classfz_1_1Edit__flags.html" title="A bitmask of flags for the data components of a Node.">Edit_flags</a> object that returns modifications carried out.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: This function does not take a <code>T_ref</code> parameter. It is specifically intended to enable skipping an arbitrary number of instances without regard to a time threshold.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The repeating <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> that should skip instances. </td></tr>
    <tr><td class="paramname">num_skip</td><td>The number of instances to skip. </td></tr>
    <tr><td class="paramname">editflags</td><td>Reference to <a class="el" href="classfz_1_1Edit__flags.html" title="A bitmask of flags for the data components of a Node.">Edit_flags</a> object that returns modifications carried out. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f2278aa9e3c21818c6f7d9aff6d9a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2278aa9e3c21818c6f7d9aff6d9a10">&#9670;&nbsp;</a></span>Node_skip_tpass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::Node_skip_tpass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>t_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Edit__flags.html">Edit_flags</a> &amp;&#160;</td>
          <td class="paramname"><em>editflags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skip instances of a repeating <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> past a specified time. </p>
<p>Note A: This is using a while-loop, because of the issue in Note 4 of <a class="el" href="namespacefz.html#a3adda9ab95cfd243eed46edac8f84a96" title="Modify the targetdate of a repeating Node by carrying out one or more iterations of advances in accor...">Node_advance_repeating()</a>. Note B: Unlike the Schedule updating <code><a class="el" href="namespacefz.html#a369a33ebf770a5ad54a404a07ccae4db" title="Update repeating Nodes past a specific time.">Update_repeating_Nodes()</a></code> function, this single-Node instance skipping function purposely does not make an exception for Nodes with an annual repeat pattern.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The repeating <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> that should skip instances. </td></tr>
    <tr><td class="paramname">t_pass</td><td>The threshold time past which to skip instances. </td></tr>
    <tr><td class="paramname">editflags</td><td>Reference to <a class="el" href="classfz_1_1Edit__flags.html" title="A bitmask of flags for the data components of a Node.">Edit_flags</a> object that returns modifications carried out. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9629548827f74d642a38b6a5f20fbef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9629548827f74d642a38b6a5f20fbef2">&#9670;&nbsp;</a></span>Nodes_created_in_time_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">key_sorted_Nodes fz::Nodes_created_in_time_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>earliest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects all Nodes that have <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> IDs (i.e. </p>
<p>creation times) within a specified time interval.</p>
<p>For example, see how this is used in <code>fzaddnode</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A valid <a class="el" href="classfz_1_1Graph.html">Graph</a> data structure. </td></tr>
    <tr><td class="paramname">earliest</td><td>The earliest epoch-time equivalent Node-ID. </td></tr>
    <tr><td class="paramname">before</td><td>The epoch-time equivalent beyond the Node-ID interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of pointers to nodes by <a class="el" href="structfz_1_1Node__ID__key.html" title="Standardized Formalizer Node ID key.">Node_ID_key</a>. </dd></dl>

</div>
</div>
<a id="ae62ff7921be30fed8109b0b3a9ceab0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62ff7921be30fed8109b0b3a9ceab0d">&#9670;&nbsp;</a></span>Nodes_in_list_by_targetdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a> fz::Nodes_in_list_by_targetdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Named__Node__List.html">Named_Node_List_ptr</a>&#160;</td>
          <td class="paramname"><em>namedlist_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects all Nodes that appear in a specific Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> Lilst and lists them by effective target date. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A valid <a class="el" href="classfz_1_1Graph.html">Graph</a> data structure. </td></tr>
    <tr><td class="paramname">namedlist_ptr</td><td>A valid Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of pointers to nodes by effective targetdate. </dd></dl>

</div>
</div>
<a id="ab002cb5dc36910bcd7e0541fa0a416e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab002cb5dc36910bcd7e0541fa0a416e2">&#9670;&nbsp;</a></span>Nodes_incomplete_and_repeating_by_targetdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a> fz::Nodes_incomplete_and_repeating_by_targetdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects all Nodes that are incomplete and repeating and lists them by (inherited) target date. </p>
<p>Note that this is NOT the same thing as incomplete with repeating. This is an and operation where both things must be true.</p>
<p>For example, see how this is used in <code>fzupdate</code> together with <code>Graphmodify:<a class="el" href="namespacefz.html#a369a33ebf770a5ad54a404a07ccae4db" title="Update repeating Nodes past a specific time.">Update_repeating_Nodes()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A valid <a class="el" href="classfz_1_1Graph.html">Graph</a> data structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of pointers to nodes by effective targetdate. </dd></dl>

</div>
</div>
<a id="a02cd92dea2dd119cb33aac6e73a24762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02cd92dea2dd119cb33aac6e73a24762">&#9670;&nbsp;</a></span>Nodes_incomplete_by_targetdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a> fz::Nodes_incomplete_by_targetdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects all Nodes that are incomplete and lists them by (inherited) target date. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A valid <a class="el" href="classfz_1_1Graph.html">Graph</a> data structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of pointers to nodes by effective targetdate.</dd></dl>
<p>For example, see how this is used in <code>fzgraphhtml</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A valid <a class="el" href="classfz_1_1Graph.html">Graph</a> data structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of pointers to nodes by effective targetdate. </dd></dl>

</div>
</div>
<a id="afeef89c75a7c538ca2e5512ec7bf92f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeef89c75a7c538ca2e5512ec7bf92f7">&#9670;&nbsp;</a></span>Nodes_incomplete_with_repeating_by_targetdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a> fz::Nodes_incomplete_with_repeating_by_targetdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>t_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>limit_repeats_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns targetdate sorted Nodes that are incomplete, augmented with repeated instances. </p>
<p>This is an application in sequence of the two functions above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A valid <a class="el" href="classfz_1_1Graph.html">Graph</a> object. </td></tr>
    <tr><td class="paramname">t_max</td><td>Limit to which to generate the resulting list of <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> pointers. </td></tr>
    <tr><td class="paramname">N_max</td><td>Maximum size of list to return (zero means no size limit). </td></tr>
    <tr><td class="paramname">limit_repeats_only</td><td>If true then apply t_max only to repeating Nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A target date sorted list of <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> pointers with repeats. </dd></dl>

</div>
</div>
<a id="a843459a8cad97af396b31c848c4740a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843459a8cad97af396b31c848c4740a0">&#9670;&nbsp;</a></span>Nodes_subset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a> fz::Nodes_subset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Node__Filter.html">Node_Filter</a> &amp;&#160;</td>
          <td class="paramname"><em>nodefilter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all Nodes that match a specified <a class="el" href="structfz_1_1Node__Filter.html" title="Filter class that helps construct filter specifications.">Node_Filter</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A valid <a class="el" href="classfz_1_1Graph.html">Graph</a> data structure. </td></tr>
    <tr><td class="paramname">nodefilter</td><td>A specified <a class="el" href="structfz_1_1Node__Filter.html" title="Filter class that helps construct filter specifications.">Node_Filter</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of pointers to nodes by effective targetdate that match the filter specifications.</dd></dl>
<p>Notes:</p><ul>
<li>Searching for Nodes within a target date range can be done with one or two active bounds. If a bound is set to RTunspecified then it is not used and that end is open.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A valid <a class="el" href="classfz_1_1Graph.html">Graph</a> data structure. </td></tr>
    <tr><td class="paramname">nodefilter</td><td>A specified <a class="el" href="structfz_1_1Node__Filter.html" title="Filter class that helps construct filter specifications.">Node_Filter</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of pointers to nodes by effective targetdate that match the filter specifications. </dd></dl>

</div>
</div>
<a id="a4004ea2f3e9d20cc1f44fb57252a6cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4004ea2f3e9d20cc1f44fb57252a6cd5">&#9670;&nbsp;</a></span>Nodes_with_repeats_by_targetdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a> fz::Nodes_with_repeats_by_targetdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a> &amp;&#160;</td>
          <td class="paramname"><em>sortednodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>t_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>limit_repeats_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add virtual Nodes to produce a list where repeating Nodes appear at their pattern-specified repeat target dates. </p>
<p>Note that <code>t_max &lt; 0</code> is interpreted as <code>t_max = RTt_maxtime</code>.</p>
<p>If you want a list with repeats of only incomplete Nodes then <code>sortednodes</code> can be prepared with <code><a class="el" href="namespacefz.html#a02cd92dea2dd119cb33aac6e73a24762" title="Selects all Nodes that are incomplete and lists them by (inherited) target date.">Nodes_incomplete_by_targetdate()</a></code>. Otherwise, use an alternative preparation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sortednodes</td><td>A list of target date sorted <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> pointers. </td></tr>
    <tr><td class="paramname">t_max</td><td>Limit to which to generate the resulting list of <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> pointers. </td></tr>
    <tr><td class="paramname">N_max</td><td>Maximum size of list to return (zero means no size limit). </td></tr>
    <tr><td class="paramname">limit_repeats_only</td><td>If true then apply t_max only to repeating Nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A target date sorted list of <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> pointers with repeats.</dd></dl>
<p>Note that <code>t_max &lt; 0</code> is interpreted as <code>t_max = RTt_maxtime</code>.</p>
<p>If you want a list with repeats of only incomplete Nodes then <code>sortednodes</code> can be prepared with <code><a class="el" href="namespacefz.html#a02cd92dea2dd119cb33aac6e73a24762" title="Selects all Nodes that are incomplete and lists them by (inherited) target date.">Nodes_incomplete_by_targetdate()</a></code>. Otherwise, use an alternative preparation. See <code><a class="el" href="namespacefz.html#afeef89c75a7c538ca2e5512ec7bf92f7" title="Returns targetdate sorted Nodes that are incomplete, augmented with repeated instances.">Nodes_incomplete_with_repeating_by_targetdate()</a></code> below.</p>
<p>BEWARE: As implemented presently, the N_max limit is only applied by cropping after collecting a potentially much larger set. As implemented presently, the combination N_max==0 and t_max&lt;0 leads to an attempt to create a set with infinite repeated Nodes of unlimited span.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sortednodes</td><td>A list of target date sorted <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> pointers. </td></tr>
    <tr><td class="paramname">t_max</td><td>Limit to which to generate the resulting list of <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> pointers. </td></tr>
    <tr><td class="paramname">N_max</td><td>Maximum size of list to return (zero means no size limit). </td></tr>
    <tr><td class="paramname">limit_repeats_only</td><td>If true then apply t_max only to repeating Nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A target date sorted list of <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> pointers with repeats. </dd></dl>

</div>
</div>
<a id="ac8be39e0425eacd0b6da8a8721861333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8be39e0425eacd0b6da8a8721861333">&#9670;&nbsp;</a></span>Nodes_with_topic_by_targetdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a> fz::Nodes_with_topic_by_targetdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacefz.html#afddacf07ad964643983aa625bd00aba8">Topic_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects all Nodes that include a specific <a class="el" href="classfz_1_1Topic.html">Topic</a> ID and lists them by (inherited) target date. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A valid <a class="el" href="classfz_1_1Graph.html">Graph</a> data structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of pointers to nodes by effective targetdate. </dd></dl>

</div>
</div>
<a id="ac5d2b0e332e8c8cb2da50ef8a3fd395f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d2b0e332e8c8cb2da50ef8a3fd395f">&#9670;&nbsp;</a></span>pq_LBlayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::pq_LBlayout </td>
          <td>(</td>
          <td class="paramtype">&quot;id timestamp (0) PRIMARY KEY&quot;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notes about the Postgres <a class="el" href="classfz_1_1Log.html">Log</a> layout: </p>
<ul>
<li>About the <a class="el" href="classfz_1_1Log.html">Log</a> entry <code>minor_id</code>: Where <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> elements are concerned, we made the assumption in the 2.x data structure that there would never be more than 9 created in the same second. Hence, the minor_id required only 1 digit to store. The situation is different for <a class="el" href="classfz_1_1Log.html">Log</a> entries. First of all, the major part of the ID is only YYYYmmddHHMM (without seconds). Secondly, it is entirely possible that a <a class="el" href="classfz_1_1Log.html">Log</a> chunk could contain many more than 9 <a class="el" href="classfz_1_1Log.html">Log</a> entries. Therefore, <a class="el" href="classfz_1_1Log.html">Log</a> entry ID storage requires more digit space for the <code>minor_id</code>. In the current version of the data structure (see coreversion), we are assuming that, because the <code>minor_id</code> is encoded as a <code>uint8_t</code>, there can be a maximum of 255 <a class="el" href="classfz_1_1Log.html">Log</a> entries in a <a class="el" href="classfz_1_1Log.html">Log</a> chunk. The <code>minor_id</code> is given a 3 digit space in the <code>.logentries</code> Postgres table. </li>
</ul>

</div>
</div>
<a id="a7d24b6e4b1323e5d5687d184aa48fb4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d24b6e4b1323e5d5687d184aa48fb4a">&#9670;&nbsp;</a></span>query_call_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::query_call_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>qstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>request_single_row_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch a Postgres query for asynchronous processing in batch or single row mode. </p>
<p>Uses PQsendQuery() and PQsetSingleRowMode().</p>
<p>To receive results, use PQgetResult(), calling that function repeatedly if in single row mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>a valid Postgres connection object. </td></tr>
    <tr><td class="paramname">qstr</td><td>a Postgres query string. </td></tr>
    <tr><td class="paramname">request_single_row_mode</td><td>switches only this query to single row mode if true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the query was successfully dispatched. </dd></dl>

</div>
</div>
<a id="a163df4ed695f0e00f7d1ff4c0efbf966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163df4ed695f0e00f7d1ff4c0efbf966">&#9670;&nbsp;</a></span>read_Breakpoints_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::read_Breakpoints_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;&#160;</td>
          <td class="paramname"><em>apq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load full Breakpoints table into Log::breakpoints. </p>
<p>We can only add Breakpoints by adding actual existing <a class="el" href="classfz_1_1Log__chunk.html" title="Specifies the start time, Node, close time, and set of entries of a Log chunk.">Log_chunk</a> objects (which is a good safety mechanism). This means, that this function can really only be successfully called after calling <code><a class="el" href="namespacefz.html#a099b3ef08695bb2eb63a19ddffb39c8b" title="Load full Chunks table into Log::chunks.">read_Chunks_pq()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apq</td><td>data structure with active database connection pointer and schema name. </td></tr>
    <tr><td class="paramname">log</td><td>a <a class="el" href="classfz_1_1Log.html">Log</a> object, typically with an existing chunks list but empty Breakpoints list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a099b3ef08695bb2eb63a19ddffb39c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099b3ef08695bb2eb63a19ddffb39c8b">&#9670;&nbsp;</a></span>read_Chunks_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::read_Chunks_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;&#160;</td>
          <td class="paramname"><em>apq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>wherestr</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>limitdirstr</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load full Chunks table into Log::chunks. </p>
<p>With optional WHERE statement and optional LIMIT and direction statement. </p>

</div>
</div>
<a id="a0924e10402414b80f16c8ca32a95e4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0924e10402414b80f16c8ca32a95e4ad">&#9670;&nbsp;</a></span>read_Entries_first_pass_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::read_Entries_first_pass_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;&#160;</td>
          <td class="paramname"><em>apq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>wherestr</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>First-Pass Load of Entries into Log::entries. </p>
<p>This version of the database table query loads entries data and creates <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> objects but does not yet associate Log_chunks. It can be used to prepare <a class="el" href="classfz_1_1Log.html">Log</a> entries in advance where a sequence of passes is needed.</p>
<p>Note that this functions DOES NOT do <code>chunk-&gt;add_Entry()</code>. A second pass is needed to accomplish that.</p>
<p>See for example how this is used in Load_Node_history_pq().</p>
<p>With optional WHERE statement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apq</td><td>data structure with active database connection pointer and schema name. </td></tr>
    <tr><td class="paramname">log</td><td>a <a class="el" href="classfz_1_1Log.html">Log</a> object that is added to. </td></tr>
    <tr><td class="paramname">wherestr</td><td>An optional WHERE string to constrain which records are retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful. </dd></dl>

</div>
</div>
<a id="ae33a508dd163fea401543abc5f20a8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33a508dd163fea401543abc5f20a8a2">&#9670;&nbsp;</a></span>read_Entries_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::read_Entries_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1active__pq.html">active_pq</a> &amp;&#160;</td>
          <td class="paramname"><em>apq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>wherestr</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load full Entries table into Log::entries. </p>
<p>We can only add Entries while referring to existing Log_chunks (which is a good safety mechanism). This means, that this function can really only be successfully called after calling <code><a class="el" href="namespacefz.html#a099b3ef08695bb2eb63a19ddffb39c8b" title="Load full Chunks table into Log::chunks.">read_Chunks_pq()</a></code>.</p>
<p>EXPERIMENTING: With optional WHERE statement! Just in case this function can be reused for load_Log_interval()!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apq</td><td>data structure with active database connection pointer and schema name. </td></tr>
    <tr><td class="paramname">log</td><td>a <a class="el" href="classfz_1_1Log.html">Log</a> object, typically with an existing chunks list but empty Breakpoints list. </td></tr>
    <tr><td class="paramname">wherestr</td><td>An optional WHERE string to constrain which records are retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful. </dd></dl>

</div>
</div>
<a id="a0faf48a147699ffdf8906e6f230f1aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0faf48a147699ffdf8906e6f230f1aae">&#9670;&nbsp;</a></span>read_Guide_IDs_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::read_Guide_IDs_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1Guide__snippet.html">Guide_snippet</a> &amp;&#160;</td>
          <td class="paramname"><em>snippet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read all IDs from Guide table in the database. </p>
<p>The <code>snippet</code> should specify <code>snippet.tablename</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">snippet</td><td>Data structure that clearly identifies the table in <code>snippet.tablename</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pa</td><td>Access data with database name and schema name. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ids</td><td>Vector of ID strings, each of which can be parsed for its components. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful. </dd></dl>

</div>
</div>
<a id="a0a8d75e81f8c4ebd34f0e25be2e4144d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8d75e81f8c4ebd34f0e25be2e4144d">&#9670;&nbsp;</a></span>read_Guide_multi_snippets_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::read_Guide_multi_snippets_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1Guide__snippet.html">Guide_snippet</a> &amp;&#160;</td>
          <td class="paramname"><em>snippet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>snippets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read multiple snippets from Guide table in the database. </p>
<p>The <code>snippet</code> should specify the filtered subset by specifying those parts of the ID that should be matched and leaving other parts unspecified. This function is shared for various guide tables and does not know the actual class of <code>snippet</code>. Therefore, the translation from Guide-specific ID components and wildcards to a Postgres key wildcards needs to be done before calling this function, so that <code>snippet.idstr()</code> returns the right filter for "WHERE id LIKE '&lt;something&gt;'".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">snippet</td><td>Data structure that clearly specifies the filter as described. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pa</td><td>Access data with database name and schema name. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">snippets</td><td>Vector of snippet strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful.</dd></dl>
<p>The <code>snippet</code> should specify the filtered subset by specifying those parts of the ID that should be matched and leaving other parts unspecified. This function is shared for various guide tables and does not know the actual class of <code>snippet</code>. Therefore, the translation from Guide-specific ID components and wildcards to a Postgres key wildcards needs to be done before calling this function, so that <code>snippet.idstr()</code> returns the right filter for "WHERE id LIKE '&lt;something&gt;'".</p>
<p>Note that a <code>nullsnippet()</code> is interpreted as "read everything".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">snippet</td><td>Data structure that clearly specifies the filter as described. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pa</td><td>Access data with database name and schema name. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">snippets</td><td>Vector of snippet strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful. </dd></dl>

</div>
</div>
<a id="ae2f30f53fd171c9a6c7f03cf96c983ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f30f53fd171c9a6c7f03cf96c983ba">&#9670;&nbsp;</a></span>read_Guide_snippet_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::read_Guide_snippet_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1Guide__snippet.html">Guide_snippet</a> &amp;&#160;</td>
          <td class="paramname"><em>snippet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single snippet from a Guide table in the database. </p>
<p>The <code>snippet</code> should specify <code>snippet.tablename</code> and a working <code>idstr()</code> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snippet</td><td>data structure that clearly identifies the snippet and receives the resulting text. </td></tr>
    <tr><td class="paramname">pa</td><td>access data with database name and schema name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a669984ccbebfe6dbd9a4d962aded0012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669984ccbebfe6dbd9a4d962aded0012">&#9670;&nbsp;</a></span>refresh_Node_history_cache_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::refresh_Node_history_cache_pq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refresh the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> history cache table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pa</td><td>Access object with valid database and schema identifiers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the refresh was successful. </dd></dl>

</div>
</div>
<a id="a6b6bca104bb411113c4860d3cf396b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6bca104bb411113c4860d3cf396b5a">&#9670;&nbsp;</a></span>remove_html()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::remove_html </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>htmlstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all HTML tags to create raw text. </p>
<p>Note: At this time, this function does not yet remove text content between &lt;script&gt;&lt;/script&gt; tags and similar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">htmlstr</td><td>A string in HTML format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string in raw text format. </dd></dl>

</div>
</div>
<a id="a86cb09143d3253224bc32ee4ec1fec97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86cb09143d3253224bc32ee4ec1fec97">&#9670;&nbsp;</a></span>remove_html_tags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::remove_html_tags </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>htmlstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all HTML tags (but not special characters) to produce text that can be safely excerpted into HTML tables, etc, but that can still show ampersands and such properly within an HTML context. </p>
<p>Note: At this time, this function does not yet remove text content between &lt;script&gt;&lt;/script&gt; tags and similar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">htmlstr</td><td>A string in HTML format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string in HTML-lite format. </dd></dl>

</div>
</div>
<a id="a2ade55b0bb312702da34cfefc4cbace4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ade55b0bb312702da34cfefc4cbace4">&#9670;&nbsp;</a></span>remove_lockfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fz::remove_lockfile </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>lockfilepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove lockfile and report if the lockfile existed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lockfilepath</td><td>The path of a lockfile. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the lockfile existed and was removed, 1 if the lockfile did not exist, -1 on error. </dd></dl>

</div>
</div>
<a id="aead256000e898b28976faa8072b5775e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead256000e898b28976faa8072b5775e">&#9670;&nbsp;</a></span>rtrim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; fz::rtrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>t</em> = <code>&quot;&#160;\t\n\r\f\v&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim whitespace from the end of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a string. </td></tr>
    <tr><td class="paramname">t</td><td>a string containing whitespace characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the trimmed string. </dd></dl>

</div>
</div>
<a id="a4a72c04fc5a7860678e9156bd32b5aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a72c04fc5a7860678e9156bd32b5aa1">&#9670;&nbsp;</a></span>safe_cmdline_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, std::string &gt; fz::safe_cmdline_options </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>optindcopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safer parsing of command line parameters. </p>
<p>This wrapper aims to reduce that ways in which parsing command line parameters can lead to segfaults. (The getopt() function is not very safe in that regard.)</p>
<p>Note: This wrapper does use getopt() and getopt() is known to modify argv. Therefore, if you need the original argv, copy it before calling this functions. For example, with <code>std::vector&lt;std::string&gt; cmdargs; for (int i = 0; i &lt; argc; ++i) cmdargs[i] = argv[i];</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>is the argc from main(). </td></tr>
    <tr><td class="paramname">argv</td><td>is the argv from main(). </td></tr>
    <tr><td class="paramname">options</td><td>is the options list in the same format as for getopt(). </td></tr>
    <tr><td class="paramname">optindcopy</td><td>is a variable reference that receives a copy of optind as used by getopt(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9f1ea1c06a6640cec379b93dd751971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f1ea1c06a6640cec379b93dd751971">&#9670;&nbsp;</a></span>safe_localtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::tm * fz::safe_localtime </td>
          <td>(</td>
          <td class="paramtype">const std::time_t *&#160;</td>
          <td class="paramname"><em>t_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>errorcode_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Formalizer standardized version of the localtime() function that always returns a usable value, but which may log errors or warnings as needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_ptr</td><td>Pointer to a (time_t) variable containing the UNIX epoch time to convert. </td></tr>
    <tr><td class="paramname">errorcode_ptr</td><td>Optional pointer to a buffer for an errno error code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a local calendar time structure.</dd></dl>
<p>Note that errno is only set if localtime() returns nullptr, and therefore should only be tested then. The errno value is otherwise undefined. One of the safeties included here, in addition to always providing a usable time structure is an optional error code that is always set to a valid value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_ptr</td><td>Pointer to a (time_t) variable containing the UNIX epoch time to convert. </td></tr>
    <tr><td class="paramname">errorcode_ptr</td><td>Optional pointer to a buffer for an errno error code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a local calendar time structure. </dd></dl>

</div>
</div>
<a id="a3a73be79a425edc61347438db441c2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a73be79a425edc61347438db441c2c6">&#9670;&nbsp;</a></span>safecpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::safecpy </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safely copy from a string (not null-terminated) to a char buffer of limited size. </p>
<p>This can even include null-characters that were in the string. This is safer than std::copy(), string::copy(), strcpy() or strncpy().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A string. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to a limited-size character buffer. </td></tr>
    <tr><td class="paramname">bufsize</td><td>Size of the character buffer (counting all chars, even if one is meant for '\0'). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59b42530ac38402a5656af5bdcac5be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b42530ac38402a5656af5bdcac5be6">&#9670;&nbsp;</a></span>sample_query_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fz::sample_query_data </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>databufstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function that dumps several rows of data to a string buffer for easy inspection. </p>
<p>A <a class="el" href="namespacefz.html#a7d24b6e4b1323e5d5687d184aa48fb4a" title="Dispatch a Postgres query for asynchronous processing in batch or single row mode.">query_call_pq()</a> or equivalent should precede this.</p>
<p>To sample all columns simple set cend &gt; number of columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>an active Postgres connection. </td></tr>
    <tr><td class="paramname">rstart</td><td>first row to sample. </td></tr>
    <tr><td class="paramname">rend</td><td>one after last row to sample. </td></tr>
    <tr><td class="paramname">cstart</td><td>first column to sample. </td></tr>
    <tr><td class="paramname">cend</td><td>one after last column to sample. </td></tr>
    <tr><td class="paramname">databufstr</td><td>a string buffer for sampled data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of rows sampled. </dd></dl>

</div>
</div>
<a id="ae1f8fda024c1d778ea48ace049e6406d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f8fda024c1d778ea48ace049e6406d">&#9670;&nbsp;</a></span>server_request_with_shared_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefz.html#a95a7b508456ccb1691f487ed136d52d4">exit_status_code</a> fz::server_request_with_shared_data </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>segname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contact the server with the unique label of shared memory containing data for a <a class="el" href="classfz_1_1Graph.html">Graph</a> modification request. </p>
<p>Prints information about results unless <code>-q</code> was specified.</p>
<p>Note: The address of the server is hard coded to 127.0.0.1 here, because this modification request method uses shared memory, which is (outside of shared-memory clusters) only possible on the same machine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segname</td><td>The unique shared memory segment label. </td></tr>
    <tr><td class="paramname">port_number</td><td>The port number at which the server is expected to be listening. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The request outcome, expressed in exit codes (exit_ok, exit_general_error, etc). </dd></dl>

</div>
</div>
<a id="a326d23fce4986b21fbe0d8cbcbcc776a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326d23fce4986b21fbe0d8cbcbcc776a">&#9670;&nbsp;</a></span>server_socket_listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefz.html#a95a7b508456ccb1691f487ed136d52d4">exit_status_code</a> fz::server_socket_listen </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1shared__memory__server.html">shared_memory_server</a> &amp;&#160;</td>
          <td class="paramname"><em>server</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up an IPv4 TCP socket on specified port and listen for client connections from any address. </p>
<p>See <a href="https://man7.org/linux/man-pages/man7/ip.7.html">https://man7.org/linux/man-pages/man7/ip.7.html</a>.</p>
<p>Note: Only some errors return a detailed error message in an error data structure. Those are typically errors that were caught during validation of the request data. Other errors may not do so, although they will typically still log the error on the server side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_number</td><td>The port number to listen on. </td></tr>
    <tr><td class="paramname">server</td><td>A <a class="el" href="structfz_1_1shared__memory__server.html">shared_memory_server</a> derived server object to handle requests with data share. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Server listen outcome, expressed in exit codes (exit_ok, exit_general_error, etc). </dd></dl>

</div>
</div>
<a id="aa23b82243a12ae2b0d35ccb70d785857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23b82243a12ae2b0d35ccb70d785857">&#9670;&nbsp;</a></span>shellcmd2str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::shellcmd2str </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a shell command and retrieve the standard output as a string. </p>
<p>Note that this function will throw a runtime_error if the command could not be executed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>the shell command to execute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing the standard output of the executed command. </dd></dl>

</div>
</div>
<a id="aa1a653de26479eb7d85b850ec2918c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a653de26479eb7d85b850ec2918c2a">&#9670;&nbsp;</a></span>simple_call_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::simple_call_pq </td>
          <td>(</td>
          <td class="paramtype">PGconn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>astr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a simple action call to a Postgres database. </p>
<p>Note: If the global flag simulate_pq_changes==pq_command_simulate then this function does not execute Postgres calls. Instead, the call string will be added to simulated_pq_calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>active database connection. </td></tr>
    <tr><td class="paramname">astr</td><td>action call string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if action call was successful. </dd></dl>

</div>
</div>
<a id="a585ab197c3d6be71ac67d84d3fcc78f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585ab197c3d6be71ac67d84d3fcc78f4">&#9670;&nbsp;</a></span>sorted_to_NNL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t fz::sorted_to_NNL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a> &amp;&#160;</td>
          <td class="paramname"><em>sortednodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>list_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy Nodes from a sorted list to a Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List. </p>
<p>This does not include synchronization to database. See, for example, how this is used when processing a <code>batchmod_tpassrepeating</code> request in <code>fzserverpq</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A memory-resident <a class="el" href="classfz_1_1Graph.html">Graph</a>. </td></tr>
    <tr><td class="paramname">sortednodes</td><td>The target date sorted list of Nodes. </td></tr>
    <tr><td class="paramname">list_name</td><td>A Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List. If it already exists then it is deleted (even if no new one is created). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of Nodes copied from the sorted list to the NNL, or the error code -1. </dd></dl>

</div>
</div>
<a id="ab7dc083b5c0e84d7d715161e462a321f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7dc083b5c0e84d7d715161e462a321f">&#9670;&nbsp;</a></span>split() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; fz::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector containing pieces of a string. </p>
<p>This uses the <a class="el" href="namespacefz.html#a45a30fb04b5721cd05047bd4088fb8b0" title="Put pieces of a string into a pre-constructed vector.">split()</a> template above. It lets you do things like pass the result directly to a function like this: f(split(s, d, v)) while still having the benefit of a pre-allocated vector if you like.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A string. </td></tr>
    <tr><td class="paramname">delim</td><td>A delimiter character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of strings. </dd></dl>

</div>
</div>
<a id="a45a30fb04b5721cd05047bd4088fb8b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a30fb04b5721cd05047bd4088fb8b0">&#9670;&nbsp;</a></span>split() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Out &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fz::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Out&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put pieces of a string into a pre-constructed vector. </p>
<p>See for example how this is used in the <a class="el" href="namespacefz.html#a45a30fb04b5721cd05047bd4088fb8b0" title="Put pieces of a string into a pre-constructed vector.">split()</a> function below. Borrowed from: <a href="https://stackoverflow.com/questions/236129/how-do-i-iterate-over-the-words-of-a-string">https://stackoverflow.com/questions/236129/how-do-i-iterate-over-the-words-of-a-string</a> Note that this solution does not skip empty tokens, so the following will find 4 items, one of which is empty: std::vector&lt;std::string&gt; x = split("one:two::three", ':');</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a string. </td></tr>
    <tr><td class="paramname">delim</td><td>a delimiter character. </td></tr>
    <tr><td class="paramname">result</td><td>a std::back_insert_iterator for the result container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cb865200e35c530ff09a2a5c142c55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb865200e35c530ff09a2a5c142c55a">&#9670;&nbsp;</a></span>store_Graph_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::store_Graph_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(unsigned long, unsigned long)&#160;</td>
          <td class="paramname"><em>progress_func</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store all the Nodes and Edges of the <a class="el" href="classfz_1_1Graph.html">Graph</a> in the PostgreSQL database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>a <a class="el" href="classfz_1_1Graph.html">Graph</a> containing all of the Nodes and Edges. </td></tr>
    <tr><td class="paramname">dbname</td><td>database name. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
    <tr><td class="paramname">progress_func</td><td>points to an optional progress indicator function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classfz_1_1Graph.html">Graph</a> was successfully stored in the database. </dd></dl>

</div>
</div>
<a id="a84b38593fec552b574f1ca8e56d3b254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b38593fec552b574f1ca8e56d3b254">&#9670;&nbsp;</a></span>store_Guide_multi_snippet_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::store_Guide_multi_snippet_pq </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Guide_snippet_ptr &gt; &amp;&#160;</td>
          <td class="paramname"><em>snippets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store multiple Guide snippets in the PostgreSQL database. </p>
<p>Creates the table if necessary.</p>
<p>At least the first element (index 0) of the vector must contain a valid <code>tablename</code> and must produce valid <code>layout()</code> information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snippets</td><td>a vector guide snippets. </td></tr>
    <tr><td class="paramname">pa</td><td>a standard database access stucture with database name and schema name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the snippet was successfully stored in the database. </dd></dl>

</div>
</div>
<a id="af8eebdb96e1f6ab62ce592c84ea3e669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8eebdb96e1f6ab62ce592c84ea3e669">&#9670;&nbsp;</a></span>store_Guide_snippet_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::store_Guide_snippet_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Guide__snippet.html">Guide_snippet</a> &amp;&#160;</td>
          <td class="paramname"><em>snippet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a new Guide snippet in the PostgreSQL database. </p>
<p>Creates the table if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snippet</td><td>a guide snippet. </td></tr>
    <tr><td class="paramname">pa</td><td>a standard database access stucture with database name and schema name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the snippet was successfully stored in the database. </dd></dl>

</div>
</div>
<a id="ac534af76c643c9568951e81e51066108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac534af76c643c9568951e81e51066108">&#9670;&nbsp;</a></span>store_Log_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::store_Log_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(unsigned long, unsigned long)&#160;</td>
          <td class="paramname"><em>progressfunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store all the Chunks and Entries of the <a class="el" href="classfz_1_1Log.html">Log</a> in the PostgreSQL database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>a <a class="el" href="classfz_1_1Log.html">Log</a> containing all of the Chunks and Entries. </td></tr>
    <tr><td class="paramname">pa</td><td>access object with database name and Formalizer schema name. </td></tr>
    <tr><td class="paramname">progress_func</td><td>points to an optional progress indicator function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classfz_1_1Log.html">Log</a> was successfully stored in the database. </dd></dl>

</div>
</div>
<a id="a5fb6b12160bc081fe25f613a84eaacdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb6b12160bc081fe25f613a84eaacdb">&#9670;&nbsp;</a></span>store_Node_history_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::store_Node_history_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Node__histories.html">Node_histories</a> &amp;&#160;</td>
          <td class="paramname"><em>nodehist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a <a class="el" href="structfz_1_1Node__history.html" title="Log history by Node expressed as a list of Log chunks and a list of Log entries for each Node for whi...">Node_history</a> object to a cache table in the database to speed up generation of a Node-specific <a class="el" href="classfz_1_1Log.html">Log</a> history. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodehist</td><td>A <a class="el" href="structfz_1_1Node__history.html" title="Log history by Node expressed as a list of Log chunks and a list of Log entries for each Node for whi...">Node_history</a> object. </td></tr>
    <tr><td class="paramname">pa</td><td>Access object with valid database and schema identifiers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if cache table storage was successful. </dd></dl>

</div>
</div>
<a id="ae354d176f2f483264ec225411f7eb122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae354d176f2f483264ec225411f7eb122">&#9670;&nbsp;</a></span>stream_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::stream_to_string </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the full contents of a (text) stream into a string. </p>
<p>This implementation was tested to be faster than the one-liner implementations shown at <a href="https://stackoverflow.com/questions/3203452/how-to-read-entire-stream-into-a-stdstring">https://stackoverflow.com/questions/3203452/how-to-read-entire-stream-into-a-stdstring</a>, at least as of Oct. 2011. It might be even faster to pre-allocate buffer space according to stream size, as per the example inhttp://www.cplusplus.com/reference/istream/istream/read/, but it isn't immediately clear to me if that also works with STDIN.</p>
<p>Note: This can be used with STDIN (<code>cin</code>) as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>is an open istream. </td></tr>
    <tr><td class="paramname">s</td><td>reference to the receiving string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the read into string was successful. </dd></dl>

</div>
</div>
<a id="abea20a984e3df8f30caadc6c4eb46381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea20a984e3df8f30caadc6c4eb46381">&#9670;&nbsp;</a></span>string_to_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::string_to_file </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream::iostate *&#160;</td>
          <td class="paramname"><em>writestate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the full contents of a string to a file. </p>
<p>Note that this function does NOT create a backup of a previous file at the given path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>of the file. </td></tr>
    <tr><td class="paramname">s</td><td>reference to the string. </td></tr>
    <tr><td class="paramname">writestate</td><td>returns the iostate flags when provided (default: nullptr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the write from string was successful. </dd></dl>

</div>
</div>
<a id="a82121e1189c46fe028b6b6e9a073c8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82121e1189c46fe028b6b6e9a073c8d5">&#9670;&nbsp;</a></span>string_to_file_with_backup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::string_to_file_with_backup </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>backupext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>backedup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream::iostate *&#160;</td>
          <td class="paramname"><em>writestate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the full contents of a string to a file, but move an existing file at the given path to a backup name first. </p>
<p>Note that TimeStamp:<a class="el" href="namespacefz.html#abe4308075d0f8dc4c0129d8ee71740e5" title="Generate a Formalizer standardized file backup extension (YYYYmmdd.bak).">BackupStampYmd()</a> and TimeStamp:<a class="el" href="namespacefz.html#a4932c9514aab01039104a5b0033934d4" title="Generate a Formalizer standardized file backup precise extension (YYYYmmddHHMM.bak).">BackupStampYmdHM()</a> provide valid Formalizer standardized backup extension tags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>of the file. </td></tr>
    <tr><td class="paramname">s</td><td>reference to the string. </td></tr>
    <tr><td class="paramname">backupext</td><td>is the extension to use for a potential backup of existing. </td></tr>
    <tr><td class="paramname">backedup</td><td>stores a flag to indicate is an existing file was renamed to a backup. </td></tr>
    <tr><td class="paramname">writestate</td><td>returns the iostate flags when provided (default: nullptr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the write from string was successful. </dd></dl>

</div>
</div>
<a id="a8824c8c3167d53cc6ac73ff691b1b680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8824c8c3167d53cc6ac73ff691b1b680">&#9670;&nbsp;</a></span>tdsorted_Nodes_to_csv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::tdsorted_Nodes_to_csv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a> &amp;&#160;</td>
          <td class="paramname"><em>sorted_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>csv_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a target date sorted multimap of <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> pointers into a string of <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> ID strings as comma separated values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sorted_nodes</td><td>The multimap of <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> pointers sorted by a target date key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">csv_str</td><td>The string object reference for the resulting comma separated values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6951620bac95418982701ccae1b150c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6951620bac95418982701ccae1b150c6">&#9670;&nbsp;</a></span>test_process_running()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::test_process_running </td>
          <td>(</td>
          <td class="paramtype">pid_t&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a process with a specific PID is running. </p>
<p>This uses the kill() function with signal 0, which sends no actual signal but still performs error checking.</p>
<p>This uses the kill() function with signal 0, which sends no actual signal but still performs error checking.</p>
<p>To use, #include &lt;sys/types.h&gt;, #include &lt;signal.h&gt;.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>Process ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if found and running. </dd></dl>

</div>
</div>
<a id="ac5d41a65ead33aea665b4ac04835c90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d41a65ead33aea665b4ac04835c90a">&#9670;&nbsp;</a></span>this_program_process_ID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pid_t fz::this_program_process_ID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the PID of this program. </p>
<p>To use, #include &lt;sys/types.h&gt;, #include &lt;unistd.h&gt;. </p>

</div>
</div>
<a id="ad3c571fbebb6453dab7977124d200c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c571fbebb6453dab7977124d200c85">&#9670;&nbsp;</a></span>Threads_Subtrees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map_of_subtrees_t fz::Threads_Subtrees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nnl_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort_by_targetdate</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>norepeated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the subtrees that are the full dependencies of all Nodes in a Named Nodes List. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nnl_str</td><td>Named Nodes List. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map in which the keys are the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> IDs of Nodes in the NNL and the values are each a set of unique Nodes that are the dependencies.</dd></dl>
<p>Note that the 'norepeated' option is applied to the board contents after full dependencies trees are collected. This is done so that excluding repeated Nodes does not halt collection of dependencies in subtrees of such Nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nnl_str</td><td>Named Nodes List. </td></tr>
    <tr><td class="paramname">sort_by_targetdate</td><td>Option to sort columns by target date. </td></tr>
    <tr><td class="paramname">norepeated</td><td>Option to exclude Nodes with the 'repeat' property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map in which the keys are the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> IDs of Nodes in the NNL and the values are each a set of unique Nodes that are the dependencies. </dd></dl>

</div>
</div>
<a id="a50b50bdd16d9e99e3ff4bf398f3fe68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b50bdd16d9e99e3ff4bf398f3fe68f">&#9670;&nbsp;</a></span>time_stamp_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t fz::time_stamp_time </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>timestr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noerror</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a Formalizer time stamp string into local Unix time. </p>
<p>Formalizer time stamp strings must have this format: 1) [^0-9]YYYYmmddHHMM (e.g. "202008140613", "__202109150714"), and, 2) the year must be &gt;= 1900, or, 3) a negative integer code (e.g. "-2").</p>
<p>Negative integer codes are returned the equivalent negative integer so that special codes can be detected.</p>
<p>Non-digit characters preceding the digits of a proper time stamp are ignored and discarded. (This does not apply to negative integer codes.)</p>
<p>When the 'noerror' flag is set then no error message will be added if an invalid time stamp is encountered. This can be useful when this function is explicitly used to check for empty/unfinished/etc time stamps.</p>
<p>The 1900 test is a useful sanity check, because mangled time stamp strings can often lead to unlikely dates preceding the computing era.</p>
<p>This function is derived from dil2al/utilities.cc:<a class="el" href="namespacefz.html#a50b50bdd16d9e99e3ff4bf398f3fe68f" title="Convert a Formalizer time stamp string into local Unix time.">time_stamp_time()</a>. Unlike that function, this one does not terminate the program when an invalid time stamp is encountered and uses no configuration flag to elicit such behavior. Instead, the special code RTt_invalid_time_stamp is returned in that case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestr</td><td>a string containing the Formalizer time stamp. </td></tr>
    <tr><td class="paramname">noerror</td><td>suppresses ADDERROR() for invalid time stamps. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>local Unix time in seconds, negative integer code, or RTt_invalid_time_stamp.</dd></dl>
<p>Formalizer time stamp strings must have this format: 1) [^0-9]YYYYmmddHHMM (e.g. "202008140613", "__202109150714"), and, 2) the year must be &gt;= 1900, or, 3) a negative integer code (e.g. "-2").</p>
<p>Negative integer codes are returned the equivalent negative integer so that special codes can be detected.</p>
<p>Non-digit characters preceding the digits of a proper time stamp are ignored and discarded. (This does not apply to negative integer codes.)</p>
<p>When the 'noerror' flag is set then no error message will be added if an invalid time stamp is encountered. This can be useful when this function is explicitly used to check for empty/unfinished/etc time stamps.</p>
<p>The 1900 test is a useful sanity check, because mangled time stamp strings can often lead to unlikely dates preceding the computing era.</p>
<p>This function is derived from dil2al/utilities.cc:<a class="el" href="namespacefz.html#a50b50bdd16d9e99e3ff4bf398f3fe68f" title="Convert a Formalizer time stamp string into local Unix time.">time_stamp_time()</a>. Unlike that function, this one does not terminate the program when an invalid time stamp is encountered and uses no configuration flag to elicit such behavior. Instead, the special code INVALID_TIME_STAMP is returned in that case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestr</td><td>a string containing the Formalizer time stamp. </td></tr>
    <tr><td class="paramname">noerror</td><td>suppresses ADDERROR() for invalid time stamps. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>local Unix time in seconds, negative integer code, or RTt_invalid_time_stamp. </dd></dl>

</div>
</div>
<a id="a31c5acaefdebe1051c4ff921bc754e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c5acaefdebe1051c4ff921bc754e68">&#9670;&nbsp;</a></span>TimeStamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::TimeStamp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dateformat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate time stamp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dateformat</td><td>a date and time format specifier, e.g. "%Y%m%d%H%M". </td></tr>
    <tr><td class="paramname">t</td><td>a date and time expressed in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The time stamp string. Returns an empty string if t&lt;0. </dd></dl>

</div>
</div>
<a id="a303e1d94ae3679f5fcc99dced6137cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303e1d94ae3679f5fcc99dced6137cb2">&#9670;&nbsp;</a></span>to_precision_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::to_precision_string </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>fillchar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print double to string with specific precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a real number. </td></tr>
    <tr><td class="paramname">p</td><td>precision (default 2). </td></tr>
    <tr><td class="paramname">fillchar</td><td>the fill character (default ' ', i.e. space). </td></tr>
    <tr><td class="paramname">w</td><td>minimum width (default 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string. </dd></dl>

</div>
</div>
<a id="a4f94c797bfe00822cb2905b11a9657b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f94c797bfe00822cb2905b11a9657b4">&#9670;&nbsp;</a></span>Topic_IDs_to_Tags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; fz::Topic_IDs_to_Tags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacefz.html#afddacf07ad964643983aa625bd00aba8">Topic_ID</a> &gt;&#160;</td>
          <td class="paramname"><em>IDs_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of <a class="el" href="classfz_1_1Topic.html">Topic</a> tag label strings for a specified vector of known <a class="el" href="classfz_1_1Topic.html">Topic</a> IDs from a specified <a class="el" href="classfz_1_1Graph.html">Graph</a>. </p>
<p>Note: Also see the <code>Graphtypes:<a class="el" href="namespacefz.html#a05501ad2719a3430eca700c5dd72b8e1" title="Returns a vector of label string and relevance value pairs for a specified Node within a specified Gr...">Topic_tags_of_Node()</a></code> function. </p>

</div>
</div>
<a id="a05501ad2719a3430eca700c5dd72b8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05501ad2719a3430eca700c5dd72b8e1">&#9670;&nbsp;</a></span>Topic_tags_of_Node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tag_Label_Real_Value_Vector fz::Topic_tags_of_Node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of label string and relevance value pairs for a specified <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> within a specified <a class="el" href="classfz_1_1Graph.html">Graph</a>. </p>
<p>Note: Also see the <code>Graphinfo:<a class="el" href="namespacefz.html#a4f94c797bfe00822cb2905b11a9657b4" title="Returns a vector of Topic tag label strings for a specified vector of known Topic IDs from a specifie...">Topic_IDs_to_Tags()</a></code> function. </p>

</div>
</div>
<a id="a503e1da7cf55e0087a7a09f7b6befc01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503e1da7cf55e0087a7a09f7b6befc01">&#9670;&nbsp;</a></span>total_minutes_incomplete_nonrepeating()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fz::total_minutes_incomplete_nonrepeating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>from_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>before_t</em> = <code><a class="el" href="namespacefz.html#aef05dd6bfa4d4a09d3eace4949b6fab0ad567131680cdfe5720218682688975a4">RTt_maxtime</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total required time for all incomplete non-repeating Nodes within a time interval. </p>
<p>Note: Adding this to the total for repeating nodes (see function above) is a better way to estimate total time required for all Scheduled Nodes, where non- repeating Nodes must be completed in time available between repeating Nodes. It can be used to provide a projection or estimate for the current time limit up to which variable or unspecified target date <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> Scheduling is sensible. (Better = better than the estimate produced with <code>Node_Statistics</code>.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A valid <a class="el" href="classfz_1_1Graph.html">Graph</a> object. </td></tr>
    <tr><td class="paramname">from_t</td><td>Earliest time from which to calculate accumulated required time. </td></tr>
    <tr><td class="paramname">before_t</td><td>Limit to which to calculate accumulated required time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total required time calculated in minutes. </dd></dl>

</div>
</div>
<a id="a1d448863f42dc4a4fe439a5b35a1747f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d448863f42dc4a4fe439a5b35a1747f">&#9670;&nbsp;</a></span>total_minutes_incomplete_repeating()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fz::total_minutes_incomplete_repeating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>from_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>before_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mapexact</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total required time for all incomplete repeating Nodes and their instances within a time interval. </p>
<p>Returns the total required time for all incompelte repeating Nodes and their instances within a time interval.</p>
<p>Note: This same information can be obtained by creating a Nodes filter, obtaining the resulting list of Nodes, and then computing the total. This function is provided for convenience.</p>
<p>Note: There is an issue/question here about how to deal with overlapping exact target date Nodes. Obviously, they will not actually consume time twice, but taking that into account correctly requires mapping time. It doesn't need to be a map with as much flexibility as needed for other mapping applications, but at least a simple flag per smallest time-interval to allocate (e.g. 1 boolean per minute). Note that mapping 1 year by minute with boolean would require a map of 525600 bytes. In this sense, fixed and exact target date <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> required time totals should ideally be calculated separately and then combined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A valid <a class="el" href="classfz_1_1Graph.html">Graph</a> object. </td></tr>
    <tr><td class="paramname">from_t</td><td>Earliest time from which to calculate accumulated required time. </td></tr>
    <tr><td class="paramname">before_t</td><td>Limit to which to calculate accumulated required time. </td></tr>
    <tr><td class="paramname">mapexact</td><td>Flag to choose exact target dates mapping for more precise totals. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total required time calculated in minutes. </dd></dl>

</div>
</div>
<a id="a56881d63a827a663822facaab67b15ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56881d63a827a663822facaab67b15ef">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; fz::trim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>t</em> = <code>&quot;&#160;\t\n\r\f\v&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim whitespace on both ends of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a string. </td></tr>
    <tr><td class="paramname">t</td><td>a string containing whitespace characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the trimmed string. </dd></dl>

</div>
</div>
<a id="a4ce2b73ba6dd26afc3099321482a02ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce2b73ba6dd26afc3099321482a02ac">&#9670;&nbsp;</a></span>update_Log_entry_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::update_Log_entry_pq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Postgres__access.html">Postgres_access</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update Entry in existing table in schema of PostgreSQL database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>A valid <a class="el" href="classfz_1_1Log.html">Log</a> entry object. </td></tr>
    <tr><td class="paramname">pa</td><td>Access object with database name and Formalizer schema name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classfz_1_1Log.html">Log</a> entry was successfully updated in the database. </dd></dl>

</div>
</div>
<a id="a74e32f92d40e442ab21d111c026dc173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e32f92d40e442ab21d111c026dc173">&#9670;&nbsp;</a></span>Update_Named_Node_List_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::Update_Named_Node_List_pq </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>listname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List in the NamedNodeLists table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dbname</td><td>Database name. </td></tr>
    <tr><td class="paramname">schemaname</td><td>Formalizer schema name (usually Graph_access::pq_schemaname) </td></tr>
    <tr><td class="paramname">listname</td><td>Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List name. </td></tr>
    <tr><td class="paramname">graph</td><td><a class="el" href="classfz_1_1Graph.html">Graph</a> that contains the Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> Lists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfully deleted. </dd></dl>

</div>
</div>
<a id="a4c73d83a9556d9e2ff47d6aa53b24fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c73d83a9556d9e2ff47d6aa53b24fd7">&#9670;&nbsp;</a></span>Update_Node_pq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::Update_Node_pq </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>schemaname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Edit__flags.html">Edit_flags</a> &amp;&#160;</td>
          <td class="paramname"><em>_editflags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct interface to the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> update function that sets up the database connection first. </p>
<p>If you consistently clear <a class="el" href="classfz_1_1Edit__flags.html" title="A bitmask of flags for the data components of a Node.">Edit_flags</a> of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> after successfully synchronizing to the database then you can use remaining flags as indicators when running an integrity check on the <a class="el" href="classfz_1_1Graph.html">Graph</a>. </p>

</div>
</div>
<a id="a369a33ebf770a5ad54a404a07ccae4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369a33ebf770a5ad54a404a07ccae4db">&#9670;&nbsp;</a></span>Update_repeating_Nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a> fz::Update_repeating_Nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacefz.html#ade8fd9836dfeac48419a3e0a89f0f8f2">targetdate_sorted_Nodes</a> &amp;&#160;</td>
          <td class="paramname"><em>sortednodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>t_pass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update repeating Nodes past a specific time. </p>
<p>The <code><a class="el" href="classfz_1_1Edit__flags.html" title="A bitmask of flags for the data components of a Node.">Edit_flags</a></code> of each updated <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> are set in accordance with the modifications that take place on that <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>. This is used by the <code>Graphpostgres</code> process. Remember to clear the <code><a class="el" href="classfz_1_1Edit__flags.html" title="A bitmask of flags for the data components of a Node.">Edit_flags</a></code> after sychronizing to the database.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sortednodes[in]</td><td>A list of target date sorted incomplete <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> pointers. These could be all or just repeated. </td></tr>
    <tr><td class="paramname">t_pass[in]</td><td>The time past which to update repeating Nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A target date sorted list of <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> pointers that were updated. Use this to synchronize to the database.</dd></dl>
<p>This is a server function, e.g. called within <code>fzserverpq</code>. For the rationale, see the explanation at <a href="https://trello.com/c/eUjjF1yZ/222-how-graph-components-are-edited#comment-5fd8fed424188014cb31a937">https://trello.com/c/eUjjF1yZ/222-how-graph-components-are-edited#comment-5fd8fed424188014cb31a937</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sortednodes[in]</td><td>A list of target date sorted incomplete <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> pointers. These could be all or just repeated. </td></tr>
    <tr><td class="paramname">t_pass[in]</td><td>The time past which to update repeating Nodes. </td></tr>
    <tr><td class="paramname">editflags[out]</td><td>Reference to <a class="el" href="classfz_1_1Edit__flags.html" title="A bitmask of flags for the data components of a Node.">Edit_flags</a> object that returns modifications that apply to one or more Nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A target date sorted list of <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> pointers that were updated. Use this to synchronize to the database. </dd></dl>

</div>
</div>
<a id="abf722de88e20cea469b8d0d79be4acc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf722de88e20cea469b8d0d79be4acc5">&#9670;&nbsp;</a></span>update_shortlist_List()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fz::update_shortlist_List </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the 'shortlist" Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List. </p>
<p>The 'shortlist' Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List is frequently used by Formalizer tools that request a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> selection. To simplify that, this function exists at the server level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A valid <a class="el" href="classfz_1_1Graph.html">Graph</a> data structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of Nodes copied into the updated 'shortlist' Named <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> List. </dd></dl>

</div>
</div>
<a id="a0ccd23a3b259b377888ca0d649ec972a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccd23a3b259b377888ca0d649ec972a">&#9670;&nbsp;</a></span>uri_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::uri_encode </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string into a URI-safe string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Unencoded string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Encoded string. </dd></dl>

</div>
</div>
<a id="a6b5a614340e67aa9ff729f387ca8e987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5a614340e67aa9ff729f387ca8e987">&#9670;&nbsp;</a></span>utf8_safe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fz::utf8_safe </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>utf8str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter a text string to ensure that it contains valid UTF8 encoded content. </p>
<p>Attempts to assign content to the text parameter as provided, and replaces any invalid UTF8 code points with a replacement character. The default replacement character is the UTF8 'REPLACEMENT CHARACTER' 0xfffd.</p>
<p>If invalid UTF8 code points were encountered and replaced then that is optionally reported through ADDWARNING.</p>
<p>Note 1: ASCII text is valid UTF8 text and will be assigned unaltered. Note 2: This does not test for valid HTML5 at this time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">utf8str</td><td>A string that should contain UTF8 encoded text. </td></tr>
    <tr><td class="paramname">warn</td><td>If true then warn about invalid UTF8 code replacements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A guaranteed utf8 compliant string. </dd></dl>

</div>
</div>
<a id="a045ec1abb4dc382e0b56e345c146de95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045ec1abb4dc382e0b56e345c146de95">&#9670;&nbsp;</a></span>valid_Log_chunk_ID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_Log_chunk_ID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> &amp;&#160;</td>
          <td class="paramname"><em>idT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>formerror</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a <a class="el" href="structfz_1_1Log__TimeStamp.html" title="Timestamp IDs in the format required for Log IDs.">Log_TimeStamp</a> can be used as a valid <a class="el" href="classfz_1_1Log__chunk__ID.html">Log_chunk_ID</a>. </p>
<p>Note that years before 1999 are disqualified, since the Formalizer did not exist before then.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idT</td><td>reference to an <a class="el" href="structfz_1_1Log__TimeStamp.html" title="Timestamp IDs in the format required for Log IDs.">Log_TimeStamp</a> object. </td></tr>
    <tr><td class="paramname">formerror</td><td>a string that collects specific error information if there is any. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

</div>
</div>
<a id="a957bdd835342852a8ef5ad94723e34cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a957bdd835342852a8ef5ad94723e34cf">&#9670;&nbsp;</a></span>valid_Log_chunk_ID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_Log_chunk_ID </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>formerror</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> *&#160;</td>
          <td class="paramname"><em>id_timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a string can be used to form a valid <a class="el" href="classfz_1_1Log__chunk__ID.html">Log_chunk_ID</a>. </p>
<p>Checks string length, all digits in time stamp, and time stamp components within valid ranges. Note that years before 1999 are disqualified, since the Formalizer did not exist before then.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_str</td><td>a string of the format YYYYmmddHHMM. </td></tr>
    <tr><td class="paramname">formerror</td><td>a string that collects specific error information if there is any. </td></tr>
    <tr><td class="paramname">id_timestamp</td><td>if not NULL, receives valid components. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

</div>
</div>
<a id="a61ced31e8ffbaf54c00a9f586eaf1dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ced31e8ffbaf54c00a9f586eaf1dd4">&#9670;&nbsp;</a></span>valid_Log_entry_ID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_Log_entry_ID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> &amp;&#160;</td>
          <td class="paramname"><em>idT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>formerror</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a <a class="el" href="structfz_1_1Log__TimeStamp.html" title="Timestamp IDs in the format required for Log IDs.">Log_TimeStamp</a> can be used as a valid <a class="el" href="classfz_1_1Log__entry__ID.html">Log_entry_ID</a>. </p>
<p>Note that years before 1999 are disqualified, since the Formalizer did not exist before then.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idT</td><td>reference to an <a class="el" href="structfz_1_1Log__TimeStamp.html" title="Timestamp IDs in the format required for Log IDs.">Log_TimeStamp</a> object. </td></tr>
    <tr><td class="paramname">formerror</td><td>a string that collects specific error information if there is any. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

</div>
</div>
<a id="a8c0d31396e23ba90447163d6b714f1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c0d31396e23ba90447163d6b714f1d5">&#9670;&nbsp;</a></span>valid_Log_entry_ID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_Log_entry_ID </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>formerror</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> *&#160;</td>
          <td class="paramname"><em>id_timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a string can be used to form a valid <a class="el" href="classfz_1_1Log__entry__ID.html">Log_entry_ID</a>. </p>
<p>Checks string length, period separating time stamp from minor ID, all digits in time stamp and minor ID, and time stamp components within valid ranges. Note that years before 1999 are disqualified, since the Formalizer did not exist before then.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_str</td><td>a string of the format YYYYmmddHHMM.num. </td></tr>
    <tr><td class="paramname">formerror</td><td>a string that collects specific error information if there is any. </td></tr>
    <tr><td class="paramname">id_timestamp</td><td>if not NULL, receives valid components. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

</div>
</div>
<a id="a0c4260c6b3087bdf22ce089216638d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4260c6b3087bdf22ce089216638d79">&#9670;&nbsp;</a></span>valid_Node_ID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_Node_ID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1ID__TimeStamp.html">ID_TimeStamp</a> &amp;&#160;</td>
          <td class="paramname"><em>idT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>formerror</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a <a class="el" href="structfz_1_1ID__TimeStamp.html" title="Timestamp IDs in the format required for Node IDs.">ID_TimeStamp</a> can be used as a valid <a class="el" href="classfz_1_1Node__ID.html" title="Node ID that caches its ID stamp for frequent use.">Node_ID</a>. </p>
<p>Note that years before 1999 are disqualified, since the Formalizer did not exist before then.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idT</td><td>reference to an <a class="el" href="structfz_1_1ID__TimeStamp.html" title="Timestamp IDs in the format required for Node IDs.">ID_TimeStamp</a> object. </td></tr>
    <tr><td class="paramname">formerror</td><td>a string that collects specific error information if there is any. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

</div>
</div>
<a id="aba0e4f3360d11eff1bf1b4553a451180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0e4f3360d11eff1bf1b4553a451180">&#9670;&nbsp;</a></span>valid_Node_ID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_Node_ID </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>formerror</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1ID__TimeStamp.html">ID_TimeStamp</a> *&#160;</td>
          <td class="paramname"><em>id_timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a string can be used to form a valid <a class="el" href="classfz_1_1Node__ID.html" title="Node ID that caches its ID stamp for frequent use.">Node_ID</a>. </p>
<p>Checks string length, period separating time stamp from minor ID, all digits in time stamp and minor ID, and time stamp components within valid ranges. Note that years before 1999 are disqualified, since the Formalizer did not exist before then.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_str</td><td>a string of the format YYYYmmddHHMMSS.num. </td></tr>
    <tr><td class="paramname">formerror</td><td>a string that collects specific error information if there is any. </td></tr>
    <tr><td class="paramname">id_timestamp</td><td>if not NULL, receives valid components. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

</div>
</div>
<a id="af320a36d5d2f05de32419ea52f625e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af320a36d5d2f05de32419ea52f625e1e">&#9670;&nbsp;</a></span>valid_year_month_day()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::valid_year_month_day </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a>&#160;</td>
          <td class="paramname"><em>ymd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a year, month and day form a valid date. </p>
<p>The rules are: 1800 &lt;= year &lt;= 9999 1 &lt;= month &lt;= 12 1 &lt;= day &lt;= max_days_in(month)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ymd</td><td>a tuple of year, month, day numbers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the date is valid. </dd></dl>

</div>
</div>
<a id="a053fc7625765a11b31ee3604a1f225b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053fc7625765a11b31ee3604a1f225b0">&#9670;&nbsp;</a></span>years_months_days()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a> fz::years_months_days </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a>&#160;</td>
          <td class="paramname"><em>ymd1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfz_1_1year__month__day__t.html">year_month_day_t</a>&#160;</td>
          <td class="paramname"><em>ymd2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Express the difference between two dates in terms of the number of Years, Months and Days between them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ymd1</td><td>an earlier year, month, day tuple. </td></tr>
    <tr><td class="paramname">ymd2</td><td>a later year, month, day tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple with the number of years, months and days between them. </dd></dl>

</div>
</div>
<a id="acd0003e81e0cb15861b2dfa5fa1469e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0003e81e0cb15861b2dfa5fa1469e2">&#9670;&nbsp;</a></span>ymd_stamp_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::time_t fz::ymd_stamp_time </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>timestr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noerror</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreHM</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UNIX epoch time equivalent of a Year-Month-Day date-stamp such as 20200914 or 202009140100. </p>
<p>This function uses <code><a class="el" href="namespacefz.html#a50b50bdd16d9e99e3ff4bf398f3fe68f" title="Convert a Formalizer time stamp string into local Unix time.">time_stamp_time()</a></code> for time stamp format validation and conversion, but it allows pure date stamps consisting of just 8 year, month and day digits, as well as 12 digit time stamps. In the 12 digit case, the last 4 digits can be optionally ignored (set to 0000) during conversion to UNIX epoch time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestr</td><td>a string containing the Formalizer time stamp or date stamp. </td></tr>
    <tr><td class="paramname">noerror</td><td>suppresses ADDERROR() for invalid time stamps. </td></tr>
    <tr><td class="paramname">ignoreHM</td><td>optionally set any hour and minute digits to 0 during conversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>local Unix time in seconds, negative integer code, or RTt_invalid_time_stamp. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a67e63f3d2130ee19138dccdf85336b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e63f3d2130ee19138dccdf85336b8c">&#9670;&nbsp;</a></span>boolean_flag_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;const char *, Boolean_Tag_Flags::boolean_flag, <a class="el" href="structfz_1_1cmp__cstr.html">cmp_cstr</a>&gt; fz::boolean_flag_map</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    { <span class="stringliteral">&quot;TZADJUST&quot;</span>, Boolean_Tag_Flags::tzadjust },</div>
<div class="line">    { <span class="stringliteral">&quot;WORK&quot;</span>, Boolean_Tag_Flags::work },</div>
<div class="line">    { <span class="stringliteral">&quot;SELFWORK&quot;</span>, Boolean_Tag_Flags::self_work },</div>
<div class="line">    { <span class="stringliteral">&quot;SYSTEM&quot;</span>, Boolean_Tag_Flags::system },</div>
<div class="line">    { <span class="stringliteral">&quot;OTHER&quot;</span>, Boolean_Tag_Flags::other },</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a22d42a3a9cb94c374b5cfe167196db73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d42a3a9cb94c374b5cfe167196db73">&#9670;&nbsp;</a></span>boolean_flag_str_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;Boolean_Tag_Flags::boolean_flag, const std::string&gt; fz::boolean_flag_str_map</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    { Boolean_Tag_Flags::tzadjust, <span class="stringliteral">&quot;TZADJUST&quot;</span> },</div>
<div class="line">    { Boolean_Tag_Flags::work, <span class="stringliteral">&quot;WORK&quot;</span> },</div>
<div class="line">    { Boolean_Tag_Flags::self_work, <span class="stringliteral">&quot;SELFWORK&quot;</span> },</div>
<div class="line">    { Boolean_Tag_Flags::system, <span class="stringliteral">&quot;SYSTEM&quot;</span> },</div>
<div class="line">    { Boolean_Tag_Flags::other, <span class="stringliteral">&quot;OTHER&quot;</span> },</div>
<div class="line">    { Boolean_Tag_Flags::error,  <span class="stringliteral">&quot;error&quot;</span> },</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a75a9d7f3f75c181024b7eb9154486b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a9d7f3f75c181024b7eb9154486b0d">&#9670;&nbsp;</a></span>copyhtmljs_template_A</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* fz::copyhtmljs_template_A</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= R<span class="stringliteral">&quot;&quot;&quot;&quot;(</span></div>
<div class="line"><span class="stringliteral">function copyHtmlToClipboard() {</span></div>
<div class="line"><span class="stringliteral">  var copyRef = document.getElementById(&quot;)&quot;&quot;&quot;&quot;</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9ac69e178c4df23d74f96359d2befa23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac69e178c4df23d74f96359d2befa23">&#9670;&nbsp;</a></span>copyhtmljs_template_B</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* fz::copyhtmljs_template_B</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= R<span class="stringliteral">&quot;&quot;&quot;&quot;(&quot;);</span></div>
<div class="line"><span class="stringliteral">  const el = document.createElement(&quot;textarea&quot;);</span></div>
<div class="line"><span class="stringliteral">  var copyValue = copyRef.innerHTML;</span></div>
<div class="line"><span class="stringliteral">  el.value = copyValue</span></div>
<div class="line"><span class="stringliteral">  document.body.appendChild(el);</span></div>
<div class="line"><span class="stringliteral">  el.select();</span></div>
<div class="line"><span class="stringliteral">  navigator.clipboard.writeText(el.value);</span></div>
<div class="line"><span class="stringliteral">  //document.execCommand(&quot;copy&quot;);</span></div>
<div class="line"><span class="stringliteral">  document.body.removeChild(el);</span></div>
<div class="line"><span class="stringliteral">  alert(&quot;Copied: &quot; + copyValue);</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral">)&quot;&quot;&quot;&quot;</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a729990e405965c2ca1f9477eb7441936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729990e405965c2ca1f9477eb7441936">&#9670;&nbsp;</a></span>copyvaluejs_template_A</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* fz::copyvaluejs_template_A</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= R<span class="stringliteral">&quot;&quot;&quot;&quot;(</span></div>
<div class="line"><span class="stringliteral">function copyValueToClipboard() {</span></div>
<div class="line"><span class="stringliteral">  var copyValue = document.getElementById(&quot;)&quot;&quot;&quot;&quot;</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa8851b96747b0e8a3f65052c5fd0a599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8851b96747b0e8a3f65052c5fd0a599">&#9670;&nbsp;</a></span>copyvaluejs_template_B</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* fz::copyvaluejs_template_B</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= R<span class="stringliteral">&quot;&quot;&quot;&quot;(&quot;);</span></div>
<div class="line"><span class="stringliteral">  copyValue.select();</span></div>
<div class="line"><span class="stringliteral">  copyValue.setSelectionRange(0, 99999); // For mobile devices</span></div>
<div class="line"><span class="stringliteral">  navigator.clipboard.writeText(copyValue.value);</span></div>
<div class="line"><span class="stringliteral">  //alert(&quot;Copied: &quot; + copyValue.value);</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral">)&quot;&quot;&quot;&quot;</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3fce015cc53230952afbdbc408efa260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fce015cc53230952afbdbc408efa260">&#9670;&nbsp;</a></span>ext_mimetype</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, std::string&gt; fz::ext_mimetype</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    {<span class="stringliteral">&quot;.html&quot;</span>,<span class="stringliteral">&quot;text/html&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;.css&quot;</span>,<span class="stringliteral">&quot;text/css&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;.csv&quot;</span>,<span class="stringliteral">&quot;text/csv&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;.gif&quot;</span>,<span class="stringliteral">&quot;image/gif&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;.ico&quot;</span>,<span class="stringliteral">&quot;image/vnd.microsoft.icon&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;.jpg&quot;</span>,<span class="stringliteral">&quot;image/jpeg&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;.jpeg&quot;</span>,<span class="stringliteral">&quot;image/jpeg&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;.png&quot;</span>,<span class="stringliteral">&quot;image/png&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;.svg&quot;</span>,<span class="stringliteral">&quot;image/svg+xml&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;.txt&quot;</span>,<span class="stringliteral">&quot;text/plain&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;.sh&quot;</span>,<span class="stringliteral">&quot;application/x-sh&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;.json&quot;</span>,<span class="stringliteral">&quot;application/json&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;.ics&quot;</span>,<span class="stringliteral">&quot;text/calendar&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;_other_&quot;</span>,<span class="stringliteral">&quot;application/octet-stream&quot;</span>}</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5c09898831c45c42a4875335c5c5ec21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c09898831c45c42a4875335c5c5ec21">&#9670;&nbsp;</a></span>flagbylabel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; std::string, Edit_flags_type &gt; fz::flagbylabel</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    {<span class="stringliteral">&quot;topics&quot;</span>, Edit_flags::topics},</div>
<div class="line">    {<span class="stringliteral">&quot;valuation&quot;</span>, Edit_flags::valuation},</div>
<div class="line">    {<span class="stringliteral">&quot;completion&quot;</span>, Edit_flags::completion},</div>
<div class="line">    {<span class="stringliteral">&quot;required&quot;</span>, Edit_flags::required},</div>
<div class="line">    {<span class="stringliteral">&quot;text&quot;</span>, Edit_flags::text},</div>
<div class="line">    {<span class="stringliteral">&quot;targetdate&quot;</span>, Edit_flags::targetdate},</div>
<div class="line">    {<span class="stringliteral">&quot;tdproperty&quot;</span>, Edit_flags::tdproperty},</div>
<div class="line">    {<span class="stringliteral">&quot;repeats&quot;</span>, Edit_flags::repeats},</div>
<div class="line">    {<span class="stringliteral">&quot;tdpattern&quot;</span>, Edit_flags::tdpattern},</div>
<div class="line">    {<span class="stringliteral">&quot;tdevery&quot;</span>, Edit_flags::tdevery},</div>
<div class="line">    {<span class="stringliteral">&quot;tdspan&quot;</span>, Edit_flags::tdspan},</div>
<div class="line">    {<span class="stringliteral">&quot;topicrels&quot;</span>, Edit_flags::topicrels},</div>
<div class="line">    {<span class="stringliteral">&quot;superiors&quot;</span>, Edit_flags::supdep},</div>
<div class="line">    {<span class="stringliteral">&quot;dependencies&quot;</span>, Edit_flags::supdep},</div>
<div class="line">    {<span class="stringliteral">&quot;in_NNLs&quot;</span>, Edit_flags::nnl},</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aae1f933c98077a8f99e1d371b33ac65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae1f933c98077a8f99e1d371b33ac65b">&#9670;&nbsp;</a></span>Graph_modification_request_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;Graph_modification_request, std::string&gt; fz::Graph_modification_request_str</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    {graphmod_add_node, <span class="stringliteral">&quot;add_node&quot;</span>},</div>
<div class="line">    {graphmod_add_edge, <span class="stringliteral">&quot;add_edge&quot;</span>},</div>
<div class="line">    {namedlist_add, <span class="stringliteral">&quot;add_to_NNL&quot;</span>},</div>
<div class="line">    {namedlist_remove, <span class="stringliteral">&quot;remove_from_NNL&quot;</span>},</div>
<div class="line">    {namedlist_delete, <span class="stringliteral">&quot;delete_NNL&quot;</span>},</div>
<div class="line">    {graphmod_edit_node, <span class="stringliteral">&quot;edit_node&quot;</span>},</div>
<div class="line">    {graphmod_edit_edge, <span class="stringliteral">&quot;edit_edge&quot;</span>},</div>
<div class="line">    {batchmod_targetdates, <span class="stringliteral">&quot;batch_targetdates&quot;</span>},</div>
<div class="line">    {batchmod_tpassrepeating, <span class="stringliteral">&quot;batch_tpassrepeating&quot;</span>},</div>
<div class="line">    {graphmod_remove_edge, <span class="stringliteral">&quot;remove_edge&quot;</span>}</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a15799708deb829c9e79b07585c3d887f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15799708deb829c9e79b07585c3d887f">&#9670;&nbsp;</a></span>href_match_vec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt; fz::href_match_vec</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <span class="stringliteral">&quot;a &quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;href&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;=&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;\&quot;&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac04ef6e0f35fe1bf076661e5cdddc084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04ef6e0f35fe1bf076661e5cdddc084">&#9670;&nbsp;</a></span>html_special_codes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, std::string&gt; fz::html_special_codes</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    {<span class="stringliteral">&quot;&amp;lt;&quot;</span>, <span class="stringliteral">&quot;&lt;&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;&amp;gt;&quot;</span>, <span class="stringliteral">&quot;&gt;&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;&amp;nbsp;&quot;</span>, <span class="stringliteral">&quot; &quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;&amp;quot;&quot;</span>, <span class="stringliteral">&quot;\&quot;&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;&amp;amp;&quot;</span>, <span class="stringliteral">&quot;&amp;&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;&amp;apos;&quot;</span>, <span class="stringliteral">&quot;&#39;&quot;</span>}</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>This is only a partial list. </p>
<p>See <a href="https://www.rapidtables.com/web/html/html-codes.html">https://www.rapidtables.com/web/html/html-codes.html</a> for more information about HTML character codes, special codes, etc. To convert them all you would need to take a different approach to handling "&amp;...;" codes. </p>

</div>
</div>
<a id="ab7c6b78f22faaba74483392e9188a336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c6b78f22faaba74483392e9188a336">&#9670;&nbsp;</a></span>http_response_code_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;http_response_code, std::string&gt; fz::http_response_code_map</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    {http_ok, <span class="stringliteral">&quot;200 OK&quot;</span>},</div>
<div class="line">    {http_bad_request, <span class="stringliteral">&quot;400 Bad Request&quot;</span>},</div>
<div class="line">    {http_not_found, <span class="stringliteral">&quot;404 Not Found&quot;</span>}</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aeab0d860bf18ea1cc2acb7577f4f294f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab0d860bf18ea1cc2acb7577f4f294f">&#9670;&nbsp;</a></span>maintime</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfz_1_1ReferenceTime.html">ReferenceTime</a> fz::maintime</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Every program that uses core Formalizer functions that depend on time stamping includes <a class="el" href="ReferenceTime_8hpp_source.html">ReferenceTime.hpp</a> (it is automatically included through <a class="el" href="TimeStamp_8hpp.html" title="This header file declares Formalizer TimeStamp format and operations.">TimeStamp.hpp</a>). </p>
<p>The <code>maintime</code> object that is defined here provides time status for the main scope of the program. Additional <a class="el" href="classfz_1_1ReferenceTime.html">ReferenceTime</a> objects can be created as needed. </p>

</div>
</div>
<a id="abc2e6fb9c1745757fd6019d8546038b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2e6fb9c1745757fd6019d8546038b5">&#9670;&nbsp;</a></span>NODE_ID_STRSZ</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t fz::NODE_ID_STRSZ = 16+1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reusable directly from Graphtypes: </p>
<p><a class="el" href="structfz_1_1ID__TimeStamp.html" title="Timestamp IDs in the format required for Node IDs.">ID_TimeStamp</a> <a class="el" href="structfz_1_1Node__ID__key.html" title="Standardized Formalizer Node ID key.">Node_ID_key</a> <a class="el" href="structfz_1_1Edge__ID__key.html" title="Standardized Formalizer Edge ID key.">Edge_ID_key</a> Keyword_Relevance Topic_ID td_property td_property_str (this array of strings does not change) td_pattern td_pattern_str (this array of strings does not change) <a class="el" href="classfz_1_1Edge.html">Edge</a></p>
<p>Needs replacement:</p>
<p><a class="el" href="classfz_1_1Node__ID.html" title="Node ID that caches its ID stamp for frequent use.">Node_ID</a> (idS_cache) <a class="el" href="classfz_1_1Edge__ID.html" title="Edge ID that caches its ID stamp for frequent use.">Edge_ID</a> (idS_cache) <a class="el" href="structfz_1_1Topic__Keyword.html">Topic_Keyword</a> (keyword) <a class="el" href="classfz_1_1Topic.html">Topic</a> (tag, title, keyrel) Topic_Tags_Vector <a class="el" href="classfz_1_1Topic__Tags.html" title="Topic tag data, arranged by integer Index-ID.">Topic_Tags</a> (topictags, topicbytag) Topics_Set Edges_Set <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> (id, topics, text, supedges, depedges) Node_Map Edge_Map Node_Index <a class="el" href="classfz_1_1Graph.html">Graph</a> (nodes, edges, topics, ) </p>

</div>
</div>
<a id="a891acb04fd8751af330b359683bf1f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891acb04fd8751af330b359683bf1f32">&#9670;&nbsp;</a></span>pq_chunk_fieldnames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::pq_chunk_fieldnames[_pqlc_NUM]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&quot;id&quot;</span>,</div>
<div class="line">                                                   <span class="stringliteral">&quot;nid&quot;</span>,</div>
<div class="line">                                                   <span class="stringliteral">&quot;tclose&quot;</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acc03bdd20fad96262b1e13b2bb897780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc03bdd20fad96262b1e13b2bb897780">&#9670;&nbsp;</a></span>pq_commands_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::pq_commands_str</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <span class="stringliteral">&quot;runsilent&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;log&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;simulate&quot;</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a58eb1389cf1205452a7dfd69e988dcb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58eb1389cf1205452a7dfd69e988dcb6">&#9670;&nbsp;</a></span>pq_edge_fieldnames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::pq_edge_fieldnames</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&quot;id&quot;</span>,</div>
<div class="line">                                                  <span class="stringliteral">&quot;dependency&quot;</span>,</div>
<div class="line">                                                  <span class="stringliteral">&quot;significance&quot;</span>,</div>
<div class="line">                                                  <span class="stringliteral">&quot;importance&quot;</span>,</div>
<div class="line">                                                  <span class="stringliteral">&quot;urgency&quot;</span>,</div>
<div class="line">                                                  <span class="stringliteral">&quot;priority&quot;</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a75e1faf355d3b06d2b95e06e207f1cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e1faf355d3b06d2b95e06e207f1cb7">&#9670;&nbsp;</a></span>pq_entry_fieldnames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::pq_entry_fieldnames[_pqle_NUM]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&quot;id&quot;</span>,</div>
<div class="line">                                                   <span class="stringliteral">&quot;nid&quot;</span>,</div>
<div class="line">                                                   <span class="stringliteral">&quot;text&quot;</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7fc3e17bc68db256eb5e791bd38a0224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc3e17bc68db256eb5e791bd38a0224">&#9670;&nbsp;</a></span>pq_history_fieldnames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::pq_history_fieldnames[3]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&quot;nid&quot;</span>,</div>
<div class="line">                                              <span class="stringliteral">&quot;chunkids&quot;</span>,</div>
<div class="line">                                              <span class="stringliteral">&quot;entryids&quot;</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0a3b61cbcee151ad5409ad5e01466cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a3b61cbcee151ad5409ad5e01466cd">&#9670;&nbsp;</a></span>pq_NNL_fieldnames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::pq_NNL_fieldnames</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&quot;name&quot;</span>,</div>
<div class="line">                                                  <span class="stringliteral">&quot;features&quot;</span>,</div>
<div class="line">                                                  <span class="stringliteral">&quot;maxsize&quot;</span>,</div>
<div class="line">                                                  <span class="stringliteral">&quot;nodeids&quot;</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae700e2bafc4331d3347a1962a14d7b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae700e2bafc4331d3347a1962a14d7b65">&#9670;&nbsp;</a></span>pq_node_fieldnames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::pq_node_fieldnames</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&quot;id&quot;</span>,</div>
<div class="line">                                                  <span class="stringliteral">&quot;topics&quot;</span>,</div>
<div class="line">                                                  <span class="stringliteral">&quot;topicrelevance&quot;</span>,</div>
<div class="line">                                                  <span class="stringliteral">&quot;valuation&quot;</span>,</div>
<div class="line">                                                  <span class="stringliteral">&quot;completion&quot;</span>,</div>
<div class="line">                                                  <span class="stringliteral">&quot;required&quot;</span>,</div>
<div class="line">                                                  <span class="stringliteral">&quot;text&quot;</span>,</div>
<div class="line">                                                  <span class="stringliteral">&quot;targetdate&quot;</span>,</div>
<div class="line">                                                  <span class="stringliteral">&quot;tdproperty&quot;</span>,</div>
<div class="line">                                                  <span class="stringliteral">&quot;isperiodic&quot;</span>,</div>
<div class="line">                                                  <span class="stringliteral">&quot;tdperiodic&quot;</span>,</div>
<div class="line">                                                  <span class="stringliteral">&quot;tdevery&quot;</span>,</div>
<div class="line">                                                  <span class="stringliteral">&quot;tdspan&quot;</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6fc52933ef4168620f90311de4df2a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc52933ef4168620f90311de4df2a78">&#9670;&nbsp;</a></span>pq_topic_fieldnames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::pq_topic_fieldnames</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&quot;id&quot;</span>,</div>
<div class="line">                                                   <span class="stringliteral">&quot;supid&quot;</span>,</div>
<div class="line">                                                   <span class="stringliteral">&quot;tag&quot;</span>,</div>
<div class="line">                                                   <span class="stringliteral">&quot;title&quot;</span>,</div>
<div class="line">                                                   <span class="stringliteral">&quot;keyword&quot;</span>,</div>
<div class="line">                                                   <span class="stringliteral">&quot;relevance&quot;</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7d66e38e251a8692684776b13aceacfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d66e38e251a8692684776b13aceacfe">&#9670;&nbsp;</a></span>safe_max_localtime</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const std::tm fz::safe_max_localtime</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    .tm_sec = 59,</div>
<div class="line">    .tm_min = 59,</div>
<div class="line">    .tm_hour = 23,</div>
<div class="line">    .tm_mday = 31,</div>
<div class="line">    .tm_mon = 11,</div>
<div class="line">    .tm_year = 9999 - 1900,</div>
<div class="line">    .tm_wday = dow_Friday,</div>
<div class="line">    .tm_isdst = -1</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a576c20054fa81e82da8f2aeb7c6ff559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576c20054fa81e82da8f2aeb7c6ff559">&#9670;&nbsp;</a></span>safe_undefined_localtime</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const std::tm fz::safe_undefined_localtime</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    .tm_sec = 0,</div>
<div class="line">    .tm_min = 0,</div>
<div class="line">    .tm_hour = 0,</div>
<div class="line">    .tm_mday = 1,</div>
<div class="line">    .tm_mon = 0,</div>
<div class="line">    .tm_year = 0,</div>
<div class="line">    .tm_wday = dow_Monday,</div>
<div class="line">    .tm_isdst = -1    </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a812e6aee98e3ba6635c8fc4bed8ad57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812e6aee98e3ba6635c8fc4bed8ad57c">&#9670;&nbsp;</a></span>standard</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfz_1_1the__standard__object.html">the_standard_object</a> fz::standard</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This object projects one unique and clear interface with settings for standardized Formalizer programs, including exit hooks and other important requirements. </p>
<p>The standard object for Formalizer programs. </p>

</div>
</div>
<a id="a4b29454d06889dc887c6a36ca1c8f83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b29454d06889dc887c6a36ca1c8f83b">&#9670;&nbsp;</a></span>td_pattern_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; std::string, td_pattern &gt; fz::td_pattern_map</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    {<span class="stringliteral">&quot;daily&quot;</span>, td_pattern::patt_daily},</div>
<div class="line">    {<span class="stringliteral">&quot;workdays&quot;</span>, td_pattern::patt_workdays},</div>
<div class="line">    {<span class="stringliteral">&quot;weekly&quot;</span>, td_pattern::patt_weekly},</div>
<div class="line">    {<span class="stringliteral">&quot;biweekly&quot;</span>, td_pattern::patt_biweekly},</div>
<div class="line">    {<span class="stringliteral">&quot;monthly&quot;</span>, td_pattern::patt_monthly},</div>
<div class="line">    {<span class="stringliteral">&quot;endofmonthoffset&quot;</span>, td_pattern::patt_endofmonthoffset},</div>
<div class="line">    {<span class="stringliteral">&quot;yearly&quot;</span>, td_pattern::patt_yearly},</div>
<div class="line">    {<span class="stringliteral">&quot;OLD_span&quot;</span>, td_pattern::OLD_patt_span},</div>
<div class="line">    {<span class="stringliteral">&quot;nonperiodic&quot;</span>, td_pattern::patt_nonperiodic},</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a64dd91504fdcea08cc7617a5314ec6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64dd91504fdcea08cc7617a5314ec6d2">&#9670;&nbsp;</a></span>td_pattern_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::td_pattern_str</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=  {</div>
<div class="line">    <span class="stringliteral">&quot;patt_daily&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;patt_workdays&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;patt_weekly&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;patt_biweekly&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;patt_monthly&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;patt_endofmonthoffset&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;patt_yearly&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;OLD_patt_span&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;patt_nonperiodic&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6bdf6ef39f17c7f41bec3c89e472b0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bdf6ef39f17c7f41bec3c89e472b0c7">&#9670;&nbsp;</a></span>td_property_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; std::string, <a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">td_property</a> &gt; fz::td_property_map</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    {<span class="stringliteral">&quot;unspecified&quot;</span>, td_property::unspecified},</div>
<div class="line">    {<span class="stringliteral">&quot;inherit&quot;</span>, td_property::inherit},</div>
<div class="line">    {<span class="stringliteral">&quot;variable&quot;</span>, td_property::variable},</div>
<div class="line">    {<span class="stringliteral">&quot;fixed&quot;</span>, td_property::fixed},</div>
<div class="line">    {<span class="stringliteral">&quot;exact&quot;</span>, td_property::exact}</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5946fa5b803240f1c0cd734f214c8c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5946fa5b803240f1c0cd734f214c8c15">&#9670;&nbsp;</a></span>td_property_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::td_property_str</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <span class="stringliteral">&quot;unspecified&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;inherit&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;variable&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;fixed&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;exact&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad7c65c6c42a33bdb3871ee3ce28ca0db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c65c6c42a33bdb3871ee3ce28ca0db">&#9670;&nbsp;</a></span>tdpatt_by_pqtdpatt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; std::string, td_pattern &gt; fz::tdpatt_by_pqtdpatt</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {{<span class="stringliteral">&quot;patt_daily&quot;</span>,td_pattern::patt_daily},</div>
<div class="line">                                                              {<span class="stringliteral">&quot;patt_workdays&quot;</span>,td_pattern::patt_workdays},</div>
<div class="line">                                                              {<span class="stringliteral">&quot;patt_weekly&quot;</span>,td_pattern::patt_weekly},</div>
<div class="line">                                                              {<span class="stringliteral">&quot;patt_biweekly&quot;</span>,td_pattern::patt_biweekly},</div>
<div class="line">                                                              {<span class="stringliteral">&quot;patt_monthly&quot;</span>,td_pattern::patt_monthly},</div>
<div class="line">                                                              {<span class="stringliteral">&quot;patt_endofmonthoffset&quot;</span>,td_pattern::patt_endofmonthoffset},</div>
<div class="line">                                                              {<span class="stringliteral">&quot;patt_yearly&quot;</span>,td_pattern::patt_yearly},</div>
<div class="line">                                                              {<span class="stringliteral">&quot;OLD_patt_span&quot;</span>,td_pattern::OLD_patt_span},</div>
<div class="line">                                                              {<span class="stringliteral">&quot;patt_nonperiodic&quot;</span>,td_pattern::patt_nonperiodic}}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a721c8cc078a6b39b2603c86680c0b573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721c8cc078a6b39b2603c86680c0b573">&#9670;&nbsp;</a></span>tdprop_by_pqtdprop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; std::string, <a class="el" href="namespacefz.html#a6c45e5e183774ed3322e5c3d445b3f70">td_property</a> &gt; fz::tdprop_by_pqtdprop</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {{<span class="stringliteral">&quot;unspecified&quot;</span>, td_property::unspecified},</div>
<div class="line">                                                               {<span class="stringliteral">&quot;inherit&quot;</span>, td_property::inherit},</div>
<div class="line">                                                               {<span class="stringliteral">&quot;variable&quot;</span>, td_property::variable},</div>
<div class="line">                                                               {<span class="stringliteral">&quot;fixed&quot;</span>, td_property::fixed},</div>
<div class="line">                                                               {<span class="stringliteral">&quot;exact&quot;</span>, td_property::exact}}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0448bb7f1a2a03d28a3e64ad9cb22a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0448bb7f1a2a03d28a3e64ad9cb22a61">&#9670;&nbsp;</a></span>tdpropbylabel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, Edit_flags_type&gt; fz::tdpropbylabel</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    {<span class="stringliteral">&quot;unspecified&quot;</span>, tdproperty_binary_pattern::unspecified},</div>
<div class="line">    {<span class="stringliteral">&quot;inherit&quot;</span>, tdproperty_binary_pattern::inherit},</div>
<div class="line">    {<span class="stringliteral">&quot;variable&quot;</span>, tdproperty_binary_pattern::variable},</div>
<div class="line">    {<span class="stringliteral">&quot;fixed&quot;</span>, tdproperty_binary_pattern::fixed},</div>
<div class="line">    {<span class="stringliteral">&quot;exact&quot;</span>, tdproperty_binary_pattern::exact},</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ace795313bd567e5ab648f4ab92598bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace795313bd567e5ab648f4ab92598bba">&#9670;&nbsp;</a></span>text_interpretation_flags_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, text_interpretation&gt; fz::text_interpretation_flags_map</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    {<span class="stringliteral">&quot;raw&quot;</span>, text_interpretation::raw},</div>
<div class="line">    {<span class="stringliteral">&quot;detect_links&quot;</span>, text_interpretation::detect_links},</div>
<div class="line">    {<span class="stringliteral">&quot;emptyline_is_par&quot;</span>, text_interpretation::emptyline_is_par},</div>
<div class="line">    {<span class="stringliteral">&quot;full_markdown&quot;</span>, text_interpretation::full_markdown}</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a05d8c691662e60b7f7a041e6d67ff4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d8c691662e60b7f7a041e6d67ff4ac">&#9670;&nbsp;</a></span>weekday_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string fz::weekday_str</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <span class="stringliteral">&quot;Sunday&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Monday&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Tuesday&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Wednesday&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Thursday&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Friday&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Saturday&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
