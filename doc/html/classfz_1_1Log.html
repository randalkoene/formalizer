<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Formalizer: fz::Log Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="formalizer-logo-20200907-41x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Formalizer
   &#160;<span id="projectnumber">2.0.0-0.1</span>
   </div>
   <div id="projectbrief">The Formalizer System Support Environment</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacefz.html">fz</a></li><li class="navelem"><a class="el" href="classfz_1_1Log.html">Log</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classfz_1_1Log-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fz::Log Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><h3><a class="el" href="classfz_1_1Log.html" title="Log">Log</a></h3>
 
 <a href="classfz_1_1Log.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Logtypes_8hpp_source.html">Logtypes.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for fz::Log:</div>
<div class="dyncontent">
<div class="center"><img src="classfz_1_1Log__inherit__graph.png" border="0" usemap="#fz_1_1Log_inherit__map" alt="Inheritance graph"/></div>
<map name="fz_1_1Log_inherit__map" id="fz_1_1Log_inherit__map">
<area shape="rect" id="node2" href="classfz_1_1Log__interval.html" title="This variant of Log is used by smart on&#45;demand Log caching modes. " alt="" coords="5,80,116,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for fz::Log:</div>
<div class="dyncontent">
<div class="center"><img src="classfz_1_1Log__coll__graph.png" border="0" usemap="#fz_1_1Log_coll__map" alt="Collaboration graph"/></div>
<map name="fz_1_1Log_coll__map" id="fz_1_1Log_coll__map">
<area shape="rect" id="node2" href="classfz_1_1Log__Breakpoints.html" title="Log Breakpoints (section starts)" alt="" coords="28,81,167,108"/>
<area shape="rect" id="node4" href="structfz_1_1Log__chunks__Deque.html" title="Log chunks (deque list)" alt="" coords="198,81,354,108"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad90229e620a657e83de68e649430936f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#ad90229e620a657e83de68e649430936f">setup_Chain_nodeprevnext</a> ()</td></tr>
<tr class="memdesc:ad90229e620a657e83de68e649430936f"><td class="mdescLeft">&#160;</td><td class="mdescRight">finalizing setup  <a href="#ad90229e620a657e83de68e649430936f">More...</a><br /></td></tr>
<tr class="separator:ad90229e620a657e83de68e649430936f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacb23e680bd446379c6597b62d27fb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#afacb23e680bd446379c6597b62d27fb7">setup_Entry_node_caches</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:afacb23e680bd446379c6597b62d27fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this after loading chunks and enties into the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a>.  <a href="#afacb23e680bd446379c6597b62d27fb7">More...</a><br /></td></tr>
<tr class="separator:afacb23e680bd446379c6597b62d27fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090e563e5880cf3508d1b878f4ea7f78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a090e563e5880cf3508d1b878f4ea7f78">setup_Chunk_node_caches</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a090e563e5880cf3508d1b878f4ea7f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this after loading entries into the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> with valid <a class="el" href="classfz_1_1Graph.html">Graph</a>.  <a href="#a090e563e5880cf3508d1b878f4ea7f78">More...</a><br /></td></tr>
<tr class="separator:a090e563e5880cf3508d1b878f4ea7f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031e4f5ab45a70e7c5d13d02e4ed986c"><td class="memItemLeft" align="right" valign="top">Log_entries_Map::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a031e4f5ab45a70e7c5d13d02e4ed986c">num_Entries</a> () const</td></tr>
<tr class="memdesc:a031e4f5ab45a70e7c5d13d02e4ed986c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this after loading entries into the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> with valid <a class="el" href="classfz_1_1Graph.html">Graph</a>.  <a href="#a031e4f5ab45a70e7c5d13d02e4ed986c">More...</a><br /></td></tr>
<tr class="separator:a031e4f5ab45a70e7c5d13d02e4ed986c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb1e2c42a22490950ed938e805f2a73"><td class="memItemLeft" align="right" valign="top"><a id="a9fb1e2c42a22490950ed938e805f2a73"></a>
Log_chunks_Deque::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>num_Chunks</b> () const</td></tr>
<tr class="separator:a9fb1e2c42a22490950ed938e805f2a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30d94fa32372d1b00e7a16c8ff9b1a6"><td class="memItemLeft" align="right" valign="top"><a id="ab30d94fa32372d1b00e7a16c8ff9b1a6"></a>
Log_chunk_ID_key_deque::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>num_Breakpoints</b> () const</td></tr>
<tr class="separator:ab30d94fa32372d1b00e7a16c8ff9b1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9cfc072f19ed88bb28c75ea246f379"><td class="memItemLeft" align="right" valign="top"><a id="aab9cfc072f19ed88bb28c75ea246f379"></a>
<a class="el" href="namespacefz.html#a005101cd3360f7440301c8c033b397f8">Log_entries_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#aab9cfc072f19ed88bb28c75ea246f379">get_Entries</a> ()</td></tr>
<tr class="memdesc:aab9cfc072f19ed88bb28c75ea246f379"><td class="mdescLeft">&#160;</td><td class="mdescRight">tables: references <br /></td></tr>
<tr class="separator:aab9cfc072f19ed88bb28c75ea246f379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1f345a554e541e4bccbd6a7b8997d0"><td class="memItemLeft" align="right" valign="top"><a id="a7d1f345a554e541e4bccbd6a7b8997d0"></a>
<a class="el" href="structfz_1_1Log__chunks__Deque.html">Log_chunks_Deque</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_Chunks</b> ()</td></tr>
<tr class="separator:a7d1f345a554e541e4bccbd6a7b8997d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f858728c0baa291563b1b0502df56fe"><td class="memItemLeft" align="right" valign="top"><a id="a4f858728c0baa291563b1b0502df56fe"></a>
<a class="el" href="classfz_1_1Log__Breakpoints.html">Log_Breakpoints</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_Breakpoints</b> ()</td></tr>
<tr class="separator:a4f858728c0baa291563b1b0502df56fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa84db4353ea130e2e681eae1524bbb"><td class="memItemLeft" align="right" valign="top"><a id="adaa84db4353ea130e2e681eae1524bbb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#adaa84db4353ea130e2e681eae1524bbb">add_earlier_Chunk</a> (const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> &amp;_tbegin, const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a> &amp;_nodeid, std::time_t _tclose)</td></tr>
<tr class="memdesc:adaa84db4353ea130e2e681eae1524bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">chunks table: extend <br /></td></tr>
<tr class="separator:adaa84db4353ea130e2e681eae1524bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a45df81e5da7687c2d79089e4ef891"><td class="memItemLeft" align="right" valign="top"><a id="a10a45df81e5da7687c2d79089e4ef891"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_later_Chunk</b> (const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> &amp;_tbegin, const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a> &amp;_nodeid, std::time_t _tclose)</td></tr>
<tr class="separator:a10a45df81e5da7687c2d79089e4ef891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba980cd73eed71a0209795b818c49ce"><td class="memItemLeft" align="right" valign="top"><a id="afba980cd73eed71a0209795b818c49ce"></a>
<a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#afba980cd73eed71a0209795b818c49ce">get_chunk</a> (Log_chunk_ptr_deque::size_type idx) const</td></tr>
<tr class="memdesc:afba980cd73eed71a0209795b818c49ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">chunks table: get chunk <br /></td></tr>
<tr class="separator:afba980cd73eed71a0209795b818c49ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ba64ccb08510ee710e7ea84c1b7a9b"><td class="memItemLeft" align="right" valign="top"><a id="ad8ba64ccb08510ee710e7ea84c1b7a9b"></a>
<a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_chunk</b> (const <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> chunk_idkey) const</td></tr>
<tr class="separator:ad8ba64ccb08510ee710e7ea84c1b7a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7138e427c58fd0a01fc0814cfce3bb1f"><td class="memItemLeft" align="right" valign="top"><a id="a7138e427c58fd0a01fc0814cfce3bb1f"></a>
<a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_chunk_id_key</b> (Log_chunk_ptr_deque::size_type idx) const</td></tr>
<tr class="separator:a7138e427c58fd0a01fc0814cfce3bb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb566ecc2d01e7da9ba9a5c67f5e421"><td class="memItemLeft" align="right" valign="top"><a id="aafb566ecc2d01e7da9ba9a5c67f5e421"></a>
Log_chunk_ptr_deque::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>find_chunk_by_key</b> (const <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> chunk_idkey) const</td></tr>
<tr class="separator:aafb566ecc2d01e7da9ba9a5c67f5e421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412a10b1f0ee8d66bd71c2f311de91e8"><td class="memItemLeft" align="right" valign="top"><a id="a412a10b1f0ee8d66bd71c2f311de91e8"></a>
std::pair&lt; Log_chunk_ptr_deque::size_type, <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>find_chunk_index_and_pointer</b> (const <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> chunk_id) const</td></tr>
<tr class="separator:a412a10b1f0ee8d66bd71c2f311de91e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3a077806fb7e1f5e1fef80f5618b84"><td class="memItemLeft" align="right" valign="top"><a id="a0e3a077806fb7e1f5e1fef80f5618b84"></a>
<a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a0e3a077806fb7e1f5e1fef80f5618b84">get_Breakpoint_first_chunk_id_key</a> (Log_chunk_ID_key_deque::size_type idx)</td></tr>
<tr class="memdesc:a0e3a077806fb7e1f5e1fef80f5618b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">breakpoints table: get breakpoint <br /></td></tr>
<tr class="separator:a0e3a077806fb7e1f5e1fef80f5618b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bed2ab878bd7a98ff05dae1d2775871"><td class="memItemLeft" align="right" valign="top"><a id="a8bed2ab878bd7a98ff05dae1d2775871"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>get_Breakpoint_first_chunk_id_str</b> (Log_chunk_ID_key_deque::size_type idx)</td></tr>
<tr class="separator:a8bed2ab878bd7a98ff05dae1d2775871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac254ac7142628b647e22f1155ab2818f"><td class="memItemLeft" align="right" valign="top"><a id="ac254ac7142628b647e22f1155ab2818f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>get_Breakpoint_Ymd_str</b> (Log_chunk_ID_key_deque::size_type idx)</td></tr>
<tr class="separator:ac254ac7142628b647e22f1155ab2818f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0882d4a1381efc00e9b6756e08c4c82"><td class="memItemLeft" align="right" valign="top"><a id="ab0882d4a1381efc00e9b6756e08c4c82"></a>
Log_chunk_ptr_deque::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#ab0882d4a1381efc00e9b6756e08c4c82">get_chunk_first_at_Breakpoint</a> (Log_chunk_ID_key_deque::size_type idx)</td></tr>
<tr class="memdesc:ab0882d4a1381efc00e9b6756e08c4c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">crossref tabless: chunks x breakpoints <br /></td></tr>
<tr class="separator:ab0882d4a1381efc00e9b6756e08c4c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ba43707098024e35c306f441ce2f73"><td class="memItemLeft" align="right" valign="top"><a id="ad6ba43707098024e35c306f441ce2f73"></a>
const <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#ad6ba43707098024e35c306f441ce2f73">find_Breakpoint_tstamp_before_chunk</a> (const <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> key)</td></tr>
<tr class="memdesc:ad6ba43707098024e35c306f441ce2f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">crossref tables: breakpoints x chunks <br /></td></tr>
<tr class="separator:ad6ba43707098024e35c306f441ce2f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12618c392b39a0257a9543bda470d899"><td class="memItemLeft" align="right" valign="top"><a id="a12618c392b39a0257a9543bda470d899"></a>
Log_chunk_ID_key_deque::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>find_Breakpoint_index_before_chunk</b> (const <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> key)</td></tr>
<tr class="separator:a12618c392b39a0257a9543bda470d899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e13bc413db72f27efaf578f72d8f2c"><td class="memItemLeft" align="right" valign="top"><a id="a64e13bc413db72f27efaf578f72d8f2c"></a>
Log_chunk_ID_key_deque::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>find_Breakpoint_index_before_entry</b> (const <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a> key)</td></tr>
<tr class="separator:a64e13bc413db72f27efaf578f72d8f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f97af34b6f83facb77381bf050fa77"><td class="memItemLeft" align="right" valign="top"><a id="a40f97af34b6f83facb77381bf050fa77"></a>
Log_chunk_ID_key_deque::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>find_Breakpoint_index_before_chaintarget</b> (const <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> &amp;chaintarget)</td></tr>
<tr class="separator:a40f97af34b6f83facb77381bf050fa77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52275040d91b5000109e383ffadaa10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefz.html#a33950887af9a1dfe223b82b40edc2b1f">Log_entry_iterator_interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#ae52275040d91b5000109e383ffadaa10">get_Entries_interval</a> (const <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a> interval_front, const <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a> interval_back)</td></tr>
<tr class="memdesc:ae52275040d91b5000109e383ffadaa10"><td class="mdescLeft">&#160;</td><td class="mdescRight">entries table: select interval, from chunk / time, to chunk / time / count  <a href="#ae52275040d91b5000109e383ffadaa10">More...</a><br /></td></tr>
<tr class="separator:ae52275040d91b5000109e383ffadaa10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae305baab36b45f3fa81b7982991ceaf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefz.html#a33950887af9a1dfe223b82b40edc2b1f">Log_entry_iterator_interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#ae305baab36b45f3fa81b7982991ceaf2">get_Entries_t_interval</a> (std::time_t t_from, std::time_t t_before)</td></tr>
<tr class="memdesc:ae305baab36b45f3fa81b7982991ceaf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pair of iterators that indicate the begin and end of an interval of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry objects, where those <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry objects all have ID keys that represent times t, with t_from &lt;= t &lt; t_before.  <a href="#ae305baab36b45f3fa81b7982991ceaf2">More...</a><br /></td></tr>
<tr class="separator:ae305baab36b45f3fa81b7982991ceaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298a3c832827a89df21911bde09b338a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefz.html#a33950887af9a1dfe223b82b40edc2b1f">Log_entry_iterator_interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a298a3c832827a89df21911bde09b338a">get_Entries_interval</a> (const <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a> interval_front, unsigned long n)</td></tr>
<tr class="memdesc:a298a3c832827a89df21911bde09b338a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pair of iterators that indicate the begin and end of an interval of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry objects.  <a href="#a298a3c832827a89df21911bde09b338a">More...</a><br /></td></tr>
<tr class="separator:a298a3c832827a89df21911bde09b338a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365fb4d3749b122fd98c1b7506647a20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefz.html#a33950887af9a1dfe223b82b40edc2b1f">Log_entry_iterator_interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a365fb4d3749b122fd98c1b7506647a20">get_Entries_n_interval</a> (std::time_t t_from, unsigned long n)</td></tr>
<tr class="memdesc:a365fb4d3749b122fd98c1b7506647a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pair of iterators that indicate the begin and end of an interval of up to n <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry objects.  <a href="#a365fb4d3749b122fd98c1b7506647a20">More...</a><br /></td></tr>
<tr class="separator:a365fb4d3749b122fd98c1b7506647a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c6c3750a23f52c04f850ce6c85e5c0"><td class="memItemLeft" align="right" valign="top">Log_chunk_ID_interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a07c6c3750a23f52c04f850ce6c85e5c0">get_Chunks_ID_t_interval</a> (std::time_t t_from, std::time_t t_before)</td></tr>
<tr class="memdesc:a07c6c3750a23f52c04f850ce6c85e5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">chunks table: select interval, from chunk / time, to chunk / time / count  <a href="#a07c6c3750a23f52c04f850ce6c85e5c0">More...</a><br /></td></tr>
<tr class="separator:a07c6c3750a23f52c04f850ce6c85e5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740b87f036296573f8e615a221cd0939"><td class="memItemLeft" align="right" valign="top">Log_chunk_ID_interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a740b87f036296573f8e615a221cd0939">get_Chunks_ID_n_interval</a> (std::time_t t_from, unsigned long n)</td></tr>
<tr class="memdesc:a740b87f036296573f8e615a221cd0939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an interval of n <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks with t_begin &gt;= t_from.  <a href="#a740b87f036296573f8e615a221cd0939">More...</a><br /></td></tr>
<tr class="separator:a740b87f036296573f8e615a221cd0939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff14b4042df0cbc66c33dd605d214941"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefz.html#ac54d7dcc5daf1d7c28a31a9ea2f2064a">Log_chunk_index_interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#aff14b4042df0cbc66c33dd605d214941">get_Chunks_index_t_interval</a> (std::time_t t_from, std::time_t t_before)</td></tr>
<tr class="memdesc:aff14b4042df0cbc66c33dd605d214941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interval of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks with t_from &lt;= t_begin &lt; t_before.  <a href="#aff14b4042df0cbc66c33dd605d214941">More...</a><br /></td></tr>
<tr class="separator:aff14b4042df0cbc66c33dd605d214941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753299dbf5c12efdf9e232a5e42a5428"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefz.html#ac54d7dcc5daf1d7c28a31a9ea2f2064a">Log_chunk_index_interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a753299dbf5c12efdf9e232a5e42a5428">get_Chunks_index_n_interval</a> (std::time_t t_from, unsigned long n)</td></tr>
<tr class="memdesc:a753299dbf5c12efdf9e232a5e42a5428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an interval of n <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks with t_begin &gt;= t_from.  <a href="#a753299dbf5c12efdf9e232a5e42a5428">More...</a><br /></td></tr>
<tr class="separator:a753299dbf5c12efdf9e232a5e42a5428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec7c92bd3d4b9c8806bc6c5fb5041d8"><td class="memItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a1ec7c92bd3d4b9c8806bc6c5fb5041d8">get_Node_chain_fullparse</a> (const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a> node_id, bool onlyfirst=false)</td></tr>
<tr class="memdesc:a1ec7c92bd3d4b9c8806bc6c5fb5041d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">chunks table: select subset by <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a>  <a href="#a1ec7c92bd3d4b9c8806bc6c5fb5041d8">More...</a><br /></td></tr>
<tr class="separator:a1ec7c92bd3d4b9c8806bc6c5fb5041d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4266e49a3045dba72a9daed76a5f263b"><td class="memItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a4266e49a3045dba72a9daed76a5f263b">get_Node_chain_fullparse_reverse</a> (const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a> node_id, bool onlylast=false)</td></tr>
<tr class="memdesc:a4266e49a3045dba72a9daed76a5f263b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse all chunks connected to the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> - in reverse - and find the sequence of chunks and entries that belongs to a specific <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a>.  <a href="#a4266e49a3045dba72a9daed76a5f263b">More...</a><br /></td></tr>
<tr class="separator:a4266e49a3045dba72a9daed76a5f263b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e54df7bb54ae553ef9e5b93ce85904"><td class="memItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a65e54df7bb54ae553ef9e5b93ce85904">get_Node_chain</a> (const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a> node_id)</td></tr>
<tr class="memdesc:a65e54df7bb54ae553ef9e5b93ce85904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quickly walk through the reference chain that belongs to the specified <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> and return all of its <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks and <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries.  <a href="#a65e54df7bb54ae553ef9e5b93ce85904">More...</a><br /></td></tr>
<tr class="separator:a65e54df7bb54ae553ef9e5b93ce85904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcef1ab3169e986a5a58902772ab643"><td class="memItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a3fcef1ab3169e986a5a58902772ab643">get_Node_chain_reverse</a> (const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a> node_id)</td></tr>
<tr class="memdesc:a3fcef1ab3169e986a5a58902772ab643"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version requires valid prev/next references.  <a href="#a3fcef1ab3169e986a5a58902772ab643">More...</a><br /></td></tr>
<tr class="separator:a3fcef1ab3169e986a5a58902772ab643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d043044e1a641a61dd2ea0bb6c514a"><td class="memItemLeft" align="right" valign="top"><a id="a10d043044e1a641a61dd2ea0bb6c514a"></a>
const <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>newest_Node_chain_element</b> (const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a> node_id)</td></tr>
<tr class="separator:a10d043044e1a641a61dd2ea0bb6c514a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98819789423a2712d06bae307e4313ed"><td class="memItemLeft" align="right" valign="top"><a id="a98819789423a2712d06bae307e4313ed"></a>
const <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>oldest_Node_chain_element</b> (const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a> node_id)</td></tr>
<tr class="separator:a98819789423a2712d06bae307e4313ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab723cd177104b779811f8eec827b7a60"><td class="memItemLeft" align="right" valign="top"><a id="ab723cd177104b779811f8eec827b7a60"></a>
std::time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#ab723cd177104b779811f8eec827b7a60">oldest_chunk_t</a> ()</td></tr>
<tr class="memdesc:ab723cd177104b779811f8eec827b7a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper (utility) functions <br /></td></tr>
<tr class="separator:ab723cd177104b779811f8eec827b7a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a3b1472b02370bd7687e3c209261b9"><td class="memItemLeft" align="right" valign="top"><a id="a30a3b1472b02370bd7687e3c209261b9"></a>
std::time_t&#160;</td><td class="memItemRight" valign="bottom"><b>newest_chunk_t</b> ()</td></tr>
<tr class="separator:a30a3b1472b02370bd7687e3c209261b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac448c8de85ac26d5ec0e3e36b5267e67"><td class="memItemLeft" align="right" valign="top"><a id="ac448c8de85ac26d5ec0e3e36b5267e67"></a>
<a class="el" href="namespacefz.html#a005101cd3360f7440301c8c033b397f8">Log_entries_Map</a>&#160;</td><td class="memItemRight" valign="bottom"><b>entries</b></td></tr>
<tr class="separator:ac448c8de85ac26d5ec0e3e36b5267e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fd73404d37ad99114bb4c881ea0a21"><td class="memItemLeft" align="right" valign="top"><a id="a17fd73404d37ad99114bb4c881ea0a21"></a>
<a class="el" href="structfz_1_1Log__chunks__Deque.html">Log_chunks_Deque</a>&#160;</td><td class="memItemRight" valign="bottom"><b>chunks</b></td></tr>
<tr class="separator:a17fd73404d37ad99114bb4c881ea0a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f24377ed6f241c8d83730053795784"><td class="memItemLeft" align="right" valign="top"><a id="a68f24377ed6f241c8d83730053795784"></a>
<a class="el" href="classfz_1_1Log__Breakpoints.html">Log_Breakpoints</a>&#160;</td><td class="memItemRight" valign="bottom"><b>breakpoints</b></td></tr>
<tr class="separator:a68f24377ed6f241c8d83730053795784"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aaf4bdbb4c920f1fa4133c1252b486c54"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Log_chunks_Deque::size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#aaf4bdbb4c920f1fa4133c1252b486c54">Breakpoint_Indices</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:aaf4bdbb4c920f1fa4133c1252b486c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">This converts the list of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> breakpoint <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk IDs into a list of indices into the list of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks (in Log::chunks).  <a href="#aaf4bdbb4c920f1fa4133c1252b486c54">More...</a><br /></td></tr>
<tr class="separator:aaf4bdbb4c920f1fa4133c1252b486c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2146ddb58a16dfe67aab15c9512a1cf5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Log_chunks_Deque::size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a2146ddb58a16dfe67aab15c9512a1cf5">Chunks_per_Breakpoint</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:a2146ddb58a16dfe67aab15c9512a1cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the frequency distribution for the number of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks per <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> breakpoint.  <a href="#a2146ddb58a16dfe67aab15c9512a1cf5">More...</a><br /></td></tr>
<tr class="separator:a2146ddb58a16dfe67aab15c9512a1cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8571d0bb6aad25c78696fc8c3dcc1a"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#aff8571d0bb6aad25c78696fc8c3dcc1a">Log_span_in_seconds</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:aff8571d0bb6aad25c78696fc8c3dcc1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the span in seconds from when the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was started (first cunk) to its most recent chunk.  <a href="#aff8571d0bb6aad25c78696fc8c3dcc1a">More...</a><br /></td></tr>
<tr class="separator:aff8571d0bb6aad25c78696fc8c3dcc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bce55e40ccb0a64160c64e30acaaa0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a49bce55e40ccb0a64160c64e30acaaa0">Log_span_in_days</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:a49bce55e40ccb0a64160c64e30acaaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the span in days from when the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was started (first cunk) to its most recent chunk.  <a href="#a49bce55e40ccb0a64160c64e30acaaa0">More...</a><br /></td></tr>
<tr class="separator:a49bce55e40ccb0a64160c64e30acaaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf04470fdb14a1ee2b7271a55413b583"><td class="memItemLeft" align="right" valign="top">ymd_tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#aaf04470fdb14a1ee2b7271a55413b583">Log_span_years_months_days</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:aaf04470fdb14a1ee2b7271a55413b583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the span in years, months and days from when the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was started (first cunk) to its most recent chunk.  <a href="#aaf04470fdb14a1ee2b7271a55413b583">More...</a><br /></td></tr>
<tr class="separator:aaf04470fdb14a1ee2b7271a55413b583"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3><a class="el" href="classfz_1_1Log.html" title="Log">Log</a></h3>
<p>This data structure is used to organize <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry elements into <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk intervals and, for backwards compatibility with <code>dil2al</code>, to indicate which <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks follow a Breakpoint and start a new section.</p>
<p>Note that sections are not used with the database storage format. Conversion back to <code>dil2al</code> Task <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> files will need to add new Breakpoints at sensible intervals beyond the last original section Breakpoint.</p>
<p>*** At this time, the functions below have only been tested in the case where the whole <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> is in-memory. Care will need to be taken to make sure things work as intended when only portions of the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> are loaded into memory. Alternatively, a separate but similar class could be defined in order to avoid any confusion. Or, the functions that find/get specific chunks or entries could be given some smarts where <em>not found</em> first leads to an attempt to find and load from database. In that case, there will also have to be some process behind the scenes that can gradually release in-memory <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> portions again, otherwise it will always end up being the whole <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> when a server is an active process for a long time. <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> requests could be handled by a separate server, which could be explicitly <em>not</em> daemonized, so that it will always release memory after serving up some <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> data. (See the Trello card at <a href="https://trello.com/c/EppSyY9Y">https://trello.com/c/EppSyY9Y</a>.) </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a740b87f036296573f8e615a221cd0939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740b87f036296573f8e615a221cd0939">&#9670;&nbsp;</a></span>get_Chunks_ID_n_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Log_chunk_ID_interval fz::Log::get_Chunks_ID_n_interval </td>
          <td>(</td>
          <td class="paramtype">std::time_t&#160;</td>
          <td class="paramname"><em>t_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an interval of n <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks with t_begin &gt;= t_from. </p>
<p>The interval is returned as a pair of <a class="el" href="structfz_1_1Log__chunk__ID__key.html" title="Standardized Formalizer Log chunk ID key. ">Log_chunk_ID_key</a> objects and is inclusive. Both ID keys belong to <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks within the interval. If the interval is empty then a pair of null-key are returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_from</td><td>is the earliest UNIX epoch time within the interval. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks to include in the interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk ID keys. </dd></dl>

</div>
</div>
<a id="a07c6c3750a23f52c04f850ce6c85e5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c6c3750a23f52c04f850ce6c85e5c0">&#9670;&nbsp;</a></span>get_Chunks_ID_t_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Log_chunk_ID_interval fz::Log::get_Chunks_ID_t_interval </td>
          <td>(</td>
          <td class="paramtype">std::time_t&#160;</td>
          <td class="paramname"><em>t_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::time_t&#160;</td>
          <td class="paramname"><em>t_before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>chunks table: select interval, from chunk / time, to chunk / time / count </p>
<p>Get the interval of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks with t_from &lt;= t_begin &lt; t_before.</p>
<p>The interval is returned as a pair of <a class="el" href="structfz_1_1Log__chunk__ID__key.html" title="Standardized Formalizer Log chunk ID key. ">Log_chunk_ID_key</a> objects and is inclusive. Both ID keys belong to <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks within the interval. If the interval is empty then a pair of null-key are returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_from</td><td>is the earliest UNIX epoch time within the interval. </td></tr>
    <tr><td class="paramname">t_before</td><td>is the UNIX epoch time 1 second after the interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk ID keys. </dd></dl>

</div>
</div>
<a id="a753299dbf5c12efdf9e232a5e42a5428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753299dbf5c12efdf9e232a5e42a5428">&#9670;&nbsp;</a></span>get_Chunks_index_n_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefz.html#ac54d7dcc5daf1d7c28a31a9ea2f2064a">Log_chunk_index_interval</a> fz::Log::get_Chunks_index_n_interval </td>
          <td>(</td>
          <td class="paramtype">std::time_t&#160;</td>
          <td class="paramname"><em>t_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an interval of n <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks with t_begin &gt;= t_from. </p>
<p>The interval is returned as a pair of indices and is inclusive. Both indices are within the interval. If the interval is empty then the indices are set to chunks.size(), beyond the range of valid indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_from</td><td>is the earliest UNIX epoch time within the interval. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks to include in the interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of indices bounding <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks within the interval, or a pair of indices beyond the range of existing <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks if no <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks were found for the interval. </dd></dl>

</div>
</div>
<a id="aff14b4042df0cbc66c33dd605d214941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff14b4042df0cbc66c33dd605d214941">&#9670;&nbsp;</a></span>get_Chunks_index_t_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefz.html#ac54d7dcc5daf1d7c28a31a9ea2f2064a">Log_chunk_index_interval</a> fz::Log::get_Chunks_index_t_interval </td>
          <td>(</td>
          <td class="paramtype">std::time_t&#160;</td>
          <td class="paramname"><em>t_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::time_t&#160;</td>
          <td class="paramname"><em>t_before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the interval of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks with t_from &lt;= t_begin &lt; t_before. </p>
<p>The interval is returned as a pair of indices and is inclusive. Both indices are within the interval. If the interval is empty then the indices are set to chunks.size(), beyond the range of valid indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_from</td><td>is the earliest UNIX epoch time within the interval. </td></tr>
    <tr><td class="paramname">t_before</td><td>is the UNIX epoch time 1 second after the interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of indices bounding <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks within the interval, or a pair of indices beyond the range of existing <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks if no <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks have start times within the interval. </dd></dl>

</div>
</div>
<a id="ae52275040d91b5000109e383ffadaa10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52275040d91b5000109e383ffadaa10">&#9670;&nbsp;</a></span>get_Entries_interval() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefz.html#a33950887af9a1dfe223b82b40edc2b1f">Log_entry_iterator_interval</a> fz::Log::get_Entries_interval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a>&#160;</td>
          <td class="paramname"><em>interval_front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a>&#160;</td>
          <td class="paramname"><em>interval_back</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>entries table: select interval, from chunk / time, to chunk / time / count </p>
<p>Get a pair of iterators that indicate the begin and end of an interval of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry objects.</p>
<p>Both <code>interval_front</code> and <code>interval_back</code> must exist in the map of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries. Otherwise, a pair of out-of-range iterators set to entries.end() are returned.</p>
<p>Note that the second iterator returned behaves like all end() iterators of C++ STL containers. In other words, it points to the object 1 beyond the object identified by <code>interval_back</code>. If that the <code>interval_back</code> object was the last entry then the second iterator == entries.end().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval_front</td><td>is the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry ID key of an entry in the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a>. </td></tr>
    <tr><td class="paramname">interval_back</td><td>is the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry ID key of an entry in the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of iterators describing the begin and end of a subset of entries. </dd></dl>

</div>
</div>
<a id="a298a3c832827a89df21911bde09b338a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298a3c832827a89df21911bde09b338a">&#9670;&nbsp;</a></span>get_Entries_interval() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefz.html#a33950887af9a1dfe223b82b40edc2b1f">Log_entry_iterator_interval</a> fz::Log::get_Entries_interval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a>&#160;</td>
          <td class="paramname"><em>interval_front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pair of iterators that indicate the begin and end of an interval of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry objects. </p>
<p>The <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry with <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry ID key <code>interval_front</code> must exist in the map of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries and n &gt; 0. Otherwise, a pair of out-of-range iterators set to entries.end() are returned.</p>
<p>Note that the second iterator returned behaves like all end() iterators of C++ STL containers. In other words, it points to the object 1 beyond the nth object in the interval, or it is entries.end().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval_front</td><td>is the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry ID key of an entry in the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a>. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries to include in the interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of iterators describing the begin and end of a subset of entries. </dd></dl>

</div>
</div>
<a id="a365fb4d3749b122fd98c1b7506647a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365fb4d3749b122fd98c1b7506647a20">&#9670;&nbsp;</a></span>get_Entries_n_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefz.html#a33950887af9a1dfe223b82b40edc2b1f">Log_entry_iterator_interval</a> fz::Log::get_Entries_n_interval </td>
          <td>(</td>
          <td class="paramtype">std::time_t&#160;</td>
          <td class="paramname"><em>t_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pair of iterators that indicate the begin and end of an interval of up to n <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry objects. </p>
<p>The <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry objects all have ID keys that represent times t, with t_from &lt;= t, and n &gt; 0. Aa pair of out-of-range iterators set to entries.end() are returned if these conditions cannot be met or if the interval is empty.</p>
<p>Note that the second iterator returned behaves like all end() iterators of C++ STL containers. In other words, it points to the object with <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry ID key representing a time at or beyond t_before, which may be entries.end().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_from</td><td>is the earliest UNIX epoch time within the interval. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries to include in the interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of iterators describing the begin and end of a subset of entries. </dd></dl>

</div>
</div>
<a id="ae305baab36b45f3fa81b7982991ceaf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae305baab36b45f3fa81b7982991ceaf2">&#9670;&nbsp;</a></span>get_Entries_t_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefz.html#a33950887af9a1dfe223b82b40edc2b1f">Log_entry_iterator_interval</a> fz::Log::get_Entries_t_interval </td>
          <td>(</td>
          <td class="paramtype">std::time_t&#160;</td>
          <td class="paramname"><em>t_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::time_t&#160;</td>
          <td class="paramname"><em>t_before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pair of iterators that indicate the begin and end of an interval of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry objects, where those <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry objects all have ID keys that represent times t, with t_from &lt;= t &lt; t_before. </p>
<p>If the interval is entirely outside of the times represented by exissting <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries then a pair of out-of-range iterators set to entries.end() are returned.</p>
<p>Note that the second iterator returned behaves like all end() iterators of C++ STL containers. In other words, it points to the object with <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entry ID key representing a time at or beyond t_before, which may be entries.end().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_from</td><td>is the earliest UNIX epoch time within the interval. </td></tr>
    <tr><td class="paramname">t_before</td><td>is the UNIX epoch time 1 second after the interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of iterators describing the begin and end of a subset of entries. </dd></dl>

</div>
</div>
<a id="a65e54df7bb54ae553ef9e5b93ce85904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e54df7bb54ae553ef9e5b93ce85904">&#9670;&nbsp;</a></span>get_Node_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> &gt; fz::Log::get_Node_chain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quickly walk through the reference chain that belongs to the specified <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> and return all of its <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks and <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries. </p>
<p>Note A: This function depends on valid rapid-access pointers within <code>node_prev</code> and <code>node_next</code> variables in each <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk and entry. Note B: This function (presently) works by building a brand-new deque list with <a class="el" href="structfz_1_1Log__chain__target.html" title="This data structure is used to follow a chain by-Node through the Log that can lead to Log chunks or ...">Log_chain_target</a> copies (instead of references). This decision is based on the assumption that the list of targets is typically informative, providing necessary access info to those targets, but you don't accidentally want to break existing chains by modifying elements of the deque list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>of the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> for which to collect its <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chain (history). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a deque sorted list of chain targets found. </dd></dl>

</div>
</div>
<a id="a1ec7c92bd3d4b9c8806bc6c5fb5041d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec7c92bd3d4b9c8806bc6c5fb5041d8">&#9670;&nbsp;</a></span>get_Node_chain_fullparse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> &gt; fz::Log::get_Node_chain_fullparse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyfirst</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>chunks table: select subset by <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> </p>
<p>Parse all chunks connected to the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> and find the sequence of chunks and entries that belongs to a specific <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a>.</p>
<p>This is used by Log::setup_Chunk_nodeprevnext(), and it can also be used independent of the reference parameters in the <a class="el" href="classfz_1_1Log__chunk.html" title="Specifies the start time, Node, close time, and set of entries of a Log chunk. ">Log_chunk</a> objects, which even works for arbitrary loaded lists of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks.</p>
<p>This function is also used by the rapid search version <code><a class="el" href="classfz_1_1Log.html#a65e54df7bb54ae553ef9e5b93ce85904" title="Quickly walk through the reference chain that belongs to the specified Node and return all of its Log...">get_Node_chain()</a></code>, which calls this to find the first target, the head of the chain, which is specifeid via the <code>onlyfirst</code> parameter.</p>
<p>This function requires that the <code>entries</code> list has been set up for all <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>of the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> for which to collect its <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chain (history). </td></tr>
    <tr><td class="paramname">onlyfirst</td><td>flag if true return only the first target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a deque sorted list of chain targets found. </dd></dl>

</div>
</div>
<a id="a4266e49a3045dba72a9daed76a5f263b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4266e49a3045dba72a9daed76a5f263b">&#9670;&nbsp;</a></span>get_Node_chain_fullparse_reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> &gt; fz::Log::get_Node_chain_fullparse_reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlylast</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse all chunks connected to the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> - in reverse - and find the sequence of chunks and entries that belongs to a specific <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a>. </p>
<p>Reverse search is probably a good option, because often referenced <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> histories are likely those of recent Nodes with recent <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries.</p>
<p>This can be used independent of the reference parameters in the <a class="el" href="classfz_1_1Log__chunk.html" title="Specifies the start time, Node, close time, and set of entries of a Log chunk. ">Log_chunk</a> objects, hence even works for arbitrary loaded lists of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks.</p>
<p>This function requires that the <code>entries</code> list has been set up for all <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>of the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> for which to collect its <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chain (history). </td></tr>
    <tr><td class="paramname">onlylast</td><td>flag if true return only the last target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a deque sorted list of chain targets found. </dd></dl>

</div>
</div>
<a id="a3fcef1ab3169e986a5a58902772ab643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fcef1ab3169e986a5a58902772ab643">&#9670;&nbsp;</a></span>get_Node_chain_reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> &gt; fz::Log::get_Node_chain_reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This version requires valid prev/next references. </p>
<p>Quickly walk through the reference chain - in reverse - that belongs to the specified <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> and return all of its <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks and <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries.</p>
<p>Reverse search is probably a good option, because often referenced <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> histories are likely those of recent Nodes with recent <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries.</p>
<p>Note A: This function depends on valid rapid-access pointers within <code>node_prev</code> and <code>node_next</code> variables in each <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk and entry. Note B: This function (presently) works by building a brand-new deque list with <a class="el" href="structfz_1_1Log__chain__target.html" title="This data structure is used to follow a chain by-Node through the Log that can lead to Log chunks or ...">Log_chain_target</a> copies (instead of references). This decision is based on the assumption that the list of targets is typically informative, providing necessary access info to those targets, but you don't accidentally want to break existing chains by modifying elements of the deque list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>of the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> for which to collect its <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chain (history). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a deque sorted list of chain targets found. </dd></dl>

</div>
</div>
<a id="a031e4f5ab45a70e7c5d13d02e4ed986c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031e4f5ab45a70e7c5d13d02e4ed986c">&#9670;&nbsp;</a></span>num_Entries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Log_entries_Map::size_type fz::Log::num_Entries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this after loading entries into the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> with valid <a class="el" href="classfz_1_1Graph.html">Graph</a>. </p>
<p>tables: sizes </p>

</div>
</div>
<a id="ad90229e620a657e83de68e649430936f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90229e620a657e83de68e649430936f">&#9670;&nbsp;</a></span>setup_Chain_nodeprevnext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::Log::setup_Chain_nodeprevnext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finalizing setup </p>
<p>Parse the deque list of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks, as well as their entries, and assign all references in <code>node_prev</code>, <code>node_next</code>, and their rapid-access pointers.</p>
<p>This is all done using references by ID within the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> data structure. No <a class="el" href="classfz_1_1Graph.html">Graph</a> object is required. </p>

</div>
</div>
<a id="a090e563e5880cf3508d1b878f4ea7f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090e563e5880cf3508d1b878f4ea7f78">&#9670;&nbsp;</a></span>setup_Chunk_node_caches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::Log::setup_Chunk_node_caches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this after loading entries into the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> with valid <a class="el" href="classfz_1_1Graph.html">Graph</a>. </p>
<p>Parse the deque of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks and assign all <code>node</code> cache pointers in acordance with <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> objects found in the <a class="el" href="classfz_1_1Graph.html">Graph</a>. </p>

</div>
</div>
<a id="afacb23e680bd446379c6597b62d27fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afacb23e680bd446379c6597b62d27fb7">&#9670;&nbsp;</a></span>setup_Entry_node_caches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::Log::setup_Entry_node_caches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this after loading chunks and enties into the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a>. </p>
<p>Parse the map of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> entries and assign all <code>node</code> cache pointers in acordance with <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph. ">Node</a> objects found in the <a class="el" href="classfz_1_1Graph.html">Graph</a>. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aaf4bdbb4c920f1fa4133c1252b486c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4bdbb4c920f1fa4133c1252b486c54">&#9670;&nbsp;</a></span>Breakpoint_Indices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Log_chunks_Deque::size_type&gt; Breakpoint_Indices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This converts the list of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> breakpoint <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunk IDs into a list of indices into the list of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks (in Log::chunks). </p>
<p>Note: All <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks must be loaded into memory before calling this function.</p>
<p>If a breakpoint was not found then the corresponding element of the vector of indices has the value log::num_Chunks(), pointing beyond all valid <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks in the deque.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> object where all <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks are in the chunks deque. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of indices into log::chunks. </dd></dl>

</div>
</div>
<a id="a2146ddb58a16dfe67aab15c9512a1cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2146ddb58a16dfe67aab15c9512a1cf5">&#9670;&nbsp;</a></span>Chunks_per_Breakpoint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Log_chunks_Deque::size_type&gt; Chunks_per_Breakpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the frequency distribution for the number of <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks per <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> breakpoint. </p>
<p>Note: All <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks must be loaded into memory before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>a <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> object where all <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> chunks are in the chunks deque. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of counts. </dd></dl>

</div>
</div>
<a id="a49bce55e40ccb0a64160c64e30acaaa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49bce55e40ccb0a64160c64e30acaaa0">&#9670;&nbsp;</a></span>Log_span_in_days</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Log_span_in_days </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report the span in days from when the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was started (first cunk) to its most recent chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> for which to report the span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the decimal number of days. </dd></dl>

</div>
</div>
<a id="aff8571d0bb6aad25c78696fc8c3dcc1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8571d0bb6aad25c78696fc8c3dcc1a">&#9670;&nbsp;</a></span>Log_span_in_seconds</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Log_span_in_seconds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report the span in seconds from when the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was started (first cunk) to its most recent chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> for which to report the span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of seconds. </dd></dl>

</div>
</div>
<a id="aaf04470fdb14a1ee2b7271a55413b583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf04470fdb14a1ee2b7271a55413b583">&#9670;&nbsp;</a></span>Log_span_years_months_days</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ymd_tuple Log_span_years_months_days </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report the span in years, months and days from when the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> was started (first cunk) to its most recent chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>the <a class="el" href="classfz_1_1Log.html" title="Log">Log</a> for which to report the span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple of [year, month, day]. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>core/include/<a class="el" href="Logtypes_8hpp_source.html">Logtypes.hpp</a></li>
<li>core/lib/Logtypes.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
