<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Formalizer: fz::Log Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="formalizer-logo-20200907-41x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Formalizer
   &#160;<span id="projectnumber">2.0.0-0.1</span>
   </div>
   <div id="projectbrief">The Formalizer System Support Environment</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacefz.html">fz</a></li><li class="navelem"><a class="el" href="classfz_1_1Log.html">Log</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classfz_1_1Log-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fz::Log Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Logtypes_8hpp_source.html">Logtypes.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for fz::Log:</div>
<div class="dyncontent">
<div class="center"><img src="classfz_1_1Log__coll__graph.png" border="0" usemap="#fz_1_1Log_coll__map" alt="Collaboration graph"/></div>
<map name="fz_1_1Log_coll__map" id="fz_1_1Log_coll__map">
<area shape="rect" title=" " alt="" coords="161,171,226,197"/>
<area shape="rect" href="classfz_1_1Log__Breakpoints.html" title=" " alt="" coords="30,81,181,108"/>
<area shape="rect" title=" " alt="" coords="5,5,195,32"/>
<area shape="rect" href="structfz_1_1Log__chunks__Map.html" title=" " alt="" coords="214,81,367,108"/>
<area shape="rect" title=" " alt="" coords="219,5,371,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad90229e620a657e83de68e649430936f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#ad90229e620a657e83de68e649430936f">setup_Chain_nodeprevnext</a> ()</td></tr>
<tr class="memdesc:ad90229e620a657e83de68e649430936f"><td class="mdescLeft">&#160;</td><td class="mdescRight">finalizing setup  <a href="classfz_1_1Log.html#ad90229e620a657e83de68e649430936f">More...</a><br /></td></tr>
<tr class="separator:ad90229e620a657e83de68e649430936f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacb23e680bd446379c6597b62d27fb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#afacb23e680bd446379c6597b62d27fb7">setup_Entry_node_caches</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:afacb23e680bd446379c6597b62d27fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this after loading chunks and entries into the <a class="el" href="classfz_1_1Log.html">Log</a>.  <a href="classfz_1_1Log.html#afacb23e680bd446379c6597b62d27fb7">More...</a><br /></td></tr>
<tr class="separator:afacb23e680bd446379c6597b62d27fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090e563e5880cf3508d1b878f4ea7f78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a090e563e5880cf3508d1b878f4ea7f78">setup_Chunk_node_caches</a> (<a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a090e563e5880cf3508d1b878f4ea7f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this after loading entries into the <a class="el" href="classfz_1_1Log.html">Log</a> with valid <a class="el" href="classfz_1_1Graph.html">Graph</a>.  <a href="classfz_1_1Log.html#a090e563e5880cf3508d1b878f4ea7f78">More...</a><br /></td></tr>
<tr class="separator:a090e563e5880cf3508d1b878f4ea7f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca44b6d200efa57834fe9358f2d1c001"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#aca44b6d200efa57834fe9358f2d1c001">prune_duplicate_chunks</a> ()</td></tr>
<tr class="memdesc:aca44b6d200efa57834fe9358f2d1c001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this after loading entries into the <a class="el" href="classfz_1_1Log.html">Log</a> with valid <a class="el" href="classfz_1_1Graph.html">Graph</a>.  <a href="classfz_1_1Log.html#aca44b6d200efa57834fe9358f2d1c001">More...</a><br /></td></tr>
<tr class="separator:aca44b6d200efa57834fe9358f2d1c001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6901a00db8db29ba3f1bc31ce4664c20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a6901a00db8db29ba3f1bc31ce4664c20">add_entries_to_chunks</a> ()</td></tr>
<tr class="memdesc:a6901a00db8db29ba3f1bc31ce4664c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any duplicate <a class="el" href="classfz_1_1Log.html">Log</a> chunks.  <a href="classfz_1_1Log.html#a6901a00db8db29ba3f1bc31ce4664c20">More...</a><br /></td></tr>
<tr class="separator:a6901a00db8db29ba3f1bc31ce4664c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031e4f5ab45a70e7c5d13d02e4ed986c"><td class="memItemLeft" align="right" valign="top">Log_entries_Map::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a031e4f5ab45a70e7c5d13d02e4ed986c">num_Entries</a> () const</td></tr>
<tr class="memdesc:a031e4f5ab45a70e7c5d13d02e4ed986c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect entries to chunks if that was not done during <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> construction. (2-pass method.)  <a href="classfz_1_1Log.html#a031e4f5ab45a70e7c5d13d02e4ed986c">More...</a><br /></td></tr>
<tr class="separator:a031e4f5ab45a70e7c5d13d02e4ed986c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638187c4391ac6f0d20ac89f4c4d0403"><td class="memItemLeft" align="right" valign="top"><a id="a638187c4391ac6f0d20ac89f4c4d0403"></a>
Log_chunks_Map::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>num_Chunks</b> () const</td></tr>
<tr class="separator:a638187c4391ac6f0d20ac89f4c4d0403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30d94fa32372d1b00e7a16c8ff9b1a6"><td class="memItemLeft" align="right" valign="top"><a id="ab30d94fa32372d1b00e7a16c8ff9b1a6"></a>
Log_chunk_ID_key_deque::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>num_Breakpoints</b> () const</td></tr>
<tr class="separator:ab30d94fa32372d1b00e7a16c8ff9b1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9cfc072f19ed88bb28c75ea246f379"><td class="memItemLeft" align="right" valign="top"><a id="aab9cfc072f19ed88bb28c75ea246f379"></a>
<a class="el" href="namespacefz.html#a36dc7a35876296c91d3ac9f8b762332e">Log_entries_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#aab9cfc072f19ed88bb28c75ea246f379">get_Entries</a> ()</td></tr>
<tr class="memdesc:aab9cfc072f19ed88bb28c75ea246f379"><td class="mdescLeft">&#160;</td><td class="mdescRight">tables: references <br /></td></tr>
<tr class="separator:aab9cfc072f19ed88bb28c75ea246f379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04b451ee153036099d645c323e7944c"><td class="memItemLeft" align="right" valign="top"><a id="ab04b451ee153036099d645c323e7944c"></a>
<a class="el" href="structfz_1_1Log__chunks__Map.html">Log_chunks_Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_Chunks</b> ()</td></tr>
<tr class="separator:ab04b451ee153036099d645c323e7944c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f858728c0baa291563b1b0502df56fe"><td class="memItemLeft" align="right" valign="top"><a id="a4f858728c0baa291563b1b0502df56fe"></a>
<a class="el" href="classfz_1_1Log__Breakpoints.html">Log_Breakpoints</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_Breakpoints</b> ()</td></tr>
<tr class="separator:a4f858728c0baa291563b1b0502df56fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95706ac96316e08bff035df0f3c2bd02"><td class="memItemLeft" align="right" valign="top"><a id="a95706ac96316e08bff035df0f3c2bd02"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a95706ac96316e08bff035df0f3c2bd02">add_Chunk</a> (const <a class="el" href="structfz_1_1Log__TimeStamp.html">Log_TimeStamp</a> &amp;_tbegin, const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a> &amp;_nodeid, std::time_t _tclose)</td></tr>
<tr class="memdesc:a95706ac96316e08bff035df0f3c2bd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">chunks table: extend <br /></td></tr>
<tr class="separator:a95706ac96316e08bff035df0f3c2bd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181ca13e9fd6cfdde266cac2d0999050"><td class="memItemLeft" align="right" valign="top"><a id="a181ca13e9fd6cfdde266cac2d0999050"></a>
const <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a181ca13e9fd6cfdde266cac2d0999050">get_chunk</a> (Log_chunk_ptr_map::const_iterator idx) const</td></tr>
<tr class="memdesc:a181ca13e9fd6cfdde266cac2d0999050"><td class="mdescLeft">&#160;</td><td class="mdescRight">chunks table: get chunk <br /></td></tr>
<tr class="separator:a181ca13e9fd6cfdde266cac2d0999050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26183585f91a777c007fd948e618bc29"><td class="memItemLeft" align="right" valign="top"><a id="a26183585f91a777c007fd948e618bc29"></a>
const <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_chunk</b> (const <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> chunk_idkey) const</td></tr>
<tr class="separator:a26183585f91a777c007fd948e618bc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62245d4eaacfd48db3822402f1b3259a"><td class="memItemLeft" align="right" valign="top"><a id="a62245d4eaacfd48db3822402f1b3259a"></a>
<a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_chunk_id_key</b> (Log_chunk_ptr_map::const_iterator idx) const</td></tr>
<tr class="separator:a62245d4eaacfd48db3822402f1b3259a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26af88e988808ecb37eab069e2314298"><td class="memItemLeft" align="right" valign="top"><a id="a26af88e988808ecb37eab069e2314298"></a>
Log_chunk_ptr_map::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>find_chunk_by_key</b> (const <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> chunk_idkey) const</td></tr>
<tr class="separator:a26af88e988808ecb37eab069e2314298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433d3ecdab0cc64a146d7d1442d802ae"><td class="memItemLeft" align="right" valign="top"><a id="a433d3ecdab0cc64a146d7d1442d802ae"></a>
std::pair&lt; Log_chunk_ptr_map::const_iterator, const <a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>find_chunk_index_and_pointer</b> (const <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> chunk_id) const</td></tr>
<tr class="separator:a433d3ecdab0cc64a146d7d1442d802ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3a077806fb7e1f5e1fef80f5618b84"><td class="memItemLeft" align="right" valign="top"><a id="a0e3a077806fb7e1f5e1fef80f5618b84"></a>
<a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a0e3a077806fb7e1f5e1fef80f5618b84">get_Breakpoint_first_chunk_id_key</a> (Log_chunk_ID_key_deque::size_type idx)</td></tr>
<tr class="memdesc:a0e3a077806fb7e1f5e1fef80f5618b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">breakpoints table: get breakpoint <br /></td></tr>
<tr class="separator:a0e3a077806fb7e1f5e1fef80f5618b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bed2ab878bd7a98ff05dae1d2775871"><td class="memItemLeft" align="right" valign="top"><a id="a8bed2ab878bd7a98ff05dae1d2775871"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>get_Breakpoint_first_chunk_id_str</b> (Log_chunk_ID_key_deque::size_type idx)</td></tr>
<tr class="separator:a8bed2ab878bd7a98ff05dae1d2775871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac254ac7142628b647e22f1155ab2818f"><td class="memItemLeft" align="right" valign="top"><a id="ac254ac7142628b647e22f1155ab2818f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>get_Breakpoint_Ymd_str</b> (Log_chunk_ID_key_deque::size_type idx)</td></tr>
<tr class="separator:ac254ac7142628b647e22f1155ab2818f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4d7428a68e28fce70f0eca8f540835"><td class="memItemLeft" align="right" valign="top"><a id="a8b4d7428a68e28fce70f0eca8f540835"></a>
Log_chunk_ptr_map::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a8b4d7428a68e28fce70f0eca8f540835">get_chunk_first_at_Breakpoint</a> (Log_chunk_ID_key_deque::size_type idx)</td></tr>
<tr class="memdesc:a8b4d7428a68e28fce70f0eca8f540835"><td class="mdescLeft">&#160;</td><td class="mdescRight">crossref tables: chunks x breakpoints <br /></td></tr>
<tr class="separator:a8b4d7428a68e28fce70f0eca8f540835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ba43707098024e35c306f441ce2f73"><td class="memItemLeft" align="right" valign="top"><a id="ad6ba43707098024e35c306f441ce2f73"></a>
const <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#ad6ba43707098024e35c306f441ce2f73">find_Breakpoint_tstamp_before_chunk</a> (const <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> key)</td></tr>
<tr class="memdesc:ad6ba43707098024e35c306f441ce2f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">crossref tables: breakpoints x chunks <br /></td></tr>
<tr class="separator:ad6ba43707098024e35c306f441ce2f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12618c392b39a0257a9543bda470d899"><td class="memItemLeft" align="right" valign="top"><a id="a12618c392b39a0257a9543bda470d899"></a>
Log_chunk_ID_key_deque::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>find_Breakpoint_index_before_chunk</b> (const <a class="el" href="structfz_1_1Log__chunk__ID__key.html">Log_chunk_ID_key</a> key)</td></tr>
<tr class="separator:a12618c392b39a0257a9543bda470d899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e13bc413db72f27efaf578f72d8f2c"><td class="memItemLeft" align="right" valign="top"><a id="a64e13bc413db72f27efaf578f72d8f2c"></a>
Log_chunk_ID_key_deque::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>find_Breakpoint_index_before_entry</b> (const <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a> key)</td></tr>
<tr class="separator:a64e13bc413db72f27efaf578f72d8f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f97af34b6f83facb77381bf050fa77"><td class="memItemLeft" align="right" valign="top"><a id="a40f97af34b6f83facb77381bf050fa77"></a>
Log_chunk_ID_key_deque::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>find_Breakpoint_index_before_chaintarget</b> (const <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> &amp;chaintarget)</td></tr>
<tr class="separator:a40f97af34b6f83facb77381bf050fa77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52275040d91b5000109e383ffadaa10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefz.html#a33950887af9a1dfe223b82b40edc2b1f">Log_entry_iterator_interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#ae52275040d91b5000109e383ffadaa10">get_Entries_interval</a> (const <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a> interval_front, const <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a> interval_back)</td></tr>
<tr class="memdesc:ae52275040d91b5000109e383ffadaa10"><td class="mdescLeft">&#160;</td><td class="mdescRight">entries table: select interval, from chunk / time, to chunk / time / count  <a href="classfz_1_1Log.html#ae52275040d91b5000109e383ffadaa10">More...</a><br /></td></tr>
<tr class="separator:ae52275040d91b5000109e383ffadaa10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae305baab36b45f3fa81b7982991ceaf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefz.html#a33950887af9a1dfe223b82b40edc2b1f">Log_entry_iterator_interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#ae305baab36b45f3fa81b7982991ceaf2">get_Entries_t_interval</a> (std::time_t t_from, std::time_t t_before)</td></tr>
<tr class="memdesc:ae305baab36b45f3fa81b7982991ceaf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pair of iterators that indicate the begin and end of an interval of <a class="el" href="classfz_1_1Log.html">Log</a> entry objects, where those <a class="el" href="classfz_1_1Log.html">Log</a> entry objects all have ID keys that represent times t, with t_from &lt;= t &lt; t_before.  <a href="classfz_1_1Log.html#ae305baab36b45f3fa81b7982991ceaf2">More...</a><br /></td></tr>
<tr class="separator:ae305baab36b45f3fa81b7982991ceaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298a3c832827a89df21911bde09b338a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefz.html#a33950887af9a1dfe223b82b40edc2b1f">Log_entry_iterator_interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a298a3c832827a89df21911bde09b338a">get_Entries_interval</a> (const <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a> interval_front, unsigned long n)</td></tr>
<tr class="memdesc:a298a3c832827a89df21911bde09b338a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pair of iterators that indicate the begin and end of an interval of <a class="el" href="classfz_1_1Log.html">Log</a> entry objects.  <a href="classfz_1_1Log.html#a298a3c832827a89df21911bde09b338a">More...</a><br /></td></tr>
<tr class="separator:a298a3c832827a89df21911bde09b338a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365fb4d3749b122fd98c1b7506647a20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefz.html#a33950887af9a1dfe223b82b40edc2b1f">Log_entry_iterator_interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a365fb4d3749b122fd98c1b7506647a20">get_Entries_n_interval</a> (std::time_t t_from, unsigned long n)</td></tr>
<tr class="memdesc:a365fb4d3749b122fd98c1b7506647a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pair of iterators that indicate the begin and end of an interval of up to n <a class="el" href="classfz_1_1Log.html">Log</a> entry objects.  <a href="classfz_1_1Log.html#a365fb4d3749b122fd98c1b7506647a20">More...</a><br /></td></tr>
<tr class="separator:a365fb4d3749b122fd98c1b7506647a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c6c3750a23f52c04f850ce6c85e5c0"><td class="memItemLeft" align="right" valign="top">Log_chunk_ID_interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a07c6c3750a23f52c04f850ce6c85e5c0">get_Chunks_ID_t_interval</a> (std::time_t t_from, std::time_t t_before)</td></tr>
<tr class="memdesc:a07c6c3750a23f52c04f850ce6c85e5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">chunks table: select interval, from chunk / time, to chunk / time / count  <a href="classfz_1_1Log.html#a07c6c3750a23f52c04f850ce6c85e5c0">More...</a><br /></td></tr>
<tr class="separator:a07c6c3750a23f52c04f850ce6c85e5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740b87f036296573f8e615a221cd0939"><td class="memItemLeft" align="right" valign="top">Log_chunk_ID_interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a740b87f036296573f8e615a221cd0939">get_Chunks_ID_n_interval</a> (std::time_t t_from, unsigned long n)</td></tr>
<tr class="memdesc:a740b87f036296573f8e615a221cd0939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an interval of n <a class="el" href="classfz_1_1Log.html">Log</a> chunks with t_begin &gt;= t_from.  <a href="classfz_1_1Log.html#a740b87f036296573f8e615a221cd0939">More...</a><br /></td></tr>
<tr class="separator:a740b87f036296573f8e615a221cd0939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc67a829ef68c9874ebfa9c307c47abd"><td class="memItemLeft" align="right" valign="top">Log_chunk_const_iterator_interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#afc67a829ef68c9874ebfa9c307c47abd">get_Chunks_index_t_interval</a> (std::time_t t_from, std::time_t t_before)</td></tr>
<tr class="memdesc:afc67a829ef68c9874ebfa9c307c47abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interval of <a class="el" href="classfz_1_1Log.html">Log</a> chunks with t_from &lt;= t_begin &lt; t_before.  <a href="classfz_1_1Log.html#afc67a829ef68c9874ebfa9c307c47abd">More...</a><br /></td></tr>
<tr class="separator:afc67a829ef68c9874ebfa9c307c47abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eef39eb4bda6a187c70fd6cbfea6786"><td class="memItemLeft" align="right" valign="top">Log_chunk_const_iterator_interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a8eef39eb4bda6a187c70fd6cbfea6786">get_Chunks_index_n_interval</a> (std::time_t t_from, unsigned long n)</td></tr>
<tr class="memdesc:a8eef39eb4bda6a187c70fd6cbfea6786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an interval of n <a class="el" href="classfz_1_1Log.html">Log</a> chunks with t_begin &gt;= t_from.  <a href="classfz_1_1Log.html#a8eef39eb4bda6a187c70fd6cbfea6786">More...</a><br /></td></tr>
<tr class="separator:a8eef39eb4bda6a187c70fd6cbfea6786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec7c92bd3d4b9c8806bc6c5fb5041d8"><td class="memItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a1ec7c92bd3d4b9c8806bc6c5fb5041d8">get_Node_chain_fullparse</a> (const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a> node_id, bool onlyfirst=false)</td></tr>
<tr class="memdesc:a1ec7c92bd3d4b9c8806bc6c5fb5041d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">chunks table: select subset by <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>  <a href="classfz_1_1Log.html#a1ec7c92bd3d4b9c8806bc6c5fb5041d8">More...</a><br /></td></tr>
<tr class="separator:a1ec7c92bd3d4b9c8806bc6c5fb5041d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4266e49a3045dba72a9daed76a5f263b"><td class="memItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a4266e49a3045dba72a9daed76a5f263b">get_Node_chain_fullparse_reverse</a> (const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a> node_id, bool onlylast=false)</td></tr>
<tr class="memdesc:a4266e49a3045dba72a9daed76a5f263b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse all chunks connected to the <a class="el" href="classfz_1_1Log.html">Log</a> - in reverse - and find the sequence of chunks and entries that belongs to a specific <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>.  <a href="classfz_1_1Log.html#a4266e49a3045dba72a9daed76a5f263b">More...</a><br /></td></tr>
<tr class="separator:a4266e49a3045dba72a9daed76a5f263b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e54df7bb54ae553ef9e5b93ce85904"><td class="memItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a65e54df7bb54ae553ef9e5b93ce85904">get_Node_chain</a> (const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a> node_id)</td></tr>
<tr class="memdesc:a65e54df7bb54ae553ef9e5b93ce85904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quickly walk through the reference chain that belongs to the specified <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> and return all of its <a class="el" href="classfz_1_1Log.html">Log</a> chunks and <a class="el" href="classfz_1_1Log.html">Log</a> entries.  <a href="classfz_1_1Log.html#a65e54df7bb54ae553ef9e5b93ce85904">More...</a><br /></td></tr>
<tr class="separator:a65e54df7bb54ae553ef9e5b93ce85904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcef1ab3169e986a5a58902772ab643"><td class="memItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a3fcef1ab3169e986a5a58902772ab643">get_Node_chain_reverse</a> (const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a> node_id)</td></tr>
<tr class="memdesc:a3fcef1ab3169e986a5a58902772ab643"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version requires valid prev/next references.  <a href="classfz_1_1Log.html#a3fcef1ab3169e986a5a58902772ab643">More...</a><br /></td></tr>
<tr class="separator:a3fcef1ab3169e986a5a58902772ab643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d043044e1a641a61dd2ea0bb6c514a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a10d043044e1a641a61dd2ea0bb6c514a">newest_Node_chain_element</a> (const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a> node_id)</td></tr>
<tr class="memdesc:a10d043044e1a641a61dd2ea0bb6c514a"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions make no assumptions about the reliability of the cached head and tail chain pointers of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>.  <a href="classfz_1_1Log.html#a10d043044e1a641a61dd2ea0bb6c514a">More...</a><br /></td></tr>
<tr class="separator:a10d043044e1a641a61dd2ea0bb6c514a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98819789423a2712d06bae307e4313ed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a98819789423a2712d06bae307e4313ed">oldest_Node_chain_element</a> (const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a> node_id)</td></tr>
<tr class="memdesc:a98819789423a2712d06bae307e4313ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notice that the set of tests in the while-loop are necessary here.  <a href="classfz_1_1Log.html#a98819789423a2712d06bae307e4313ed">More...</a><br /></td></tr>
<tr class="separator:a98819789423a2712d06bae307e4313ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab723cd177104b779811f8eec827b7a60"><td class="memItemLeft" align="right" valign="top"><a id="ab723cd177104b779811f8eec827b7a60"></a>
std::time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#ab723cd177104b779811f8eec827b7a60">oldest_chunk_t</a> ()</td></tr>
<tr class="memdesc:ab723cd177104b779811f8eec827b7a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper (utility) functions <br /></td></tr>
<tr class="separator:ab723cd177104b779811f8eec827b7a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a3b1472b02370bd7687e3c209261b9"><td class="memItemLeft" align="right" valign="top"><a id="a30a3b1472b02370bd7687e3c209261b9"></a>
std::time_t&#160;</td><td class="memItemRight" valign="bottom"><b>newest_chunk_t</b> ()</td></tr>
<tr class="separator:a30a3b1472b02370bd7687e3c209261b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4acb858a33c3ccb6e17da4e6b255a3e"><td class="memItemLeft" align="right" valign="top"><a id="ab4acb858a33c3ccb6e17da4e6b255a3e"></a>
<a class="el" href="classfz_1_1Log__chunk.html">Log_chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_newest_Chunk</b> ()</td></tr>
<tr class="separator:ab4acb858a33c3ccb6e17da4e6b255a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13f12beff033788739514e034967adb"><td class="memItemLeft" align="right" valign="top"><a id="ab13f12beff033788739514e034967adb"></a>
<a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_newest_Entry</b> ()</td></tr>
<tr class="separator:ab13f12beff033788739514e034967adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92ea4f8975984e1ab4ff18c5debff14"><td class="memItemLeft" align="right" valign="top">Log_chunk_ID_key_set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#ae92ea4f8975984e1ab4ff18c5debff14">chunk_key_list_from_entries</a> ()</td></tr>
<tr class="memdesc:ae92ea4f8975984e1ab4ff18c5debff14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a set of <a class="el" href="classfz_1_1Log.html">Log</a> chunk ID keys that corresponds to the ID keys of all entries in the <a class="el" href="classfz_1_1Log.html">Log</a>.  <a href="classfz_1_1Log.html#ae92ea4f8975984e1ab4ff18c5debff14">More...</a><br /></td></tr>
<tr class="separator:ae92ea4f8975984e1ab4ff18c5debff14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac448c8de85ac26d5ec0e3e36b5267e67"><td class="memItemLeft" align="right" valign="top"><a id="ac448c8de85ac26d5ec0e3e36b5267e67"></a>
<a class="el" href="namespacefz.html#a36dc7a35876296c91d3ac9f8b762332e">Log_entries_Map</a>&#160;</td><td class="memItemRight" valign="bottom"><b>entries</b></td></tr>
<tr class="separator:ac448c8de85ac26d5ec0e3e36b5267e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49ff6ab52074aace7cea07f25e29624"><td class="memItemLeft" align="right" valign="top"><a id="ad49ff6ab52074aace7cea07f25e29624"></a>
<a class="el" href="structfz_1_1Log__chunks__Map.html">Log_chunks_Map</a>&#160;</td><td class="memItemRight" valign="bottom"><b>chunks</b></td></tr>
<tr class="separator:ad49ff6ab52074aace7cea07f25e29624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f24377ed6f241c8d83730053795784"><td class="memItemLeft" align="right" valign="top"><a id="a68f24377ed6f241c8d83730053795784"></a>
<a class="el" href="classfz_1_1Log__Breakpoints.html">Log_Breakpoints</a>&#160;</td><td class="memItemRight" valign="bottom"><b>breakpoints</b></td></tr>
<tr class="separator:a68f24377ed6f241c8d83730053795784"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a536d7fb0f2241d8e0053f4b4318b9bbb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Log_chunks_Map::iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a536d7fb0f2241d8e0053f4b4318b9bbb">Breakpoint_Indices</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:a536d7fb0f2241d8e0053f4b4318b9bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This converts the list of <a class="el" href="classfz_1_1Log.html">Log</a> breakpoint <a class="el" href="classfz_1_1Log.html">Log</a> chunk IDs into a list of indices into the list of <a class="el" href="classfz_1_1Log.html">Log</a> chunks (in Log::chunks).  <a href="classfz_1_1Log.html#a536d7fb0f2241d8e0053f4b4318b9bbb">More...</a><br /></td></tr>
<tr class="separator:a536d7fb0f2241d8e0053f4b4318b9bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5d49ed9cde163bba6d34a6eaa5f154"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a5a5d49ed9cde163bba6d34a6eaa5f154">Chunks_per_Breakpoint</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:a5a5d49ed9cde163bba6d34a6eaa5f154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the frequency distribution for the number of <a class="el" href="classfz_1_1Log.html">Log</a> chunks per <a class="el" href="classfz_1_1Log.html">Log</a> breakpoint.  <a href="classfz_1_1Log.html#a5a5d49ed9cde163bba6d34a6eaa5f154">More...</a><br /></td></tr>
<tr class="separator:a5a5d49ed9cde163bba6d34a6eaa5f154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8571d0bb6aad25c78696fc8c3dcc1a"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#aff8571d0bb6aad25c78696fc8c3dcc1a">Log_span_in_seconds</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:aff8571d0bb6aad25c78696fc8c3dcc1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the span in seconds from when the <a class="el" href="classfz_1_1Log.html">Log</a> was started (first cunk) to its most recent chunk.  <a href="classfz_1_1Log.html#aff8571d0bb6aad25c78696fc8c3dcc1a">More...</a><br /></td></tr>
<tr class="separator:aff8571d0bb6aad25c78696fc8c3dcc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bce55e40ccb0a64160c64e30acaaa0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#a49bce55e40ccb0a64160c64e30acaaa0">Log_span_in_days</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:a49bce55e40ccb0a64160c64e30acaaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the span in days from when the <a class="el" href="classfz_1_1Log.html">Log</a> was started (first cunk) to its most recent chunk.  <a href="classfz_1_1Log.html#a49bce55e40ccb0a64160c64e30acaaa0">More...</a><br /></td></tr>
<tr class="separator:a49bce55e40ccb0a64160c64e30acaaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf04470fdb14a1ee2b7271a55413b583"><td class="memItemLeft" align="right" valign="top">ymd_tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfz_1_1Log.html#aaf04470fdb14a1ee2b7271a55413b583">Log_span_years_months_days</a> (<a class="el" href="classfz_1_1Log.html">Log</a> &amp;log)</td></tr>
<tr class="memdesc:aaf04470fdb14a1ee2b7271a55413b583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the span in years, months and days from when the <a class="el" href="classfz_1_1Log.html">Log</a> was started (first cunk) to its most recent chunk.  <a href="classfz_1_1Log.html#aaf04470fdb14a1ee2b7271a55413b583">More...</a><br /></td></tr>
<tr class="separator:aaf04470fdb14a1ee2b7271a55413b583"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3><a class="el" href="classfz_1_1Log.html">Log</a></h3>
<p>This data structure is used to organize <a class="el" href="classfz_1_1Log.html">Log</a> entry elements into <a class="el" href="classfz_1_1Log.html">Log</a> chunk intervals and, for backwards compatibility with <code>dil2al</code>, to indicate which <a class="el" href="classfz_1_1Log.html">Log</a> chunks follow a Breakpoint and start a new section.</p>
<p>Note that sections are not used with the database storage format. Conversion back to <code>dil2al</code> Task <a class="el" href="classfz_1_1Log.html">Log</a> files will need to add new Breakpoints at sensible intervals beyond the last original section Breakpoint.</p>
<p>*** At this time, the functions below have only been tested in the case where the whole <a class="el" href="classfz_1_1Log.html">Log</a> is in-memory. Care will need to be taken to make sure things work as intended when only portions of the <a class="el" href="classfz_1_1Log.html">Log</a> are loaded into memory. Alternatively, a separate but similar class could be defined in order to avoid any confusion. Or, the functions that find/get specific chunks or entries could be given some smarts where <em>not found</em> first leads to an attempt to find and load from database. In that case, there will also have to be some process behind the scenes that can gradually release in-memory <a class="el" href="classfz_1_1Log.html">Log</a> portions again, otherwise it will always end up being the whole <a class="el" href="classfz_1_1Log.html">Log</a> when a server is an active process for a long time. <a class="el" href="classfz_1_1Log.html">Log</a> requests could be handled by a separate server, which could be explicitly <em>not</em> daemonized, so that it will always release memory after serving up some <a class="el" href="classfz_1_1Log.html">Log</a> data. (See the Trello card at <a href="https://trello.com/c/EppSyY9Y">https://trello.com/c/EppSyY9Y</a>.) </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a6901a00db8db29ba3f1bc31ce4664c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6901a00db8db29ba3f1bc31ce4664c20">&#9670;&nbsp;</a></span>add_entries_to_chunks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fz::Log::add_entries_to_chunks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove any duplicate <a class="el" href="classfz_1_1Log.html">Log</a> chunks. </p>
<p>If <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> objects were created without immediately specifying a corresponding <a class="el" href="classfz_1_1Log__chunk.html" title="Specifies the start time, Node, close time, and set of entries of a Log chunk.">Log_chunk</a> object (created earlier), i.e.</p>
<p>if using a 2-pass method, then parse the list of entries and connect entries with chunks. </p>

</div>
</div>
<a id="ae92ea4f8975984e1ab4ff18c5debff14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92ea4f8975984e1ab4ff18c5debff14">&#9670;&nbsp;</a></span>chunk_key_list_from_entries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Log_chunk_ID_key_set fz::Log::chunk_key_list_from_entries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a set of <a class="el" href="classfz_1_1Log.html">Log</a> chunk ID keys that corresponds to the ID keys of all entries in the <a class="el" href="classfz_1_1Log.html">Log</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A set of <code><a class="el" href="structfz_1_1Log__chunk__ID__key.html" title="Standardized Formalizer Log chunk ID key.">Log_chunk_ID_key</a></code> objects. </dd></dl>

</div>
</div>
<a id="a740b87f036296573f8e615a221cd0939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740b87f036296573f8e615a221cd0939">&#9670;&nbsp;</a></span>get_Chunks_ID_n_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Log_chunk_ID_interval fz::Log::get_Chunks_ID_n_interval </td>
          <td>(</td>
          <td class="paramtype">std::time_t&#160;</td>
          <td class="paramname"><em>t_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an interval of n <a class="el" href="classfz_1_1Log.html">Log</a> chunks with t_begin &gt;= t_from. </p>
<p>The interval is returned as a pair of <a class="el" href="structfz_1_1Log__chunk__ID__key.html" title="Standardized Formalizer Log chunk ID key.">Log_chunk_ID_key</a> objects and is inclusive. Both ID keys belong to <a class="el" href="classfz_1_1Log.html">Log</a> chunks within the interval. If the interval is empty then a pair of null-key are returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_from</td><td>is the earliest UNIX epoch time within the interval. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of <a class="el" href="classfz_1_1Log.html">Log</a> chunks to include in the interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of <a class="el" href="classfz_1_1Log.html">Log</a> chunk ID keys. </dd></dl>

</div>
</div>
<a id="a07c6c3750a23f52c04f850ce6c85e5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c6c3750a23f52c04f850ce6c85e5c0">&#9670;&nbsp;</a></span>get_Chunks_ID_t_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Log_chunk_ID_interval fz::Log::get_Chunks_ID_t_interval </td>
          <td>(</td>
          <td class="paramtype">std::time_t&#160;</td>
          <td class="paramname"><em>t_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::time_t&#160;</td>
          <td class="paramname"><em>t_before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>chunks table: select interval, from chunk / time, to chunk / time / count </p>
<p>Get the interval of <a class="el" href="classfz_1_1Log.html">Log</a> chunks with t_from &lt;= t_begin &lt; t_before.</p>
<p>The interval is returned as a pair of <a class="el" href="structfz_1_1Log__chunk__ID__key.html" title="Standardized Formalizer Log chunk ID key.">Log_chunk_ID_key</a> objects and is inclusive. Both ID keys belong to <a class="el" href="classfz_1_1Log.html">Log</a> chunks within the interval. If the interval is empty then a pair of null-key are returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_from</td><td>is the earliest UNIX epoch time within the interval. </td></tr>
    <tr><td class="paramname">t_before</td><td>is the UNIX epoch time 1 second after the interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of <a class="el" href="classfz_1_1Log.html">Log</a> chunk ID keys. </dd></dl>

</div>
</div>
<a id="a8eef39eb4bda6a187c70fd6cbfea6786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eef39eb4bda6a187c70fd6cbfea6786">&#9670;&nbsp;</a></span>get_Chunks_index_n_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Log_chunk_const_iterator_interval fz::Log::get_Chunks_index_n_interval </td>
          <td>(</td>
          <td class="paramtype">std::time_t&#160;</td>
          <td class="paramname"><em>t_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an interval of n <a class="el" href="classfz_1_1Log.html">Log</a> chunks with t_begin &gt;= t_from. </p>
<p>The interval is returned as a pair of indices and is inclusive. Both indices are within the interval. If the interval is empty then the indices are set to chunks.size(), beyond the range of valid indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_from</td><td>is the earliest UNIX epoch time within the interval. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of <a class="el" href="classfz_1_1Log.html">Log</a> chunks to include in the interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of indices bounding <a class="el" href="classfz_1_1Log.html">Log</a> chunks within the interval, or a pair of indices beyond the range of existing <a class="el" href="classfz_1_1Log.html">Log</a> chunks if no <a class="el" href="classfz_1_1Log.html">Log</a> chunks were found for the interval. </dd></dl>

</div>
</div>
<a id="afc67a829ef68c9874ebfa9c307c47abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc67a829ef68c9874ebfa9c307c47abd">&#9670;&nbsp;</a></span>get_Chunks_index_t_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Log_chunk_const_iterator_interval fz::Log::get_Chunks_index_t_interval </td>
          <td>(</td>
          <td class="paramtype">std::time_t&#160;</td>
          <td class="paramname"><em>t_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::time_t&#160;</td>
          <td class="paramname"><em>t_before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the interval of <a class="el" href="classfz_1_1Log.html">Log</a> chunks with t_from &lt;= t_begin &lt; t_before. </p>
<p>The interval is returned as a pair of indices and is inclusive. Both indices are within the interval. If the interval is empty then the indices are set to chunks.size(), beyond the range of valid indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_from</td><td>is the earliest UNIX epoch time within the interval. </td></tr>
    <tr><td class="paramname">t_before</td><td>is the UNIX epoch time 1 second after the interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of indices bounding <a class="el" href="classfz_1_1Log.html">Log</a> chunks within the interval, or a pair of indices beyond the range of existing <a class="el" href="classfz_1_1Log.html">Log</a> chunks if no <a class="el" href="classfz_1_1Log.html">Log</a> chunks have start times within the interval. </dd></dl>

</div>
</div>
<a id="ae52275040d91b5000109e383ffadaa10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52275040d91b5000109e383ffadaa10">&#9670;&nbsp;</a></span>get_Entries_interval() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefz.html#a33950887af9a1dfe223b82b40edc2b1f">Log_entry_iterator_interval</a> fz::Log::get_Entries_interval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a>&#160;</td>
          <td class="paramname"><em>interval_front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a>&#160;</td>
          <td class="paramname"><em>interval_back</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>entries table: select interval, from chunk / time, to chunk / time / count </p>
<p>Get a pair of iterators that indicate the begin and end of an interval of <a class="el" href="classfz_1_1Log.html">Log</a> entry objects.</p>
<p>Both <code>interval_front</code> and <code>interval_back</code> must exist in the map of <a class="el" href="classfz_1_1Log.html">Log</a> entries. Otherwise, a pair of out-of-range iterators set to entries.end() are returned.</p>
<p>Note that the second iterator returned behaves like all end() iterators of C++ STL containers. In other words, it points to the object 1 beyond the object identified by <code>interval_back</code>. If that the <code>interval_back</code> object was the last entry then the second iterator == entries.end().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval_front</td><td>is the <a class="el" href="classfz_1_1Log.html">Log</a> entry ID key of an entry in the <a class="el" href="classfz_1_1Log.html">Log</a>. </td></tr>
    <tr><td class="paramname">interval_back</td><td>is the <a class="el" href="classfz_1_1Log.html">Log</a> entry ID key of an entry in the <a class="el" href="classfz_1_1Log.html">Log</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of iterators describing the begin and end of a subset of entries. </dd></dl>

</div>
</div>
<a id="a298a3c832827a89df21911bde09b338a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298a3c832827a89df21911bde09b338a">&#9670;&nbsp;</a></span>get_Entries_interval() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefz.html#a33950887af9a1dfe223b82b40edc2b1f">Log_entry_iterator_interval</a> fz::Log::get_Entries_interval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfz_1_1Log__entry__ID__key.html">Log_entry_ID_key</a>&#160;</td>
          <td class="paramname"><em>interval_front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pair of iterators that indicate the begin and end of an interval of <a class="el" href="classfz_1_1Log.html">Log</a> entry objects. </p>
<p>The <a class="el" href="classfz_1_1Log.html">Log</a> entry with <a class="el" href="classfz_1_1Log.html">Log</a> entry ID key <code>interval_front</code> must exist in the map of <a class="el" href="classfz_1_1Log.html">Log</a> entries and n &gt; 0. Otherwise, a pair of out-of-range iterators set to entries.end() are returned.</p>
<p>Note that the second iterator returned behaves like all end() iterators of C++ STL containers. In other words, it points to the object 1 beyond the nth object in the interval, or it is entries.end().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval_front</td><td>is the <a class="el" href="classfz_1_1Log.html">Log</a> entry ID key of an entry in the <a class="el" href="classfz_1_1Log.html">Log</a>. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of <a class="el" href="classfz_1_1Log.html">Log</a> entries to include in the interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of iterators describing the begin and end of a subset of entries. </dd></dl>

</div>
</div>
<a id="a365fb4d3749b122fd98c1b7506647a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365fb4d3749b122fd98c1b7506647a20">&#9670;&nbsp;</a></span>get_Entries_n_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefz.html#a33950887af9a1dfe223b82b40edc2b1f">Log_entry_iterator_interval</a> fz::Log::get_Entries_n_interval </td>
          <td>(</td>
          <td class="paramtype">std::time_t&#160;</td>
          <td class="paramname"><em>t_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pair of iterators that indicate the begin and end of an interval of up to n <a class="el" href="classfz_1_1Log.html">Log</a> entry objects. </p>
<p>The <a class="el" href="classfz_1_1Log.html">Log</a> entry objects all have ID keys that represent times t, with t_from &lt;= t, and n &gt; 0. Aa pair of out-of-range iterators set to entries.end() are returned if these conditions cannot be met or if the interval is empty.</p>
<p>Note that the second iterator returned behaves like all end() iterators of C++ STL containers. In other words, it points to the object with <a class="el" href="classfz_1_1Log.html">Log</a> entry ID key representing a time at or beyond t_before, which may be entries.end().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_from</td><td>is the earliest UNIX epoch time within the interval. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of <a class="el" href="classfz_1_1Log.html">Log</a> entries to include in the interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of iterators describing the begin and end of a subset of entries. </dd></dl>

</div>
</div>
<a id="ae305baab36b45f3fa81b7982991ceaf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae305baab36b45f3fa81b7982991ceaf2">&#9670;&nbsp;</a></span>get_Entries_t_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefz.html#a33950887af9a1dfe223b82b40edc2b1f">Log_entry_iterator_interval</a> fz::Log::get_Entries_t_interval </td>
          <td>(</td>
          <td class="paramtype">std::time_t&#160;</td>
          <td class="paramname"><em>t_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::time_t&#160;</td>
          <td class="paramname"><em>t_before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pair of iterators that indicate the begin and end of an interval of <a class="el" href="classfz_1_1Log.html">Log</a> entry objects, where those <a class="el" href="classfz_1_1Log.html">Log</a> entry objects all have ID keys that represent times t, with t_from &lt;= t &lt; t_before. </p>
<p>If the interval is entirely outside of the times represented by exissting <a class="el" href="classfz_1_1Log.html">Log</a> entries then a pair of out-of-range iterators set to entries.end() are returned.</p>
<p>Note that the second iterator returned behaves like all end() iterators of C++ STL containers. In other words, it points to the object with <a class="el" href="classfz_1_1Log.html">Log</a> entry ID key representing a time at or beyond t_before, which may be entries.end().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_from</td><td>is the earliest UNIX epoch time within the interval. </td></tr>
    <tr><td class="paramname">t_before</td><td>is the UNIX epoch time 1 second after the interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of iterators describing the begin and end of a subset of entries. </dd></dl>

</div>
</div>
<a id="a65e54df7bb54ae553ef9e5b93ce85904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e54df7bb54ae553ef9e5b93ce85904">&#9670;&nbsp;</a></span>get_Node_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> &gt; fz::Log::get_Node_chain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quickly walk through the reference chain that belongs to the specified <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> and return all of its <a class="el" href="classfz_1_1Log.html">Log</a> chunks and <a class="el" href="classfz_1_1Log.html">Log</a> entries. </p>
<p>Note A: This function depends on valid rapid-access pointers within <code>node_prev</code> and <code>node_next</code> variables in each <a class="el" href="classfz_1_1Log.html">Log</a> chunk and entry. Note B: This function (presently) works by building a brand-new deque list with <a class="el" href="structfz_1_1Log__chain__target.html" title="This data structure is used to follow a chain by-Node through the Log that can lead to Log chunks or ...">Log_chain_target</a> copies (instead of references). This decision is based on the assumption that the list of targets is typically informative, providing necessary access info to those targets, but you don't accidentally want to break existing chains by modifying elements of the deque list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>of the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> for which to collect its <a class="el" href="classfz_1_1Log.html">Log</a> chain (history). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a deque sorted list of chain targets found. </dd></dl>

</div>
</div>
<a id="a1ec7c92bd3d4b9c8806bc6c5fb5041d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec7c92bd3d4b9c8806bc6c5fb5041d8">&#9670;&nbsp;</a></span>get_Node_chain_fullparse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> &gt; fz::Log::get_Node_chain_fullparse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyfirst</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>chunks table: select subset by <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> </p>
<p>Parse all chunks connected to the <a class="el" href="classfz_1_1Log.html">Log</a> and find the sequence of chunks and entries that belongs to a specific <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>.</p>
<p>This is used by Log::setup_Chunk_nodeprevnext(), and it can also be used independent of the reference parameters in the <a class="el" href="classfz_1_1Log__chunk.html" title="Specifies the start time, Node, close time, and set of entries of a Log chunk.">Log_chunk</a> objects, which even works for arbitrary loaded lists of <a class="el" href="classfz_1_1Log.html">Log</a> chunks.</p>
<p>This function is also used by the rapid search version <code><a class="el" href="classfz_1_1Log.html#a65e54df7bb54ae553ef9e5b93ce85904" title="Quickly walk through the reference chain that belongs to the specified Node and return all of its Log...">get_Node_chain()</a></code>, which calls this to find the first target, the head of the chain, which is specifeid via the <code>onlyfirst</code> parameter.</p>
<p>This function requires that the <code>entries</code> list has been set up for all <a class="el" href="classfz_1_1Log.html">Log</a> chunks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>of the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> for which to collect its <a class="el" href="classfz_1_1Log.html">Log</a> chain (history). </td></tr>
    <tr><td class="paramname">onlyfirst</td><td>flag if true return only the first target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a deque sorted list of chain targets found. </dd></dl>

</div>
</div>
<a id="a4266e49a3045dba72a9daed76a5f263b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4266e49a3045dba72a9daed76a5f263b">&#9670;&nbsp;</a></span>get_Node_chain_fullparse_reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> &gt; fz::Log::get_Node_chain_fullparse_reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlylast</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse all chunks connected to the <a class="el" href="classfz_1_1Log.html">Log</a> - in reverse - and find the sequence of chunks and entries that belongs to a specific <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>. </p>
<p>Reverse search is probably a good option, because often referenced <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> histories are likely those of recent Nodes with recent <a class="el" href="classfz_1_1Log.html">Log</a> entries.</p>
<p>This can be used independent of the reference parameters in the <a class="el" href="classfz_1_1Log__chunk.html" title="Specifies the start time, Node, close time, and set of entries of a Log chunk.">Log_chunk</a> objects, hence even works for arbitrary loaded lists of <a class="el" href="classfz_1_1Log.html">Log</a> chunks.</p>
<p>This function requires that the <code>entries</code> list has been set up for all <a class="el" href="classfz_1_1Log.html">Log</a> chunks.</p>
<p>If <code>onlylast == true</code> then the deque returned will contain only one element, namely the last (latest, newest) element in the chain that belongs to <code>node_id</code>. A full search is not conducted in this case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>of the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> for which to collect its <a class="el" href="classfz_1_1Log.html">Log</a> chain (history). </td></tr>
    <tr><td class="paramname">onlylast</td><td>flag if true return only the last target (do not find the whole list). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a deque sorted list of chain targets found. </dd></dl>

</div>
</div>
<a id="a3fcef1ab3169e986a5a58902772ab643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fcef1ab3169e986a5a58902772ab643">&#9670;&nbsp;</a></span>get_Node_chain_reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> &gt; fz::Log::get_Node_chain_reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This version requires valid prev/next references. </p>
<p>Quickly walk through the reference chain - in reverse - that belongs to the specified <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> and return all of its <a class="el" href="classfz_1_1Log.html">Log</a> chunks and <a class="el" href="classfz_1_1Log.html">Log</a> entries.</p>
<p>Reverse search is probably a good option, because often referenced <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> histories are likely those of recent Nodes with recent <a class="el" href="classfz_1_1Log.html">Log</a> entries.</p>
<p>Note A: This function depends on valid rapid-access pointers within <code>node_prev</code> and <code>node_next</code> variables in each <a class="el" href="classfz_1_1Log.html">Log</a> chunk and entry. Note B: This function (presently) works by building a brand-new deque list with <a class="el" href="structfz_1_1Log__chain__target.html" title="This data structure is used to follow a chain by-Node through the Log that can lead to Log chunks or ...">Log_chain_target</a> copies (instead of references). This decision is based on the assumption that the list of targets is typically informative, providing necessary access info to those targets, but you don't accidentally want to break existing chains by modifying elements of the deque list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>of the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> for which to collect its <a class="el" href="classfz_1_1Log.html">Log</a> chain (history). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a deque sorted list of chain targets found. </dd></dl>

</div>
</div>
<a id="a10d043044e1a641a61dd2ea0bb6c514a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d043044e1a641a61dd2ea0bb6c514a">&#9670;&nbsp;</a></span>newest_Node_chain_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> * fz::Log::newest_Node_chain_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These functions make no assumptions about the reliability of the cached head and tail chain pointers of a <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>. </p>
<p>They begin by walking backwards in time from the newest <a class="el" href="classfz_1_1Log.html">Log</a> chunk's entries to the oldesst <a class="el" href="classfz_1_1Log.html">Log</a> chunk, collecting chain elements (entries and chunks) that belong to the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> along the way.</p>
<p>Chain elements found are emplaced at the front of the deque, meaning that the oldest element will be at the front of the deque when done, and the newest element will be at the back.</p>
<p>The <code><a class="el" href="classfz_1_1Log.html#a10d043044e1a641a61dd2ea0bb6c514a" title="These functions make no assumptions about the reliability of the cached head and tail chain pointers ...">newest_Node_chain_element()</a></code> function then returns the <code>back()</code> of the deque, i.e. the newest entry or chunk that belongs to the <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a>.</p>
<p>The <code><a class="el" href="classfz_1_1Log.html#a98819789423a2712d06bae307e4313ed" title="Notice that the set of tests in the while-loop are necessary here.">oldest_Node_chain_element()</a></code> function also appears to take the <code>back()</code>, i.e. the newest element, after walking the whole chain - and then does a walk backwards using <code>prev_in_chain()</code>, until that returns <code>nullptr</code>. This is done, because calling <code>get_Node_chain_fullparse_reverse</code> with <code>onlylast == true</code> means that only the neweest element is returned in the deque. Even so, this will only work if the <a class="el" href="classfz_1_1Log.html">Log</a> chains have been set up in advance. This happens, for example, through <code>Graphaccess:Graph_access::rapid_access_init()</code>. See, for example, how this is used via <code><a class="el" href="structfz_1_1Graph__access.html#a14321424e9836da20420133fe90513c6" title="This is similar to request_Graph_and_Log_copies_and_init() but uses the memory resident Graph instead...">Graph_access::access_shared_Graph_and_request_Log_copy_with_init()</a></code> in <code><a class="el" href="structgraph2dil.html">graph2dil</a></code>.</p>
<p>Either of these functions should return a nullptr only if there are no <a class="el" href="classfz_1_1Log.html">Log</a> chunks or entries associated with node_id. </p>

</div>
</div>
<a id="a031e4f5ab45a70e7c5d13d02e4ed986c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031e4f5ab45a70e7c5d13d02e4ed986c">&#9670;&nbsp;</a></span>num_Entries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Log_entries_Map::size_type fz::Log::num_Entries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect entries to chunks if that was not done during <a class="el" href="classfz_1_1Log__entry.html">Log_entry</a> construction. (2-pass method.) </p>
<p>tables: sizes </p>

</div>
</div>
<a id="a98819789423a2712d06bae307e4313ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98819789423a2712d06bae307e4313ed">&#9670;&nbsp;</a></span>oldest_Node_chain_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structfz_1_1Log__chain__target.html">Log_chain_target</a> * fz::Log::oldest_Node_chain_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfz_1_1Node__ID.html">Node_ID</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notice that the set of tests in the while-loop are necessary here. </p>
<p>You cannot simply test if prev_in_chain() is nullptr. See the explanation above LogtypesID.cpp:next_in_chain() and the referenced debugging example. </p>

</div>
</div>
<a id="aca44b6d200efa57834fe9358f2d1c001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca44b6d200efa57834fe9358f2d1c001">&#9670;&nbsp;</a></span>prune_duplicate_chunks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long fz::Log::prune_duplicate_chunks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this after loading entries into the <a class="el" href="classfz_1_1Log.html">Log</a> with valid <a class="el" href="classfz_1_1Graph.html">Graph</a>. </p>
<p>Prune duplicate chunks.</p>
<p>Note that this does not take care of entries that may be connected to a pruned chunk. In other words, this is better done before <a class="el" href="classfz_1_1Log.html#a6901a00db8db29ba3f1bc31ce4664c20" title="Remove any duplicate Log chunks.">add_entries_to_chunks()</a>.</p>
<p>NOTE: Now that chunks is a map this function is probably superfluous. </p>

</div>
</div>
<a id="ad90229e620a657e83de68e649430936f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90229e620a657e83de68e649430936f">&#9670;&nbsp;</a></span>setup_Chain_nodeprevnext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::Log::setup_Chain_nodeprevnext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finalizing setup </p>
<p>Parse the deque list of <a class="el" href="classfz_1_1Log.html">Log</a> chunks, as well as their entries, and assign all references in <code>node_prev</code>, <code>node_next</code>, and their rapid-access pointers.</p>
<p>This is all done using references by ID within the <a class="el" href="classfz_1_1Log.html">Log</a> data structure. No <a class="el" href="classfz_1_1Graph.html">Graph</a> object is required. </p>

</div>
</div>
<a id="a090e563e5880cf3508d1b878f4ea7f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090e563e5880cf3508d1b878f4ea7f78">&#9670;&nbsp;</a></span>setup_Chunk_node_caches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::Log::setup_Chunk_node_caches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this after loading entries into the <a class="el" href="classfz_1_1Log.html">Log</a> with valid <a class="el" href="classfz_1_1Graph.html">Graph</a>. </p>
<p>Parse the deque of <a class="el" href="classfz_1_1Log.html">Log</a> chunks and assign all <code>node</code> cache pointers in acordance with <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> objects found in the <a class="el" href="classfz_1_1Graph.html">Graph</a>. </p>

</div>
</div>
<a id="afacb23e680bd446379c6597b62d27fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afacb23e680bd446379c6597b62d27fb7">&#9670;&nbsp;</a></span>setup_Entry_node_caches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fz::Log::setup_Entry_node_caches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this after loading chunks and entries into the <a class="el" href="classfz_1_1Log.html">Log</a>. </p>
<p>Parse the map of <a class="el" href="classfz_1_1Log.html">Log</a> entries and assign all <code>node</code> cache pointers in acordance with <a class="el" href="classfz_1_1Node.html" title="The Node class is the principal object type within a Formalizer Graph.">Node</a> objects found in the <a class="el" href="classfz_1_1Graph.html">Graph</a>. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a536d7fb0f2241d8e0053f4b4318b9bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536d7fb0f2241d8e0053f4b4318b9bbb">&#9670;&nbsp;</a></span>Breakpoint_Indices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Log_chunks_Map::iterator&gt; Breakpoint_Indices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This converts the list of <a class="el" href="classfz_1_1Log.html">Log</a> breakpoint <a class="el" href="classfz_1_1Log.html">Log</a> chunk IDs into a list of indices into the list of <a class="el" href="classfz_1_1Log.html">Log</a> chunks (in Log::chunks). </p>
<p>Note: All <a class="el" href="classfz_1_1Log.html">Log</a> chunks must be loaded into memory before calling this function.</p>
<p>If a breakpoint was not found then the corresponding element of the vector of indices has the value log::num_Chunks(), pointing beyond all valid <a class="el" href="classfz_1_1Log.html">Log</a> chunks in the deque.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>a <a class="el" href="classfz_1_1Log.html">Log</a> object where all <a class="el" href="classfz_1_1Log.html">Log</a> chunks are in the chunks deque. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of indices into log::chunks. </dd></dl>

</div>
</div>
<a id="a5a5d49ed9cde163bba6d34a6eaa5f154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5d49ed9cde163bba6d34a6eaa5f154">&#9670;&nbsp;</a></span>Chunks_per_Breakpoint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; Chunks_per_Breakpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the frequency distribution for the number of <a class="el" href="classfz_1_1Log.html">Log</a> chunks per <a class="el" href="classfz_1_1Log.html">Log</a> breakpoint. </p>
<p>Note: All <a class="el" href="classfz_1_1Log.html">Log</a> chunks must be loaded into memory before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>a <a class="el" href="classfz_1_1Log.html">Log</a> object where all <a class="el" href="classfz_1_1Log.html">Log</a> chunks are in the chunks deque. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of counts. </dd></dl>

</div>
</div>
<a id="a49bce55e40ccb0a64160c64e30acaaa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49bce55e40ccb0a64160c64e30acaaa0">&#9670;&nbsp;</a></span>Log_span_in_days</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Log_span_in_days </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report the span in days from when the <a class="el" href="classfz_1_1Log.html">Log</a> was started (first cunk) to its most recent chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>the <a class="el" href="classfz_1_1Log.html">Log</a> for which to report the span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the decimal number of days. </dd></dl>

</div>
</div>
<a id="aff8571d0bb6aad25c78696fc8c3dcc1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8571d0bb6aad25c78696fc8c3dcc1a">&#9670;&nbsp;</a></span>Log_span_in_seconds</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Log_span_in_seconds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report the span in seconds from when the <a class="el" href="classfz_1_1Log.html">Log</a> was started (first cunk) to its most recent chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>the <a class="el" href="classfz_1_1Log.html">Log</a> for which to report the span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of seconds. </dd></dl>

</div>
</div>
<a id="aaf04470fdb14a1ee2b7271a55413b583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf04470fdb14a1ee2b7271a55413b583">&#9670;&nbsp;</a></span>Log_span_years_months_days</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ymd_tuple Log_span_years_months_days </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfz_1_1Log.html">Log</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report the span in years, months and days from when the <a class="el" href="classfz_1_1Log.html">Log</a> was started (first cunk) to its most recent chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>the <a class="el" href="classfz_1_1Log.html">Log</a> for which to report the span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple of [year, month, day]. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>core/include/<a class="el" href="Logtypes_8hpp_source.html">Logtypes.hpp</a></li>
<li>core/lib/Logtypes.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
