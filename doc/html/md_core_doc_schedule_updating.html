<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Formalizer: Formalizer: Schedule Updating</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="formalizer-logo-20200907-41x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Formalizer
   &#160;<span id="projectnumber">2.0.0-0.1</span>
   </div>
   <div id="projectbrief">The Formalizer System Support Environment</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Formalizer: Schedule Updating </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document describes up a Schedule is automatically updated with the Formalizer v2.x. Links within this document lead to additional information.</p>
<p>This document was started as part of Node <a href="http://localhost/cgi-bin/fzlink.py?id=20240614082648.1">20240614082648.1</a>.</p>
<h1>Programs used to auto-update the Schedule</h1>
<p>Updating the Schedule via a form link in an HTML page is done by calling:</p>
<div class="fragment"><div class="line">/cgi-bin/fzupdate-cgi.py</div>
</div><!-- fragment --><p>The CGI script expects the parameter <code>update</code> with one of the following values:</p>
<ol type="1">
<li><code>repeating</code></li>
<li><code>variable</code></li>
<li><code>both</code></li>
</ol>
<p>If <code>both</code> is selected then it causes 2 successive <code>fzupdate</code> calls, first to update <code>repeating</code> and then to update <code>variable</code>.</p>
<p>An emulated time can be provided through the parameter <code>T_emulate</code>. The number of days to map can be provided through the parameter <code>map_days</code> and normally defaults to 14 days. That default value can be modified through the <code>.formalizer/config/fzupdate/config.json</code> file.</p>
<p>To carry out the update, a Formalizer core program, <code>fzupdate</code> is called. To update <code>repeating</code> the call is:</p>
<div class="fragment"><div class="line">fzupdate -r -t &lt;T_emulate&gt; </div>
</div><!-- fragment --><p>The Nodes that were modified during the update can be inspected in the NNL <code>repeating_updated</code>.</p>
<p>To update <code>variable</code> the call is:</p>
<div class="fragment"><div class="line">fzupdate -u -t &lt;T_emulate&gt; -D &lt;map_days&gt;</div>
</div><!-- fragment --><p>The Nodes that were modified during the update can be inspected in the NNL <code>batch_updated</code>.</p>
<p>There are additional ways to call the CGI script with script <code>update</code> values <code>passedfixed</code> or <code>convert_passedfixed</code>:</p>
<ul>
<li><code>passedfixed</code>: This uses a serial API request to find fixed target date Nodes with a target date that has passed and puts those into a <code>passed_fixed</code> NNL.</li>
<li><code>convert_passedfixed</code>: This edits the Nodes found in the <code>passed_fixed</code> NNL to change their target date property to <code>variable</code>.</li>
</ul>
<h1>Updating repeating Nodes</h1>
<p>The <code>fzupdate -r</code> call updates repeating Nodes.</p>
<p>This creates a request in shared memory and uses a TCP call to the <code>fzserverpq</code> to run the <code>shm_server_handlers.cpp:handle_request_stack()</code> function. In that function, the case <code>batchmod_tpassrepeating</code> is activated. It carries out the update using the function <code>Graphmodify.cpp:Graph_modify_batch_node_tpassrepeating()</code>.</p>
<p>That function does the following:</p>
<ol type="1">
<li>Collects a list of repeating Nodes with target dates up to a specified <code>tpass</code> TD through a call to <code>Graphinfo.cpp:<a class="el" href="namespacefz.html#ab002cb5dc36910bcd7e0541fa0a416e2" title="Selects all Nodes that are incomplete and repeating and lists them by (inherited) target date.">Nodes_incomplete_and_repeating_by_targetdate()</a></code>.</li>
<li>Updates the target dates of Nodes in that list that have target dates that were passed by calling the function <code>Graphmodify.cpp:Update_repeating_Nodes()</code>.</li>
</ol>
<p>The Nodes that were updated are placed in the NNL <code>repeating_updated</code>.</p>
<h1>Updating variable Nodes</h1>
<p>The <code>fzupdate -u</code> call updates variable target date Nodes with the <code>update_variable()</code> function of <code>fzupdate.cpp</code>.</p>
<ol type="1">
<li>A time limit, <code>t_limit</code>, is set. Normally, this is <code>t_pass</code> plus the number of days in <code>config.map_days</code>. Alternatively, a specific <code>t_limit</code> may have been requested that must be smaller or equal to <code>t_pass</code>. To keep updates from exploding, if <code>t_limit</code> was set to <code>RTt_maxtime</code> it is instead set to a TD that is sufficient to complete all non-repeating Nodes.</li>
<li>Constraints are initialized. The <code><a class="el" href="structupdate__constraints.html">update_constraints</a></code> struct is used for that. It contains <code>t_fetchlimit</code>, <code>chunks_per_week</code>, <code>num_nodes_with_repeating</code>, <code>chunks_req_total</code>, <code>weeks_for_nonperiodic</code>, <code>days_in_map</code>. The <code>f_fetchlimit</code> is <code>t_limit</code> plus <code>config.fetch_days_beyond_t_limit</code> (defaults to 30). The <code>chunks_per_week</code> is determined based on <code>config.chunk_minutes</code>.</li>
<li>Edit flags are set to edit target dates.</li>
<li>Collect all incomplete Nodes, including repeats up to <code>constraints.t_fetchlimit</code>.</li>
<li>A vector containing EPS data (<code>chunks_req</code>, <code>epsflags</code>, <code>t_eps</code>) is initialized. There is one set of data for each entry in the list of incomplete Nodes. For each entry, the time required to complete a Node is used to set <code>chunks_req</code> (with more than 36 hours being considered 'suspicious'). The <code>t_eps</code> variable is initialized to <code>RTt_maxtime</code> for each. We now know how many chunks are needed for each Node in the incomplete Nodes list.</li>
<li>The total number of chunks needed for all incomplete Nodes up to <code>t_limit</code> is calculated. This is used to set necessary values in the <code><a class="el" href="structupdate__constraints.html">update_constraints</a></code> structure, namely values for <code>num_nodes_with_repeating</code>, <code>chunks_req_total</code>, <code>weeks_for_nonperiodic</code> (with a minimum of 1), <code>days_in_map</code>.</li>
<li>An <code><a class="el" href="structEPS__map.html">EPS_map</a></code> is initialized using <code>t_pass</code>, <code>constraints.days_in_map</code>, the list of incomplete Nodes, and the vector of <code>epsdata</code>. A number of so-called 'slots' is allocated for each chunk, because the <code><a class="el" href="structEPS__map.html">EPS_map</a></code> works with 5 minute slots for a more detailed mapping. While the <code>starttime</code> is set to the time from which to start mapping (usually current time, unless a time is being emulated), the <code>firstdaystart</code> is set to the start of the first day in the map and <code>t_beyond</code> is set to the start of the first day after the <code>days_in_map</code>. Slots already passed before <code>starttime</code> are discounted in <code>firstday_slotspassed</code> and the <code>first_slot_td</code> is determined accordingly. All of the necessary <code>slots</code> are initialized with their corresponding TDs. The <code>next_slot</code> to handle is initialized to the beginning of that <code>slots</code> list. A <code>node_vector_index</code> list is created so that every Node in the list of incomplete Nodes with repeats has a corresponding index number. We now have a look-up table that matches Node ID keys to entries in the EPS data vector.</li>
<li><b>Exact target date Nodes</b> are placed in the map up to <code>t_limit</code>. Slots are reserved for these Nodes in accordance with their chunks required. The reserved slots for each line up to reserve time as if for an appointment that has to happen at exactly that time. Where there is overlap between such Nodes, this is noted. It is also noted if repeated Nodes have periodicity less than a year.</li>
<li><b>Fixed target date Nodes</b> are placed in the map up to <code>t_limit</code>. Note that this also includes Nodes that specify they <b>inherit</b> a target date and do so from an <code>origin</code> that is a Node with <b>fixed</b> target date. In this case of inheritance, the EPS data <code>epsflags</code> note it as <code>treatgroupable</code>, and assigning slots is done in the step for <em>moveable Nodes</em>. Otherwise, slots are immediately reserved and it is noted whether available slots are insufficient. Slots are reserved from the target date backwards (to earlier times), using any available slots. It is also noted if repeated Nodes have periodicity less than a year.</li>
<li><b>Moveable Nodes</b> are placed, meaning Nodes with <b>variable</b> or <b>unspecified</b> target dates. See detailing in the subsection below.</li>
<li>Nodes to update are collected from the EPS map and requests are made to update them to their new target dates.</li>
</ol>
<p>Note that there is an alternative method called <code>pack_moveable</code>, but that method is off by default and is presently typically left off in the <code>config.json</code>. The <code>pack_moveable</code> option attempts to pack more moveables into the map instead of leaving them undisturbed if their target dates are beyond <code>t_limit</code>.</p>
<h2>Exact TD Nodes</h2>
<p>The process for Nodes with exact target dates has no optionality, since it is assumed that those must be dealt with at exactly the indicated times.</p>
<h2>Fixed TD Nodes</h2>
<p>Time for Nodes with fixed target dates is found in the map such that a Node could by completed by its target date, but without any randomization of assigned slots or chunks at the stage when the EPS map is created. This greatly simplifies the process.</p>
<p>Randomization could be applied as a secondary step when suggesting a day-calendar of Nodes to work on.</p>
<h2>Variable TD Nodes</h2>
<p>This process applies to all Nodes marked <code>variable</code> TD, <code>unspecified</code> TD, or EPS <code>treatgroupable</code>.</p>
<p>Processing is done in terms of so-called EPS groups, i.e. groups of Node that are treated as having the same target dates.</p>
<p>For each group, an attempt is made to find enough slots to allocate time for all of the Nodes in the group. Nodes are allocated to slots starting from the earliest available slot to the latest.</p>
<p>A <em>new target date is proposed</em> for each Node in a processed group once slots have been found for all the Nodes in the group.</p>
<p>Once insufficient slots are found, remaining Nodes to be processed are marked with the EPS flag <code>insufficient</code>. There is some special treatment here in the case of <code>pack_moveable</code>.</p>
<h1>New directions for Schedule handling</h1>
<ol type="1">
<li>VTD Nodes should continue to be handled as they are, namely that they are supposed to be completed by their specified target dates, and that Nodes where the target date has not been passed don't - normally - get modified.</li>
<li>Ordinarily, updating VTD Nodes should only involve updating those where target dates have been passed, so that perhaps we switch away from modifying those to earlier target dates that are within the specified Schedule window.</li>
<li>With rules 1. and 2. above, space remains, and that space gets filled with the list of UTD Nodes, Nodes with unspecified target dates. For this to work well, most, or almost all of my typical VTD Nodes will need to become UTD Nodes, because only in a few cases do you really want to get things done by a particular target date - but you are open to shifting those dates as needed.</li>
<li>Clearly, this does make FTD and VTD Nodes seem more similar, with the principal difference being that FTD Nodes require manual attention to modify target dates.</li>
<li>Wherever there are true dependencies, i.e. something really can only be done when dependency tasks have been completed, those serious dependencies should use the ITD (Inherited Target Date) method. This should apply regardless whether the superior in question is of FTD or VTD type. If the superior is of fixed type then the inheriting dependencies need to be placed in the schedule before VTD Nodes, otherwise along with them. UTD placement always comes last. Note that UTD Nodes should not be scheduled to have the same target date as the superior, because that can cause them to be placed in the Schedule in the wrong order. They should have effective target dates generated for use in Scheduling that are earlier than the superior they make possible (this is wrong in Schedule updates right now).</li>
<li>Giving Nodes ITD type should be encouraged. To make that feasible, it needs to be taken into account that one tends to underestimate time needed. That means, ITD Nodes cannot use a placement method that works backwards from the superior's target date, because some extra time needs to be available. Using UTD type more will greatly reduce time needed to update the Schedule manually.</li>
<li>UTD Node placement must carefully use the dependency tree hierarchy to decide the order of Nodes.</li>
<li>It is good to be able to inspect what Schedule updating is doing by checking an HTML version of the map as it is being generated from step to step.</li>
</ol>
<hr  />
<p> Randal A. Koene, 20240617 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
